// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"dtPYO":[function(require,module,exports) {
var _typeOf = require("@swc/helpers/_/_type_of");
var global = arguments[3];
(function() {
    function r(e, n, t) {
        function o(i, f) {
            if (!n[i]) {
                if (!e[i]) {
                    var c = undefined;
                    if (!f && c) return c(i, !0);
                    if (u) return u(i, !0);
                    var a = new Error("Cannot find module '" + i + "'");
                    throw a.code = "MODULE_NOT_FOUND", a;
                }
                var p = n[i] = {
                    exports: {}
                };
                e[i][0].call(p.exports, function(r) {
                    var _$n = e[i][1][r];
                    return o(_$n || r);
                }, p, p.exports, r, e, n, t);
            }
            return n[i].exports;
        }
        for(var u = undefined, i = 0; i < t.length; i++)o(t[i]);
        return o;
    }
    return r;
})()({
    1: [
        function(require1, module, exports) {
            /*!
  * Bootstrap v4.6.2 (https://getbootstrap.com/)
  * Copyright 2011-2022 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */ (function(global, factory) {
                typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require1("jquery"), require1("popper.js")) : typeof define === "function" && define.amd ? define([
                    "exports",
                    "jquery",
                    "popper.js"
                ], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.bootstrap = {}, global.jQuery, global.Popper));
            })(this, function(exports, $, Popper) {
                "use strict";
                function _interopDefaultLegacy(e) {
                    return e && typeof e === "object" && "default" in e ? e : {
                        "default": e
                    };
                }
                var $__default = /*#__PURE__*/ _interopDefaultLegacy($);
                var Popper__default = /*#__PURE__*/ _interopDefaultLegacy(Popper);
                function _defineProperties(target, props) {
                    for(var i = 0; i < props.length; i++){
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) _defineProperties(Constructor, staticProps);
                    Object.defineProperty(Constructor, "prototype", {
                        writable: false
                    });
                    return Constructor;
                }
                function _extends() {
                    _extends = Object.assign ? Object.assign.bind() : function _extends(target) {
                        for(var i = 1; i < arguments.length; i++){
                            var source = arguments[i];
                            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
                        }
                        return target;
                    };
                    return _extends.apply(this, arguments);
                }
                function _inheritsLoose(subClass, superClass) {
                    subClass.prototype = Object.create(superClass.prototype);
                    subClass.prototype.constructor = subClass;
                    _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
                        o.__proto__ = p;
                        return o;
                    };
                    return _setPrototypeOf(o, p);
                }
                /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.6.2): util.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */ /**
   * Private TransitionEnd Helpers
   */ var TRANSITION_END = "transitionend";
                var MAX_UID = 1000000;
                var MILLISECONDS_MULTIPLIER = 1000; // Shoutout AngusCroll (https://goo.gl/pxwQGp)
                function toType(obj) {
                    if (obj === null || typeof obj === "undefined") return "" + obj;
                    return ({}).toString.call(obj).match(/\s([a-z]+)/i)[1].toLowerCase();
                }
                function getSpecialTransitionEndEvent() {
                    return {
                        bindType: TRANSITION_END,
                        delegateType: TRANSITION_END,
                        handle: function handle(event) {
                            if ($__default["default"](event.target).is(this)) return event.handleObj.handler.apply(this, arguments); // eslint-disable-line prefer-rest-params
                            return undefined;
                        }
                    };
                }
                function transitionEndEmulator(duration) {
                    var _this = this;
                    var called = false;
                    $__default["default"](this).one(Util.TRANSITION_END, function() {
                        called = true;
                    });
                    setTimeout(function() {
                        if (!called) Util.triggerTransitionEnd(_this);
                    }, duration);
                    return this;
                }
                function setTransitionEndSupport() {
                    $__default["default"].fn.emulateTransitionEnd = transitionEndEmulator;
                    $__default["default"].event.special[Util.TRANSITION_END] = getSpecialTransitionEndEvent();
                }
                /**
   * Public Util API
   */ var Util = {
                    TRANSITION_END: "bsTransitionEnd",
                    getUID: function getUID(prefix) {
                        do // eslint-disable-next-line no-bitwise
                        prefix += ~~(Math.random() * MAX_UID); // "~~" acts like a faster Math.floor() here
                        while (document.getElementById(prefix));
                        return prefix;
                    },
                    getSelectorFromElement: function getSelectorFromElement(element) {
                        var selector = element.getAttribute("data-target");
                        if (!selector || selector === "#") {
                            var hrefAttr = element.getAttribute("href");
                            selector = hrefAttr && hrefAttr !== "#" ? hrefAttr.trim() : "";
                        }
                        try {
                            return document.querySelector(selector) ? selector : null;
                        } catch (_) {
                            return null;
                        }
                    },
                    getTransitionDurationFromElement: function getTransitionDurationFromElement(element) {
                        if (!element) return 0;
                         // Get transition-duration of the element
                        var transitionDuration = $__default["default"](element).css("transition-duration");
                        var transitionDelay = $__default["default"](element).css("transition-delay");
                        var floatTransitionDuration = parseFloat(transitionDuration);
                        var floatTransitionDelay = parseFloat(transitionDelay); // Return 0 if element or transition duration is not found
                        if (!floatTransitionDuration && !floatTransitionDelay) return 0;
                         // If multiple durations are defined, take the first
                        transitionDuration = transitionDuration.split(",")[0];
                        transitionDelay = transitionDelay.split(",")[0];
                        return (parseFloat(transitionDuration) + parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
                    },
                    reflow: function reflow(element) {
                        return element.offsetHeight;
                    },
                    triggerTransitionEnd: function triggerTransitionEnd(element) {
                        $__default["default"](element).trigger(TRANSITION_END);
                    },
                    supportsTransitionEnd: function supportsTransitionEnd() {
                        return Boolean(TRANSITION_END);
                    },
                    isElement: function isElement(obj) {
                        return (obj[0] || obj).nodeType;
                    },
                    typeCheckConfig: function typeCheckConfig(componentName, config, configTypes) {
                        for(var property in configTypes)if (Object.prototype.hasOwnProperty.call(configTypes, property)) {
                            var expectedTypes = configTypes[property];
                            var value = config[property];
                            var valueType = value && Util.isElement(value) ? "element" : toType(value);
                            if (!new RegExp(expectedTypes).test(valueType)) throw new Error(componentName.toUpperCase() + ": " + ('Option "' + property + '" provided type "' + valueType + '" ') + ('but expected type "' + expectedTypes + '".'));
                        }
                    },
                    findShadowRoot: function findShadowRoot(element) {
                        if (!document.documentElement.attachShadow) return null;
                         // Can find the shadow root otherwise it'll return the document
                        if (typeof element.getRootNode === "function") {
                            var root = element.getRootNode();
                            return root instanceof ShadowRoot ? root : null;
                        }
                        if (element instanceof ShadowRoot) return element;
                         // when we don't find a shadow root
                        if (!element.parentNode) return null;
                        return Util.findShadowRoot(element.parentNode);
                    },
                    jQueryDetection: function jQueryDetection() {
                        if (typeof $__default["default"] === "undefined") throw new TypeError("Bootstrap's JavaScript requires jQuery. jQuery must be included before Bootstrap's JavaScript.");
                        var version = $__default["default"].fn.jquery.split(" ")[0].split(".");
                        var minMajor = 1;
                        var ltMajor = 2;
                        var minMinor = 9;
                        var minPatch = 1;
                        var maxMajor = 4;
                        if (version[0] < ltMajor && version[1] < minMinor || version[0] === minMajor && version[1] === minMinor && version[2] < minPatch || version[0] >= maxMajor) throw new Error("Bootstrap's JavaScript requires at least jQuery v1.9.1 but less than v4.0.0");
                    }
                };
                Util.jQueryDetection();
                setTransitionEndSupport();
                /**
   * Constants
   */ var NAME$a = "alert";
                var VERSION$a = "4.6.2";
                var DATA_KEY$a = "bs.alert";
                var EVENT_KEY$a = "." + DATA_KEY$a;
                var DATA_API_KEY$7 = ".data-api";
                var JQUERY_NO_CONFLICT$a = $__default["default"].fn[NAME$a];
                var CLASS_NAME_ALERT = "alert";
                var CLASS_NAME_FADE$5 = "fade";
                var CLASS_NAME_SHOW$7 = "show";
                var EVENT_CLOSE = "close" + EVENT_KEY$a;
                var EVENT_CLOSED = "closed" + EVENT_KEY$a;
                var EVENT_CLICK_DATA_API$6 = "click" + EVENT_KEY$a + DATA_API_KEY$7;
                var SELECTOR_DISMISS = '[data-dismiss="alert"]';
                /**
   * Class definition
   */ var Alert = /*#__PURE__*/ function() {
                    function Alert(element) {
                        this._element = element;
                    } // Getters
                    var _proto = Alert.prototype;
                    // Public
                    _proto.close = function close(element) {
                        var rootElement = this._element;
                        if (element) rootElement = this._getRootElement(element);
                        var customEvent = this._triggerCloseEvent(rootElement);
                        if (customEvent.isDefaultPrevented()) return;
                        this._removeElement(rootElement);
                    };
                    _proto.dispose = function dispose() {
                        $__default["default"].removeData(this._element, DATA_KEY$a);
                        this._element = null;
                    } // Private
                    ;
                    _proto._getRootElement = function _getRootElement(element) {
                        var selector = Util.getSelectorFromElement(element);
                        var parent = false;
                        if (selector) parent = document.querySelector(selector);
                        if (!parent) parent = $__default["default"](element).closest("." + CLASS_NAME_ALERT)[0];
                        return parent;
                    };
                    _proto._triggerCloseEvent = function _triggerCloseEvent(element) {
                        var closeEvent = $__default["default"].Event(EVENT_CLOSE);
                        $__default["default"](element).trigger(closeEvent);
                        return closeEvent;
                    };
                    _proto._removeElement = function _removeElement(element) {
                        var _this = this;
                        $__default["default"](element).removeClass(CLASS_NAME_SHOW$7);
                        if (!$__default["default"](element).hasClass(CLASS_NAME_FADE$5)) {
                            this._destroyElement(element);
                            return;
                        }
                        var transitionDuration = Util.getTransitionDurationFromElement(element);
                        $__default["default"](element).one(Util.TRANSITION_END, function(event) {
                            return _this._destroyElement(element, event);
                        }).emulateTransitionEnd(transitionDuration);
                    };
                    _proto._destroyElement = function _destroyElement(element) {
                        $__default["default"](element).detach().trigger(EVENT_CLOSED).remove();
                    } // Static
                    ;
                    Alert._jQueryInterface = function _jQueryInterface(config) {
                        return this.each(function() {
                            var $element = $__default["default"](this);
                            var data = $element.data(DATA_KEY$a);
                            if (!data) {
                                data = new Alert(this);
                                $element.data(DATA_KEY$a, data);
                            }
                            if (config === "close") data[config](this);
                        });
                    };
                    Alert._handleDismiss = function _handleDismiss(alertInstance) {
                        return function(event) {
                            if (event) event.preventDefault();
                            alertInstance.close(this);
                        };
                    };
                    _createClass(Alert, null, [
                        {
                            key: "VERSION",
                            get: function get() {
                                return VERSION$a;
                            }
                        }
                    ]);
                    return Alert;
                }();
                /**
   * Data API implementation
   */ $__default["default"](document).on(EVENT_CLICK_DATA_API$6, SELECTOR_DISMISS, Alert._handleDismiss(new Alert()));
                /**
   * jQuery
   */ $__default["default"].fn[NAME$a] = Alert._jQueryInterface;
                $__default["default"].fn[NAME$a].Constructor = Alert;
                $__default["default"].fn[NAME$a].noConflict = function() {
                    $__default["default"].fn[NAME$a] = JQUERY_NO_CONFLICT$a;
                    return Alert._jQueryInterface;
                };
                /**
   * Constants
   */ var NAME$9 = "button";
                var VERSION$9 = "4.6.2";
                var DATA_KEY$9 = "bs.button";
                var EVENT_KEY$9 = "." + DATA_KEY$9;
                var DATA_API_KEY$6 = ".data-api";
                var JQUERY_NO_CONFLICT$9 = $__default["default"].fn[NAME$9];
                var CLASS_NAME_ACTIVE$3 = "active";
                var CLASS_NAME_BUTTON = "btn";
                var CLASS_NAME_FOCUS = "focus";
                var EVENT_CLICK_DATA_API$5 = "click" + EVENT_KEY$9 + DATA_API_KEY$6;
                var EVENT_FOCUS_BLUR_DATA_API = "focus" + EVENT_KEY$9 + DATA_API_KEY$6 + " " + ("blur" + EVENT_KEY$9 + DATA_API_KEY$6);
                var EVENT_LOAD_DATA_API$2 = "load" + EVENT_KEY$9 + DATA_API_KEY$6;
                var SELECTOR_DATA_TOGGLE_CARROT = '[data-toggle^="button"]';
                var SELECTOR_DATA_TOGGLES = '[data-toggle="buttons"]';
                var SELECTOR_DATA_TOGGLE$4 = '[data-toggle="button"]';
                var SELECTOR_DATA_TOGGLES_BUTTONS = '[data-toggle="buttons"] .btn';
                var SELECTOR_INPUT = 'input:not([type="hidden"])';
                var SELECTOR_ACTIVE$2 = ".active";
                var SELECTOR_BUTTON = ".btn";
                /**
   * Class definition
   */ var Button = /*#__PURE__*/ function() {
                    function Button(element) {
                        this._element = element;
                        this.shouldAvoidTriggerChange = false;
                    } // Getters
                    var _proto = Button.prototype;
                    // Public
                    _proto.toggle = function toggle() {
                        var triggerChangeEvent = true;
                        var addAriaPressed = true;
                        var rootElement = $__default["default"](this._element).closest(SELECTOR_DATA_TOGGLES)[0];
                        if (rootElement) {
                            var input = this._element.querySelector(SELECTOR_INPUT);
                            if (input) {
                                if (input.type === "radio") {
                                    if (input.checked && this._element.classList.contains(CLASS_NAME_ACTIVE$3)) triggerChangeEvent = false;
                                    else {
                                        var activeElement = rootElement.querySelector(SELECTOR_ACTIVE$2);
                                        if (activeElement) $__default["default"](activeElement).removeClass(CLASS_NAME_ACTIVE$3);
                                    }
                                }
                                if (triggerChangeEvent) {
                                    // if it's not a radio button or checkbox don't add a pointless/invalid checked property to the input
                                    if (input.type === "checkbox" || input.type === "radio") input.checked = !this._element.classList.contains(CLASS_NAME_ACTIVE$3);
                                    if (!this.shouldAvoidTriggerChange) $__default["default"](input).trigger("change");
                                }
                                input.focus();
                                addAriaPressed = false;
                            }
                        }
                        if (!(this._element.hasAttribute("disabled") || this._element.classList.contains("disabled"))) {
                            if (addAriaPressed) this._element.setAttribute("aria-pressed", !this._element.classList.contains(CLASS_NAME_ACTIVE$3));
                            if (triggerChangeEvent) $__default["default"](this._element).toggleClass(CLASS_NAME_ACTIVE$3);
                        }
                    };
                    _proto.dispose = function dispose() {
                        $__default["default"].removeData(this._element, DATA_KEY$9);
                        this._element = null;
                    } // Static
                    ;
                    Button._jQueryInterface = function _jQueryInterface(config, avoidTriggerChange) {
                        return this.each(function() {
                            var $element = $__default["default"](this);
                            var data = $element.data(DATA_KEY$9);
                            if (!data) {
                                data = new Button(this);
                                $element.data(DATA_KEY$9, data);
                            }
                            data.shouldAvoidTriggerChange = avoidTriggerChange;
                            if (config === "toggle") data[config]();
                        });
                    };
                    _createClass(Button, null, [
                        {
                            key: "VERSION",
                            get: function get() {
                                return VERSION$9;
                            }
                        }
                    ]);
                    return Button;
                }();
                /**
   * Data API implementation
   */ $__default["default"](document).on(EVENT_CLICK_DATA_API$5, SELECTOR_DATA_TOGGLE_CARROT, function(event) {
                    var button = event.target;
                    var initialButton = button;
                    if (!$__default["default"](button).hasClass(CLASS_NAME_BUTTON)) button = $__default["default"](button).closest(SELECTOR_BUTTON)[0];
                    if (!button || button.hasAttribute("disabled") || button.classList.contains("disabled")) event.preventDefault(); // work around Firefox bug #1540995
                    else {
                        var inputBtn = button.querySelector(SELECTOR_INPUT);
                        if (inputBtn && (inputBtn.hasAttribute("disabled") || inputBtn.classList.contains("disabled"))) {
                            event.preventDefault(); // work around Firefox bug #1540995
                            return;
                        }
                        if (initialButton.tagName === "INPUT" || button.tagName !== "LABEL") Button._jQueryInterface.call($__default["default"](button), "toggle", initialButton.tagName === "INPUT");
                    }
                }).on(EVENT_FOCUS_BLUR_DATA_API, SELECTOR_DATA_TOGGLE_CARROT, function(event) {
                    var button = $__default["default"](event.target).closest(SELECTOR_BUTTON)[0];
                    $__default["default"](button).toggleClass(CLASS_NAME_FOCUS, /^focus(in)?$/.test(event.type));
                });
                $__default["default"](window).on(EVENT_LOAD_DATA_API$2, function() {
                    // ensure correct active class is set to match the controls' actual values/states
                    // find all checkboxes/readio buttons inside data-toggle groups
                    var buttons = [].slice.call(document.querySelectorAll(SELECTOR_DATA_TOGGLES_BUTTONS));
                    for(var i = 0, len = buttons.length; i < len; i++){
                        var button = buttons[i];
                        var input = button.querySelector(SELECTOR_INPUT);
                        if (input.checked || input.hasAttribute("checked")) button.classList.add(CLASS_NAME_ACTIVE$3);
                        else button.classList.remove(CLASS_NAME_ACTIVE$3);
                    } // find all button toggles
                    buttons = [].slice.call(document.querySelectorAll(SELECTOR_DATA_TOGGLE$4));
                    for(var _i = 0, _len = buttons.length; _i < _len; _i++){
                        var _button = buttons[_i];
                        if (_button.getAttribute("aria-pressed") === "true") _button.classList.add(CLASS_NAME_ACTIVE$3);
                        else _button.classList.remove(CLASS_NAME_ACTIVE$3);
                    }
                });
                /**
   * jQuery
   */ $__default["default"].fn[NAME$9] = Button._jQueryInterface;
                $__default["default"].fn[NAME$9].Constructor = Button;
                $__default["default"].fn[NAME$9].noConflict = function() {
                    $__default["default"].fn[NAME$9] = JQUERY_NO_CONFLICT$9;
                    return Button._jQueryInterface;
                };
                /**
   * Constants
   */ var NAME$8 = "carousel";
                var VERSION$8 = "4.6.2";
                var DATA_KEY$8 = "bs.carousel";
                var EVENT_KEY$8 = "." + DATA_KEY$8;
                var DATA_API_KEY$5 = ".data-api";
                var JQUERY_NO_CONFLICT$8 = $__default["default"].fn[NAME$8];
                var ARROW_LEFT_KEYCODE = 37; // KeyboardEvent.which value for left arrow key
                var ARROW_RIGHT_KEYCODE = 39; // KeyboardEvent.which value for right arrow key
                var TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch
                var SWIPE_THRESHOLD = 40;
                var CLASS_NAME_CAROUSEL = "carousel";
                var CLASS_NAME_ACTIVE$2 = "active";
                var CLASS_NAME_SLIDE = "slide";
                var CLASS_NAME_RIGHT = "carousel-item-right";
                var CLASS_NAME_LEFT = "carousel-item-left";
                var CLASS_NAME_NEXT = "carousel-item-next";
                var CLASS_NAME_PREV = "carousel-item-prev";
                var CLASS_NAME_POINTER_EVENT = "pointer-event";
                var DIRECTION_NEXT = "next";
                var DIRECTION_PREV = "prev";
                var DIRECTION_LEFT = "left";
                var DIRECTION_RIGHT = "right";
                var EVENT_SLIDE = "slide" + EVENT_KEY$8;
                var EVENT_SLID = "slid" + EVENT_KEY$8;
                var EVENT_KEYDOWN = "keydown" + EVENT_KEY$8;
                var EVENT_MOUSEENTER = "mouseenter" + EVENT_KEY$8;
                var EVENT_MOUSELEAVE = "mouseleave" + EVENT_KEY$8;
                var EVENT_TOUCHSTART = "touchstart" + EVENT_KEY$8;
                var EVENT_TOUCHMOVE = "touchmove" + EVENT_KEY$8;
                var EVENT_TOUCHEND = "touchend" + EVENT_KEY$8;
                var EVENT_POINTERDOWN = "pointerdown" + EVENT_KEY$8;
                var EVENT_POINTERUP = "pointerup" + EVENT_KEY$8;
                var EVENT_DRAG_START = "dragstart" + EVENT_KEY$8;
                var EVENT_LOAD_DATA_API$1 = "load" + EVENT_KEY$8 + DATA_API_KEY$5;
                var EVENT_CLICK_DATA_API$4 = "click" + EVENT_KEY$8 + DATA_API_KEY$5;
                var SELECTOR_ACTIVE$1 = ".active";
                var SELECTOR_ACTIVE_ITEM = ".active.carousel-item";
                var SELECTOR_ITEM = ".carousel-item";
                var SELECTOR_ITEM_IMG = ".carousel-item img";
                var SELECTOR_NEXT_PREV = ".carousel-item-next, .carousel-item-prev";
                var SELECTOR_INDICATORS = ".carousel-indicators";
                var SELECTOR_DATA_SLIDE = "[data-slide], [data-slide-to]";
                var SELECTOR_DATA_RIDE = '[data-ride="carousel"]';
                var Default$7 = {
                    interval: 5000,
                    keyboard: true,
                    slide: false,
                    pause: "hover",
                    wrap: true,
                    touch: true
                };
                var DefaultType$7 = {
                    interval: "(number|boolean)",
                    keyboard: "boolean",
                    slide: "(boolean|string)",
                    pause: "(string|boolean)",
                    wrap: "boolean",
                    touch: "boolean"
                };
                var PointerType = {
                    TOUCH: "touch",
                    PEN: "pen"
                };
                /**
   * Class definition
   */ var Carousel = /*#__PURE__*/ function() {
                    function Carousel(element, config) {
                        this._items = null;
                        this._interval = null;
                        this._activeElement = null;
                        this._isPaused = false;
                        this._isSliding = false;
                        this.touchTimeout = null;
                        this.touchStartX = 0;
                        this.touchDeltaX = 0;
                        this._config = this._getConfig(config);
                        this._element = element;
                        this._indicatorsElement = this._element.querySelector(SELECTOR_INDICATORS);
                        this._touchSupported = "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0;
                        this._pointerEvent = Boolean(window.PointerEvent || window.MSPointerEvent);
                        this._addEventListeners();
                    } // Getters
                    var _proto = Carousel.prototype;
                    // Public
                    _proto.next = function next() {
                        if (!this._isSliding) this._slide(DIRECTION_NEXT);
                    };
                    _proto.nextWhenVisible = function nextWhenVisible() {
                        var $element = $__default["default"](this._element); // Don't call next when the page isn't visible
                        // or the carousel or its parent isn't visible
                        if (!document.hidden && $element.is(":visible") && $element.css("visibility") !== "hidden") this.next();
                    };
                    _proto.prev = function prev() {
                        if (!this._isSliding) this._slide(DIRECTION_PREV);
                    };
                    _proto.pause = function pause(event) {
                        if (!event) this._isPaused = true;
                        if (this._element.querySelector(SELECTOR_NEXT_PREV)) {
                            Util.triggerTransitionEnd(this._element);
                            this.cycle(true);
                        }
                        clearInterval(this._interval);
                        this._interval = null;
                    };
                    _proto.cycle = function cycle(event) {
                        if (!event) this._isPaused = false;
                        if (this._interval) {
                            clearInterval(this._interval);
                            this._interval = null;
                        }
                        if (this._config.interval && !this._isPaused) {
                            this._updateInterval();
                            this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);
                        }
                    };
                    _proto.to = function to(index) {
                        var _this = this;
                        this._activeElement = this._element.querySelector(SELECTOR_ACTIVE_ITEM);
                        var activeIndex = this._getItemIndex(this._activeElement);
                        if (index > this._items.length - 1 || index < 0) return;
                        if (this._isSliding) {
                            $__default["default"](this._element).one(EVENT_SLID, function() {
                                return _this.to(index);
                            });
                            return;
                        }
                        if (activeIndex === index) {
                            this.pause();
                            this.cycle();
                            return;
                        }
                        var direction = index > activeIndex ? DIRECTION_NEXT : DIRECTION_PREV;
                        this._slide(direction, this._items[index]);
                    };
                    _proto.dispose = function dispose() {
                        $__default["default"](this._element).off(EVENT_KEY$8);
                        $__default["default"].removeData(this._element, DATA_KEY$8);
                        this._items = null;
                        this._config = null;
                        this._element = null;
                        this._interval = null;
                        this._isPaused = null;
                        this._isSliding = null;
                        this._activeElement = null;
                        this._indicatorsElement = null;
                    } // Private
                    ;
                    _proto._getConfig = function _getConfig(config) {
                        config = _extends({}, Default$7, config);
                        Util.typeCheckConfig(NAME$8, config, DefaultType$7);
                        return config;
                    };
                    _proto._handleSwipe = function _handleSwipe() {
                        var absDeltax = Math.abs(this.touchDeltaX);
                        if (absDeltax <= SWIPE_THRESHOLD) return;
                        var direction = absDeltax / this.touchDeltaX;
                        this.touchDeltaX = 0; // swipe left
                        if (direction > 0) this.prev();
                         // swipe right
                        if (direction < 0) this.next();
                    };
                    _proto._addEventListeners = function _addEventListeners() {
                        var _this2 = this;
                        if (this._config.keyboard) $__default["default"](this._element).on(EVENT_KEYDOWN, function(event) {
                            return _this2._keydown(event);
                        });
                        if (this._config.pause === "hover") $__default["default"](this._element).on(EVENT_MOUSEENTER, function(event) {
                            return _this2.pause(event);
                        }).on(EVENT_MOUSELEAVE, function(event) {
                            return _this2.cycle(event);
                        });
                        if (this._config.touch) this._addTouchEventListeners();
                    };
                    _proto._addTouchEventListeners = function _addTouchEventListeners() {
                        var _this3 = this;
                        if (!this._touchSupported) return;
                        var start = function start(event) {
                            if (_this3._pointerEvent && PointerType[event.originalEvent.pointerType.toUpperCase()]) _this3.touchStartX = event.originalEvent.clientX;
                            else if (!_this3._pointerEvent) _this3.touchStartX = event.originalEvent.touches[0].clientX;
                        };
                        var move = function move(event) {
                            // ensure swiping with one touch and not pinching
                            _this3.touchDeltaX = event.originalEvent.touches && event.originalEvent.touches.length > 1 ? 0 : event.originalEvent.touches[0].clientX - _this3.touchStartX;
                        };
                        var end = function end(event) {
                            if (_this3._pointerEvent && PointerType[event.originalEvent.pointerType.toUpperCase()]) _this3.touchDeltaX = event.originalEvent.clientX - _this3.touchStartX;
                            _this3._handleSwipe();
                            if (_this3._config.pause === "hover") {
                                // If it's a touch-enabled device, mouseenter/leave are fired as
                                // part of the mouse compatibility events on first tap - the carousel
                                // would stop cycling until user tapped out of it;
                                // here, we listen for touchend, explicitly pause the carousel
                                // (as if it's the second time we tap on it, mouseenter compat event
                                // is NOT fired) and after a timeout (to allow for mouse compatibility
                                // events to fire) we explicitly restart cycling
                                _this3.pause();
                                if (_this3.touchTimeout) clearTimeout(_this3.touchTimeout);
                                _this3.touchTimeout = setTimeout(function(event) {
                                    return _this3.cycle(event);
                                }, TOUCHEVENT_COMPAT_WAIT + _this3._config.interval);
                            }
                        };
                        $__default["default"](this._element.querySelectorAll(SELECTOR_ITEM_IMG)).on(EVENT_DRAG_START, function(e) {
                            return e.preventDefault();
                        });
                        if (this._pointerEvent) {
                            $__default["default"](this._element).on(EVENT_POINTERDOWN, function(event) {
                                return start(event);
                            });
                            $__default["default"](this._element).on(EVENT_POINTERUP, function(event) {
                                return end(event);
                            });
                            this._element.classList.add(CLASS_NAME_POINTER_EVENT);
                        } else {
                            $__default["default"](this._element).on(EVENT_TOUCHSTART, function(event) {
                                return start(event);
                            });
                            $__default["default"](this._element).on(EVENT_TOUCHMOVE, function(event) {
                                return move(event);
                            });
                            $__default["default"](this._element).on(EVENT_TOUCHEND, function(event) {
                                return end(event);
                            });
                        }
                    };
                    _proto._keydown = function _keydown(event) {
                        if (/input|textarea/i.test(event.target.tagName)) return;
                        switch(event.which){
                            case ARROW_LEFT_KEYCODE:
                                event.preventDefault();
                                this.prev();
                                break;
                            case ARROW_RIGHT_KEYCODE:
                                event.preventDefault();
                                this.next();
                                break;
                        }
                    };
                    _proto._getItemIndex = function _getItemIndex(element) {
                        this._items = element && element.parentNode ? [].slice.call(element.parentNode.querySelectorAll(SELECTOR_ITEM)) : [];
                        return this._items.indexOf(element);
                    };
                    _proto._getItemByDirection = function _getItemByDirection(direction, activeElement) {
                        var isNextDirection = direction === DIRECTION_NEXT;
                        var isPrevDirection = direction === DIRECTION_PREV;
                        var activeIndex = this._getItemIndex(activeElement);
                        var lastItemIndex = this._items.length - 1;
                        var isGoingToWrap = isPrevDirection && activeIndex === 0 || isNextDirection && activeIndex === lastItemIndex;
                        if (isGoingToWrap && !this._config.wrap) return activeElement;
                        var delta = direction === DIRECTION_PREV ? -1 : 1;
                        var itemIndex = (activeIndex + delta) % this._items.length;
                        return itemIndex === -1 ? this._items[this._items.length - 1] : this._items[itemIndex];
                    };
                    _proto._triggerSlideEvent = function _triggerSlideEvent(relatedTarget, eventDirectionName) {
                        var targetIndex = this._getItemIndex(relatedTarget);
                        var fromIndex = this._getItemIndex(this._element.querySelector(SELECTOR_ACTIVE_ITEM));
                        var slideEvent = $__default["default"].Event(EVENT_SLIDE, {
                            relatedTarget: relatedTarget,
                            direction: eventDirectionName,
                            from: fromIndex,
                            to: targetIndex
                        });
                        $__default["default"](this._element).trigger(slideEvent);
                        return slideEvent;
                    };
                    _proto._setActiveIndicatorElement = function _setActiveIndicatorElement(element) {
                        if (this._indicatorsElement) {
                            var indicators = [].slice.call(this._indicatorsElement.querySelectorAll(SELECTOR_ACTIVE$1));
                            $__default["default"](indicators).removeClass(CLASS_NAME_ACTIVE$2);
                            var nextIndicator = this._indicatorsElement.children[this._getItemIndex(element)];
                            if (nextIndicator) $__default["default"](nextIndicator).addClass(CLASS_NAME_ACTIVE$2);
                        }
                    };
                    _proto._updateInterval = function _updateInterval() {
                        var element = this._activeElement || this._element.querySelector(SELECTOR_ACTIVE_ITEM);
                        if (!element) return;
                        var elementInterval = parseInt(element.getAttribute("data-interval"), 10);
                        if (elementInterval) {
                            this._config.defaultInterval = this._config.defaultInterval || this._config.interval;
                            this._config.interval = elementInterval;
                        } else this._config.interval = this._config.defaultInterval || this._config.interval;
                    };
                    _proto._slide = function _slide(direction, element) {
                        var _this4 = this;
                        var activeElement = this._element.querySelector(SELECTOR_ACTIVE_ITEM);
                        var activeElementIndex = this._getItemIndex(activeElement);
                        var nextElement = element || activeElement && this._getItemByDirection(direction, activeElement);
                        var nextElementIndex = this._getItemIndex(nextElement);
                        var isCycling = Boolean(this._interval);
                        var directionalClassName;
                        var orderClassName;
                        var eventDirectionName;
                        if (direction === DIRECTION_NEXT) {
                            directionalClassName = CLASS_NAME_LEFT;
                            orderClassName = CLASS_NAME_NEXT;
                            eventDirectionName = DIRECTION_LEFT;
                        } else {
                            directionalClassName = CLASS_NAME_RIGHT;
                            orderClassName = CLASS_NAME_PREV;
                            eventDirectionName = DIRECTION_RIGHT;
                        }
                        if (nextElement && $__default["default"](nextElement).hasClass(CLASS_NAME_ACTIVE$2)) {
                            this._isSliding = false;
                            return;
                        }
                        var slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);
                        if (slideEvent.isDefaultPrevented()) return;
                        if (!activeElement || !nextElement) // Some weirdness is happening, so we bail
                        return;
                        this._isSliding = true;
                        if (isCycling) this.pause();
                        this._setActiveIndicatorElement(nextElement);
                        this._activeElement = nextElement;
                        var slidEvent = $__default["default"].Event(EVENT_SLID, {
                            relatedTarget: nextElement,
                            direction: eventDirectionName,
                            from: activeElementIndex,
                            to: nextElementIndex
                        });
                        if ($__default["default"](this._element).hasClass(CLASS_NAME_SLIDE)) {
                            $__default["default"](nextElement).addClass(orderClassName);
                            Util.reflow(nextElement);
                            $__default["default"](activeElement).addClass(directionalClassName);
                            $__default["default"](nextElement).addClass(directionalClassName);
                            var transitionDuration = Util.getTransitionDurationFromElement(activeElement);
                            $__default["default"](activeElement).one(Util.TRANSITION_END, function() {
                                $__default["default"](nextElement).removeClass(directionalClassName + " " + orderClassName).addClass(CLASS_NAME_ACTIVE$2);
                                $__default["default"](activeElement).removeClass(CLASS_NAME_ACTIVE$2 + " " + orderClassName + " " + directionalClassName);
                                _this4._isSliding = false;
                                setTimeout(function() {
                                    return $__default["default"](_this4._element).trigger(slidEvent);
                                }, 0);
                            }).emulateTransitionEnd(transitionDuration);
                        } else {
                            $__default["default"](activeElement).removeClass(CLASS_NAME_ACTIVE$2);
                            $__default["default"](nextElement).addClass(CLASS_NAME_ACTIVE$2);
                            this._isSliding = false;
                            $__default["default"](this._element).trigger(slidEvent);
                        }
                        if (isCycling) this.cycle();
                    } // Static
                    ;
                    Carousel._jQueryInterface = function _jQueryInterface(config) {
                        return this.each(function() {
                            var data = $__default["default"](this).data(DATA_KEY$8);
                            var _config = _extends({}, Default$7, $__default["default"](this).data());
                            if (typeof config === "object") _config = _extends({}, _config, config);
                            var action = typeof config === "string" ? config : _config.slide;
                            if (!data) {
                                data = new Carousel(this, _config);
                                $__default["default"](this).data(DATA_KEY$8, data);
                            }
                            if (typeof config === "number") data.to(config);
                            else if (typeof action === "string") {
                                if (typeof data[action] === "undefined") throw new TypeError('No method named "' + action + '"');
                                data[action]();
                            } else if (_config.interval && _config.ride) {
                                data.pause();
                                data.cycle();
                            }
                        });
                    };
                    Carousel._dataApiClickHandler = function _dataApiClickHandler(event) {
                        var selector = Util.getSelectorFromElement(this);
                        if (!selector) return;
                        var target = $__default["default"](selector)[0];
                        if (!target || !$__default["default"](target).hasClass(CLASS_NAME_CAROUSEL)) return;
                        var config = _extends({}, $__default["default"](target).data(), $__default["default"](this).data());
                        var slideIndex = this.getAttribute("data-slide-to");
                        if (slideIndex) config.interval = false;
                        Carousel._jQueryInterface.call($__default["default"](target), config);
                        if (slideIndex) $__default["default"](target).data(DATA_KEY$8).to(slideIndex);
                        event.preventDefault();
                    };
                    _createClass(Carousel, null, [
                        {
                            key: "VERSION",
                            get: function get() {
                                return VERSION$8;
                            }
                        },
                        {
                            key: "Default",
                            get: function get() {
                                return Default$7;
                            }
                        }
                    ]);
                    return Carousel;
                }();
                /**
   * Data API implementation
   */ $__default["default"](document).on(EVENT_CLICK_DATA_API$4, SELECTOR_DATA_SLIDE, Carousel._dataApiClickHandler);
                $__default["default"](window).on(EVENT_LOAD_DATA_API$1, function() {
                    var carousels = [].slice.call(document.querySelectorAll(SELECTOR_DATA_RIDE));
                    for(var i = 0, len = carousels.length; i < len; i++){
                        var $carousel = $__default["default"](carousels[i]);
                        Carousel._jQueryInterface.call($carousel, $carousel.data());
                    }
                });
                /**
   * jQuery
   */ $__default["default"].fn[NAME$8] = Carousel._jQueryInterface;
                $__default["default"].fn[NAME$8].Constructor = Carousel;
                $__default["default"].fn[NAME$8].noConflict = function() {
                    $__default["default"].fn[NAME$8] = JQUERY_NO_CONFLICT$8;
                    return Carousel._jQueryInterface;
                };
                /**
   * Constants
   */ var NAME$7 = "collapse";
                var VERSION$7 = "4.6.2";
                var DATA_KEY$7 = "bs.collapse";
                var EVENT_KEY$7 = "." + DATA_KEY$7;
                var DATA_API_KEY$4 = ".data-api";
                var JQUERY_NO_CONFLICT$7 = $__default["default"].fn[NAME$7];
                var CLASS_NAME_SHOW$6 = "show";
                var CLASS_NAME_COLLAPSE = "collapse";
                var CLASS_NAME_COLLAPSING = "collapsing";
                var CLASS_NAME_COLLAPSED = "collapsed";
                var DIMENSION_WIDTH = "width";
                var DIMENSION_HEIGHT = "height";
                var EVENT_SHOW$4 = "show" + EVENT_KEY$7;
                var EVENT_SHOWN$4 = "shown" + EVENT_KEY$7;
                var EVENT_HIDE$4 = "hide" + EVENT_KEY$7;
                var EVENT_HIDDEN$4 = "hidden" + EVENT_KEY$7;
                var EVENT_CLICK_DATA_API$3 = "click" + EVENT_KEY$7 + DATA_API_KEY$4;
                var SELECTOR_ACTIVES = ".show, .collapsing";
                var SELECTOR_DATA_TOGGLE$3 = '[data-toggle="collapse"]';
                var Default$6 = {
                    toggle: true,
                    parent: ""
                };
                var DefaultType$6 = {
                    toggle: "boolean",
                    parent: "(string|element)"
                };
                /**
   * Class definition
   */ var Collapse = /*#__PURE__*/ function() {
                    function Collapse(element, config) {
                        this._isTransitioning = false;
                        this._element = element;
                        this._config = this._getConfig(config);
                        this._triggerArray = [].slice.call(document.querySelectorAll('[data-toggle="collapse"][href="#' + element.id + '"],' + ('[data-toggle="collapse"][data-target="#' + element.id + '"]')));
                        var toggleList = [].slice.call(document.querySelectorAll(SELECTOR_DATA_TOGGLE$3));
                        for(var i = 0, len = toggleList.length; i < len; i++){
                            var elem = toggleList[i];
                            var selector = Util.getSelectorFromElement(elem);
                            var filterElement = [].slice.call(document.querySelectorAll(selector)).filter(function(foundElem) {
                                return foundElem === element;
                            });
                            if (selector !== null && filterElement.length > 0) {
                                this._selector = selector;
                                this._triggerArray.push(elem);
                            }
                        }
                        this._parent = this._config.parent ? this._getParent() : null;
                        if (!this._config.parent) this._addAriaAndCollapsedClass(this._element, this._triggerArray);
                        if (this._config.toggle) this.toggle();
                    } // Getters
                    var _proto = Collapse.prototype;
                    // Public
                    _proto.toggle = function toggle() {
                        if ($__default["default"](this._element).hasClass(CLASS_NAME_SHOW$6)) this.hide();
                        else this.show();
                    };
                    _proto.show = function show() {
                        var _this = this;
                        if (this._isTransitioning || $__default["default"](this._element).hasClass(CLASS_NAME_SHOW$6)) return;
                        var actives;
                        var activesData;
                        if (this._parent) {
                            actives = [].slice.call(this._parent.querySelectorAll(SELECTOR_ACTIVES)).filter(function(elem) {
                                if (typeof _this._config.parent === "string") return elem.getAttribute("data-parent") === _this._config.parent;
                                return elem.classList.contains(CLASS_NAME_COLLAPSE);
                            });
                            if (actives.length === 0) actives = null;
                        }
                        if (actives) {
                            activesData = $__default["default"](actives).not(this._selector).data(DATA_KEY$7);
                            if (activesData && activesData._isTransitioning) return;
                        }
                        var startEvent = $__default["default"].Event(EVENT_SHOW$4);
                        $__default["default"](this._element).trigger(startEvent);
                        if (startEvent.isDefaultPrevented()) return;
                        if (actives) {
                            Collapse._jQueryInterface.call($__default["default"](actives).not(this._selector), "hide");
                            if (!activesData) $__default["default"](actives).data(DATA_KEY$7, null);
                        }
                        var dimension = this._getDimension();
                        $__default["default"](this._element).removeClass(CLASS_NAME_COLLAPSE).addClass(CLASS_NAME_COLLAPSING);
                        this._element.style[dimension] = 0;
                        if (this._triggerArray.length) $__default["default"](this._triggerArray).removeClass(CLASS_NAME_COLLAPSED).attr("aria-expanded", true);
                        this.setTransitioning(true);
                        var complete = function complete() {
                            $__default["default"](_this._element).removeClass(CLASS_NAME_COLLAPSING).addClass(CLASS_NAME_COLLAPSE + " " + CLASS_NAME_SHOW$6);
                            _this._element.style[dimension] = "";
                            _this.setTransitioning(false);
                            $__default["default"](_this._element).trigger(EVENT_SHOWN$4);
                        };
                        var capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
                        var scrollSize = "scroll" + capitalizedDimension;
                        var transitionDuration = Util.getTransitionDurationFromElement(this._element);
                        $__default["default"](this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
                        this._element.style[dimension] = this._element[scrollSize] + "px";
                    };
                    _proto.hide = function hide() {
                        var _this2 = this;
                        if (this._isTransitioning || !$__default["default"](this._element).hasClass(CLASS_NAME_SHOW$6)) return;
                        var startEvent = $__default["default"].Event(EVENT_HIDE$4);
                        $__default["default"](this._element).trigger(startEvent);
                        if (startEvent.isDefaultPrevented()) return;
                        var dimension = this._getDimension();
                        this._element.style[dimension] = this._element.getBoundingClientRect()[dimension] + "px";
                        Util.reflow(this._element);
                        $__default["default"](this._element).addClass(CLASS_NAME_COLLAPSING).removeClass(CLASS_NAME_COLLAPSE + " " + CLASS_NAME_SHOW$6);
                        var triggerArrayLength = this._triggerArray.length;
                        if (triggerArrayLength > 0) for(var i = 0; i < triggerArrayLength; i++){
                            var trigger = this._triggerArray[i];
                            var selector = Util.getSelectorFromElement(trigger);
                            if (selector !== null) {
                                var $elem = $__default["default"]([].slice.call(document.querySelectorAll(selector)));
                                if (!$elem.hasClass(CLASS_NAME_SHOW$6)) $__default["default"](trigger).addClass(CLASS_NAME_COLLAPSED).attr("aria-expanded", false);
                            }
                        }
                        this.setTransitioning(true);
                        var complete = function complete() {
                            _this2.setTransitioning(false);
                            $__default["default"](_this2._element).removeClass(CLASS_NAME_COLLAPSING).addClass(CLASS_NAME_COLLAPSE).trigger(EVENT_HIDDEN$4);
                        };
                        this._element.style[dimension] = "";
                        var transitionDuration = Util.getTransitionDurationFromElement(this._element);
                        $__default["default"](this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
                    };
                    _proto.setTransitioning = function setTransitioning(isTransitioning) {
                        this._isTransitioning = isTransitioning;
                    };
                    _proto.dispose = function dispose() {
                        $__default["default"].removeData(this._element, DATA_KEY$7);
                        this._config = null;
                        this._parent = null;
                        this._element = null;
                        this._triggerArray = null;
                        this._isTransitioning = null;
                    } // Private
                    ;
                    _proto._getConfig = function _getConfig(config) {
                        config = _extends({}, Default$6, config);
                        config.toggle = Boolean(config.toggle); // Coerce string values
                        Util.typeCheckConfig(NAME$7, config, DefaultType$6);
                        return config;
                    };
                    _proto._getDimension = function _getDimension() {
                        var hasWidth = $__default["default"](this._element).hasClass(DIMENSION_WIDTH);
                        return hasWidth ? DIMENSION_WIDTH : DIMENSION_HEIGHT;
                    };
                    _proto._getParent = function _getParent() {
                        var _this3 = this;
                        var parent;
                        if (Util.isElement(this._config.parent)) {
                            parent = this._config.parent; // It's a jQuery object
                            if (typeof this._config.parent.jquery !== "undefined") parent = this._config.parent[0];
                        } else parent = document.querySelector(this._config.parent);
                        var selector = '[data-toggle="collapse"][data-parent="' + this._config.parent + '"]';
                        var children = [].slice.call(parent.querySelectorAll(selector));
                        $__default["default"](children).each(function(i, element) {
                            _this3._addAriaAndCollapsedClass(Collapse._getTargetFromElement(element), [
                                element
                            ]);
                        });
                        return parent;
                    };
                    _proto._addAriaAndCollapsedClass = function _addAriaAndCollapsedClass(element, triggerArray) {
                        var isOpen = $__default["default"](element).hasClass(CLASS_NAME_SHOW$6);
                        if (triggerArray.length) $__default["default"](triggerArray).toggleClass(CLASS_NAME_COLLAPSED, !isOpen).attr("aria-expanded", isOpen);
                    } // Static
                    ;
                    Collapse._getTargetFromElement = function _getTargetFromElement(element) {
                        var selector = Util.getSelectorFromElement(element);
                        return selector ? document.querySelector(selector) : null;
                    };
                    Collapse._jQueryInterface = function _jQueryInterface(config) {
                        return this.each(function() {
                            var $element = $__default["default"](this);
                            var data = $element.data(DATA_KEY$7);
                            var _config = _extends({}, Default$6, $element.data(), typeof config === "object" && config ? config : {});
                            if (!data && _config.toggle && typeof config === "string" && /show|hide/.test(config)) _config.toggle = false;
                            if (!data) {
                                data = new Collapse(this, _config);
                                $element.data(DATA_KEY$7, data);
                            }
                            if (typeof config === "string") {
                                if (typeof data[config] === "undefined") throw new TypeError('No method named "' + config + '"');
                                data[config]();
                            }
                        });
                    };
                    _createClass(Collapse, null, [
                        {
                            key: "VERSION",
                            get: function get() {
                                return VERSION$7;
                            }
                        },
                        {
                            key: "Default",
                            get: function get() {
                                return Default$6;
                            }
                        }
                    ]);
                    return Collapse;
                }();
                /**
   * Data API implementation
   */ $__default["default"](document).on(EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function(event) {
                    // preventDefault only for <a> elements (which change the URL) not inside the collapsible element
                    if (event.currentTarget.tagName === "A") event.preventDefault();
                    var $trigger = $__default["default"](this);
                    var selector = Util.getSelectorFromElement(this);
                    var selectors = [].slice.call(document.querySelectorAll(selector));
                    $__default["default"](selectors).each(function() {
                        var $target = $__default["default"](this);
                        var data = $target.data(DATA_KEY$7);
                        var config = data ? "toggle" : $trigger.data();
                        Collapse._jQueryInterface.call($target, config);
                    });
                });
                /**
   * jQuery
   */ $__default["default"].fn[NAME$7] = Collapse._jQueryInterface;
                $__default["default"].fn[NAME$7].Constructor = Collapse;
                $__default["default"].fn[NAME$7].noConflict = function() {
                    $__default["default"].fn[NAME$7] = JQUERY_NO_CONFLICT$7;
                    return Collapse._jQueryInterface;
                };
                /**
   * Constants
   */ var NAME$6 = "dropdown";
                var VERSION$6 = "4.6.2";
                var DATA_KEY$6 = "bs.dropdown";
                var EVENT_KEY$6 = "." + DATA_KEY$6;
                var DATA_API_KEY$3 = ".data-api";
                var JQUERY_NO_CONFLICT$6 = $__default["default"].fn[NAME$6];
                var ESCAPE_KEYCODE$1 = 27; // KeyboardEvent.which value for Escape (Esc) key
                var SPACE_KEYCODE = 32; // KeyboardEvent.which value for space key
                var TAB_KEYCODE = 9; // KeyboardEvent.which value for tab key
                var ARROW_UP_KEYCODE = 38; // KeyboardEvent.which value for up arrow key
                var ARROW_DOWN_KEYCODE = 40; // KeyboardEvent.which value for down arrow key
                var RIGHT_MOUSE_BUTTON_WHICH = 3; // MouseEvent.which value for the right button (assuming a right-handed mouse)
                var REGEXP_KEYDOWN = new RegExp(ARROW_UP_KEYCODE + "|" + ARROW_DOWN_KEYCODE + "|" + ESCAPE_KEYCODE$1);
                var CLASS_NAME_DISABLED$1 = "disabled";
                var CLASS_NAME_SHOW$5 = "show";
                var CLASS_NAME_DROPUP = "dropup";
                var CLASS_NAME_DROPRIGHT = "dropright";
                var CLASS_NAME_DROPLEFT = "dropleft";
                var CLASS_NAME_MENURIGHT = "dropdown-menu-right";
                var CLASS_NAME_POSITION_STATIC = "position-static";
                var EVENT_HIDE$3 = "hide" + EVENT_KEY$6;
                var EVENT_HIDDEN$3 = "hidden" + EVENT_KEY$6;
                var EVENT_SHOW$3 = "show" + EVENT_KEY$6;
                var EVENT_SHOWN$3 = "shown" + EVENT_KEY$6;
                var EVENT_CLICK = "click" + EVENT_KEY$6;
                var EVENT_CLICK_DATA_API$2 = "click" + EVENT_KEY$6 + DATA_API_KEY$3;
                var EVENT_KEYDOWN_DATA_API = "keydown" + EVENT_KEY$6 + DATA_API_KEY$3;
                var EVENT_KEYUP_DATA_API = "keyup" + EVENT_KEY$6 + DATA_API_KEY$3;
                var SELECTOR_DATA_TOGGLE$2 = '[data-toggle="dropdown"]';
                var SELECTOR_FORM_CHILD = ".dropdown form";
                var SELECTOR_MENU = ".dropdown-menu";
                var SELECTOR_NAVBAR_NAV = ".navbar-nav";
                var SELECTOR_VISIBLE_ITEMS = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)";
                var PLACEMENT_TOP = "top-start";
                var PLACEMENT_TOPEND = "top-end";
                var PLACEMENT_BOTTOM = "bottom-start";
                var PLACEMENT_BOTTOMEND = "bottom-end";
                var PLACEMENT_RIGHT = "right-start";
                var PLACEMENT_LEFT = "left-start";
                var Default$5 = {
                    offset: 0,
                    flip: true,
                    boundary: "scrollParent",
                    reference: "toggle",
                    display: "dynamic",
                    popperConfig: null
                };
                var DefaultType$5 = {
                    offset: "(number|string|function)",
                    flip: "boolean",
                    boundary: "(string|element)",
                    reference: "(string|element)",
                    display: "string",
                    popperConfig: "(null|object)"
                };
                /**
   * Class definition
   */ var Dropdown = /*#__PURE__*/ function() {
                    function Dropdown(element, config) {
                        this._element = element;
                        this._popper = null;
                        this._config = this._getConfig(config);
                        this._menu = this._getMenuElement();
                        this._inNavbar = this._detectNavbar();
                        this._addEventListeners();
                    } // Getters
                    var _proto = Dropdown.prototype;
                    // Public
                    _proto.toggle = function toggle() {
                        if (this._element.disabled || $__default["default"](this._element).hasClass(CLASS_NAME_DISABLED$1)) return;
                        var isActive = $__default["default"](this._menu).hasClass(CLASS_NAME_SHOW$5);
                        Dropdown._clearMenus();
                        if (isActive) return;
                        this.show(true);
                    };
                    _proto.show = function show(usePopper) {
                        if (usePopper === void 0) usePopper = false;
                        if (this._element.disabled || $__default["default"](this._element).hasClass(CLASS_NAME_DISABLED$1) || $__default["default"](this._menu).hasClass(CLASS_NAME_SHOW$5)) return;
                        var relatedTarget = {
                            relatedTarget: this._element
                        };
                        var showEvent = $__default["default"].Event(EVENT_SHOW$3, relatedTarget);
                        var parent = Dropdown._getParentFromElement(this._element);
                        $__default["default"](parent).trigger(showEvent);
                        if (showEvent.isDefaultPrevented()) return;
                         // Totally disable Popper for Dropdowns in Navbar
                        if (!this._inNavbar && usePopper) {
                            // Check for Popper dependency
                            if (typeof Popper__default["default"] === "undefined") throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
                            var referenceElement = this._element;
                            if (this._config.reference === "parent") referenceElement = parent;
                            else if (Util.isElement(this._config.reference)) {
                                referenceElement = this._config.reference; // Check if it's jQuery element
                                if (typeof this._config.reference.jquery !== "undefined") referenceElement = this._config.reference[0];
                            } // If boundary is not `scrollParent`, then set position to `static`
                            // to allow the menu to "escape" the scroll parent's boundaries
                            // https://github.com/twbs/bootstrap/issues/24251
                            if (this._config.boundary !== "scrollParent") $__default["default"](parent).addClass(CLASS_NAME_POSITION_STATIC);
                            this._popper = new Popper__default["default"](referenceElement, this._menu, this._getPopperConfig());
                        } // If this is a touch-enabled device we add extra
                        // empty mouseover listeners to the body's immediate children;
                        // only needed because of broken event delegation on iOS
                        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html
                        if ("ontouchstart" in document.documentElement && $__default["default"](parent).closest(SELECTOR_NAVBAR_NAV).length === 0) $__default["default"](document.body).children().on("mouseover", null, $__default["default"].noop);
                        this._element.focus();
                        this._element.setAttribute("aria-expanded", true);
                        $__default["default"](this._menu).toggleClass(CLASS_NAME_SHOW$5);
                        $__default["default"](parent).toggleClass(CLASS_NAME_SHOW$5).trigger($__default["default"].Event(EVENT_SHOWN$3, relatedTarget));
                    };
                    _proto.hide = function hide() {
                        if (this._element.disabled || $__default["default"](this._element).hasClass(CLASS_NAME_DISABLED$1) || !$__default["default"](this._menu).hasClass(CLASS_NAME_SHOW$5)) return;
                        var relatedTarget = {
                            relatedTarget: this._element
                        };
                        var hideEvent = $__default["default"].Event(EVENT_HIDE$3, relatedTarget);
                        var parent = Dropdown._getParentFromElement(this._element);
                        $__default["default"](parent).trigger(hideEvent);
                        if (hideEvent.isDefaultPrevented()) return;
                        if (this._popper) this._popper.destroy();
                        $__default["default"](this._menu).toggleClass(CLASS_NAME_SHOW$5);
                        $__default["default"](parent).toggleClass(CLASS_NAME_SHOW$5).trigger($__default["default"].Event(EVENT_HIDDEN$3, relatedTarget));
                    };
                    _proto.dispose = function dispose() {
                        $__default["default"].removeData(this._element, DATA_KEY$6);
                        $__default["default"](this._element).off(EVENT_KEY$6);
                        this._element = null;
                        this._menu = null;
                        if (this._popper !== null) {
                            this._popper.destroy();
                            this._popper = null;
                        }
                    };
                    _proto.update = function update() {
                        this._inNavbar = this._detectNavbar();
                        if (this._popper !== null) this._popper.scheduleUpdate();
                    } // Private
                    ;
                    _proto._addEventListeners = function _addEventListeners() {
                        var _this = this;
                        $__default["default"](this._element).on(EVENT_CLICK, function(event) {
                            event.preventDefault();
                            event.stopPropagation();
                            _this.toggle();
                        });
                    };
                    _proto._getConfig = function _getConfig(config) {
                        config = _extends({}, this.constructor.Default, $__default["default"](this._element).data(), config);
                        Util.typeCheckConfig(NAME$6, config, this.constructor.DefaultType);
                        return config;
                    };
                    _proto._getMenuElement = function _getMenuElement() {
                        if (!this._menu) {
                            var parent = Dropdown._getParentFromElement(this._element);
                            if (parent) this._menu = parent.querySelector(SELECTOR_MENU);
                        }
                        return this._menu;
                    };
                    _proto._getPlacement = function _getPlacement() {
                        var $parentDropdown = $__default["default"](this._element.parentNode);
                        var placement = PLACEMENT_BOTTOM; // Handle dropup
                        if ($parentDropdown.hasClass(CLASS_NAME_DROPUP)) placement = $__default["default"](this._menu).hasClass(CLASS_NAME_MENURIGHT) ? PLACEMENT_TOPEND : PLACEMENT_TOP;
                        else if ($parentDropdown.hasClass(CLASS_NAME_DROPRIGHT)) placement = PLACEMENT_RIGHT;
                        else if ($parentDropdown.hasClass(CLASS_NAME_DROPLEFT)) placement = PLACEMENT_LEFT;
                        else if ($__default["default"](this._menu).hasClass(CLASS_NAME_MENURIGHT)) placement = PLACEMENT_BOTTOMEND;
                        return placement;
                    };
                    _proto._detectNavbar = function _detectNavbar() {
                        return $__default["default"](this._element).closest(".navbar").length > 0;
                    };
                    _proto._getOffset = function _getOffset() {
                        var _this2 = this;
                        var offset = {};
                        if (typeof this._config.offset === "function") offset.fn = function(data) {
                            data.offsets = _extends({}, data.offsets, _this2._config.offset(data.offsets, _this2._element));
                            return data;
                        };
                        else offset.offset = this._config.offset;
                        return offset;
                    };
                    _proto._getPopperConfig = function _getPopperConfig() {
                        var popperConfig = {
                            placement: this._getPlacement(),
                            modifiers: {
                                offset: this._getOffset(),
                                flip: {
                                    enabled: this._config.flip
                                },
                                preventOverflow: {
                                    boundariesElement: this._config.boundary
                                }
                            }
                        }; // Disable Popper if we have a static display
                        if (this._config.display === "static") popperConfig.modifiers.applyStyle = {
                            enabled: false
                        };
                        return _extends({}, popperConfig, this._config.popperConfig);
                    } // Static
                    ;
                    Dropdown._jQueryInterface = function _jQueryInterface(config) {
                        return this.each(function() {
                            var data = $__default["default"](this).data(DATA_KEY$6);
                            var _config = typeof config === "object" ? config : null;
                            if (!data) {
                                data = new Dropdown(this, _config);
                                $__default["default"](this).data(DATA_KEY$6, data);
                            }
                            if (typeof config === "string") {
                                if (typeof data[config] === "undefined") throw new TypeError('No method named "' + config + '"');
                                data[config]();
                            }
                        });
                    };
                    Dropdown._clearMenus = function _clearMenus(event) {
                        if (event && (event.which === RIGHT_MOUSE_BUTTON_WHICH || event.type === "keyup" && event.which !== TAB_KEYCODE)) return;
                        var toggles = [].slice.call(document.querySelectorAll(SELECTOR_DATA_TOGGLE$2));
                        for(var i = 0, len = toggles.length; i < len; i++){
                            var parent = Dropdown._getParentFromElement(toggles[i]);
                            var context = $__default["default"](toggles[i]).data(DATA_KEY$6);
                            var relatedTarget = {
                                relatedTarget: toggles[i]
                            };
                            if (event && event.type === "click") relatedTarget.clickEvent = event;
                            if (!context) continue;
                            var dropdownMenu = context._menu;
                            if (!$__default["default"](parent).hasClass(CLASS_NAME_SHOW$5)) continue;
                            if (event && (event.type === "click" && /input|textarea/i.test(event.target.tagName) || event.type === "keyup" && event.which === TAB_KEYCODE) && $__default["default"].contains(parent, event.target)) continue;
                            var hideEvent = $__default["default"].Event(EVENT_HIDE$3, relatedTarget);
                            $__default["default"](parent).trigger(hideEvent);
                            if (hideEvent.isDefaultPrevented()) continue;
                             // If this is a touch-enabled device we remove the extra
                            // empty mouseover listeners we added for iOS support
                            if ("ontouchstart" in document.documentElement) $__default["default"](document.body).children().off("mouseover", null, $__default["default"].noop);
                            toggles[i].setAttribute("aria-expanded", "false");
                            if (context._popper) context._popper.destroy();
                            $__default["default"](dropdownMenu).removeClass(CLASS_NAME_SHOW$5);
                            $__default["default"](parent).removeClass(CLASS_NAME_SHOW$5).trigger($__default["default"].Event(EVENT_HIDDEN$3, relatedTarget));
                        }
                    };
                    Dropdown._getParentFromElement = function _getParentFromElement(element) {
                        var parent;
                        var selector = Util.getSelectorFromElement(element);
                        if (selector) parent = document.querySelector(selector);
                        return parent || element.parentNode;
                    } // eslint-disable-next-line complexity
                    ;
                    Dropdown._dataApiKeydownHandler = function _dataApiKeydownHandler(event) {
                        // If not input/textarea:
                        //  - And not a key in REGEXP_KEYDOWN => not a dropdown command
                        // If input/textarea:
                        //  - If space key => not a dropdown command
                        //  - If key is other than escape
                        //    - If key is not up or down => not a dropdown command
                        //    - If trigger inside the menu => not a dropdown command
                        if (/input|textarea/i.test(event.target.tagName) ? event.which === SPACE_KEYCODE || event.which !== ESCAPE_KEYCODE$1 && (event.which !== ARROW_DOWN_KEYCODE && event.which !== ARROW_UP_KEYCODE || $__default["default"](event.target).closest(SELECTOR_MENU).length) : !REGEXP_KEYDOWN.test(event.which)) return;
                        if (this.disabled || $__default["default"](this).hasClass(CLASS_NAME_DISABLED$1)) return;
                        var parent = Dropdown._getParentFromElement(this);
                        var isActive = $__default["default"](parent).hasClass(CLASS_NAME_SHOW$5);
                        if (!isActive && event.which === ESCAPE_KEYCODE$1) return;
                        event.preventDefault();
                        event.stopPropagation();
                        if (!isActive || event.which === ESCAPE_KEYCODE$1 || event.which === SPACE_KEYCODE) {
                            if (event.which === ESCAPE_KEYCODE$1) $__default["default"](parent.querySelector(SELECTOR_DATA_TOGGLE$2)).trigger("focus");
                            $__default["default"](this).trigger("click");
                            return;
                        }
                        var items = [].slice.call(parent.querySelectorAll(SELECTOR_VISIBLE_ITEMS)).filter(function(item) {
                            return $__default["default"](item).is(":visible");
                        });
                        if (items.length === 0) return;
                        var index = items.indexOf(event.target);
                        if (event.which === ARROW_UP_KEYCODE && index > 0) // Up
                        index--;
                        if (event.which === ARROW_DOWN_KEYCODE && index < items.length - 1) // Down
                        index++;
                        if (index < 0) index = 0;
                        items[index].focus();
                    };
                    _createClass(Dropdown, null, [
                        {
                            key: "VERSION",
                            get: function get() {
                                return VERSION$6;
                            }
                        },
                        {
                            key: "Default",
                            get: function get() {
                                return Default$5;
                            }
                        },
                        {
                            key: "DefaultType",
                            get: function get() {
                                return DefaultType$5;
                            }
                        }
                    ]);
                    return Dropdown;
                }();
                /**
   * Data API implementation
   */ $__default["default"](document).on(EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$2, Dropdown._dataApiKeydownHandler).on(EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown._dataApiKeydownHandler).on(EVENT_CLICK_DATA_API$2 + " " + EVENT_KEYUP_DATA_API, Dropdown._clearMenus).on(EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function(event) {
                    event.preventDefault();
                    event.stopPropagation();
                    Dropdown._jQueryInterface.call($__default["default"](this), "toggle");
                }).on(EVENT_CLICK_DATA_API$2, SELECTOR_FORM_CHILD, function(e) {
                    e.stopPropagation();
                });
                /**
   * jQuery
   */ $__default["default"].fn[NAME$6] = Dropdown._jQueryInterface;
                $__default["default"].fn[NAME$6].Constructor = Dropdown;
                $__default["default"].fn[NAME$6].noConflict = function() {
                    $__default["default"].fn[NAME$6] = JQUERY_NO_CONFLICT$6;
                    return Dropdown._jQueryInterface;
                };
                /**
   * Constants
   */ var NAME$5 = "modal";
                var VERSION$5 = "4.6.2";
                var DATA_KEY$5 = "bs.modal";
                var EVENT_KEY$5 = "." + DATA_KEY$5;
                var DATA_API_KEY$2 = ".data-api";
                var JQUERY_NO_CONFLICT$5 = $__default["default"].fn[NAME$5];
                var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key
                var CLASS_NAME_SCROLLABLE = "modal-dialog-scrollable";
                var CLASS_NAME_SCROLLBAR_MEASURER = "modal-scrollbar-measure";
                var CLASS_NAME_BACKDROP = "modal-backdrop";
                var CLASS_NAME_OPEN = "modal-open";
                var CLASS_NAME_FADE$4 = "fade";
                var CLASS_NAME_SHOW$4 = "show";
                var CLASS_NAME_STATIC = "modal-static";
                var EVENT_HIDE$2 = "hide" + EVENT_KEY$5;
                var EVENT_HIDE_PREVENTED = "hidePrevented" + EVENT_KEY$5;
                var EVENT_HIDDEN$2 = "hidden" + EVENT_KEY$5;
                var EVENT_SHOW$2 = "show" + EVENT_KEY$5;
                var EVENT_SHOWN$2 = "shown" + EVENT_KEY$5;
                var EVENT_FOCUSIN = "focusin" + EVENT_KEY$5;
                var EVENT_RESIZE = "resize" + EVENT_KEY$5;
                var EVENT_CLICK_DISMISS$1 = "click.dismiss" + EVENT_KEY$5;
                var EVENT_KEYDOWN_DISMISS = "keydown.dismiss" + EVENT_KEY$5;
                var EVENT_MOUSEUP_DISMISS = "mouseup.dismiss" + EVENT_KEY$5;
                var EVENT_MOUSEDOWN_DISMISS = "mousedown.dismiss" + EVENT_KEY$5;
                var EVENT_CLICK_DATA_API$1 = "click" + EVENT_KEY$5 + DATA_API_KEY$2;
                var SELECTOR_DIALOG = ".modal-dialog";
                var SELECTOR_MODAL_BODY = ".modal-body";
                var SELECTOR_DATA_TOGGLE$1 = '[data-toggle="modal"]';
                var SELECTOR_DATA_DISMISS$1 = '[data-dismiss="modal"]';
                var SELECTOR_FIXED_CONTENT = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top";
                var SELECTOR_STICKY_CONTENT = ".sticky-top";
                var Default$4 = {
                    backdrop: true,
                    keyboard: true,
                    focus: true,
                    show: true
                };
                var DefaultType$4 = {
                    backdrop: "(boolean|string)",
                    keyboard: "boolean",
                    focus: "boolean",
                    show: "boolean"
                };
                /**
   * Class definition
   */ var Modal = /*#__PURE__*/ function() {
                    function Modal(element, config) {
                        this._config = this._getConfig(config);
                        this._element = element;
                        this._dialog = element.querySelector(SELECTOR_DIALOG);
                        this._backdrop = null;
                        this._isShown = false;
                        this._isBodyOverflowing = false;
                        this._ignoreBackdropClick = false;
                        this._isTransitioning = false;
                        this._scrollbarWidth = 0;
                    } // Getters
                    var _proto = Modal.prototype;
                    // Public
                    _proto.toggle = function toggle(relatedTarget) {
                        return this._isShown ? this.hide() : this.show(relatedTarget);
                    };
                    _proto.show = function show(relatedTarget) {
                        var _this = this;
                        if (this._isShown || this._isTransitioning) return;
                        var showEvent = $__default["default"].Event(EVENT_SHOW$2, {
                            relatedTarget: relatedTarget
                        });
                        $__default["default"](this._element).trigger(showEvent);
                        if (showEvent.isDefaultPrevented()) return;
                        this._isShown = true;
                        if ($__default["default"](this._element).hasClass(CLASS_NAME_FADE$4)) this._isTransitioning = true;
                        this._checkScrollbar();
                        this._setScrollbar();
                        this._adjustDialog();
                        this._setEscapeEvent();
                        this._setResizeEvent();
                        $__default["default"](this._element).on(EVENT_CLICK_DISMISS$1, SELECTOR_DATA_DISMISS$1, function(event) {
                            return _this.hide(event);
                        });
                        $__default["default"](this._dialog).on(EVENT_MOUSEDOWN_DISMISS, function() {
                            $__default["default"](_this._element).one(EVENT_MOUSEUP_DISMISS, function(event) {
                                if ($__default["default"](event.target).is(_this._element)) _this._ignoreBackdropClick = true;
                            });
                        });
                        this._showBackdrop(function() {
                            return _this._showElement(relatedTarget);
                        });
                    };
                    _proto.hide = function hide(event) {
                        var _this2 = this;
                        if (event) event.preventDefault();
                        if (!this._isShown || this._isTransitioning) return;
                        var hideEvent = $__default["default"].Event(EVENT_HIDE$2);
                        $__default["default"](this._element).trigger(hideEvent);
                        if (!this._isShown || hideEvent.isDefaultPrevented()) return;
                        this._isShown = false;
                        var transition = $__default["default"](this._element).hasClass(CLASS_NAME_FADE$4);
                        if (transition) this._isTransitioning = true;
                        this._setEscapeEvent();
                        this._setResizeEvent();
                        $__default["default"](document).off(EVENT_FOCUSIN);
                        $__default["default"](this._element).removeClass(CLASS_NAME_SHOW$4);
                        $__default["default"](this._element).off(EVENT_CLICK_DISMISS$1);
                        $__default["default"](this._dialog).off(EVENT_MOUSEDOWN_DISMISS);
                        if (transition) {
                            var transitionDuration = Util.getTransitionDurationFromElement(this._element);
                            $__default["default"](this._element).one(Util.TRANSITION_END, function(event) {
                                return _this2._hideModal(event);
                            }).emulateTransitionEnd(transitionDuration);
                        } else this._hideModal();
                    };
                    _proto.dispose = function dispose() {
                        [
                            window,
                            this._element,
                            this._dialog
                        ].forEach(function(htmlElement) {
                            return $__default["default"](htmlElement).off(EVENT_KEY$5);
                        });
                        /**
       * `document` has 2 events `EVENT_FOCUSIN` and `EVENT_CLICK_DATA_API`
       * Do not move `document` in `htmlElements` array
       * It will remove `EVENT_CLICK_DATA_API` event that should remain
       */ $__default["default"](document).off(EVENT_FOCUSIN);
                        $__default["default"].removeData(this._element, DATA_KEY$5);
                        this._config = null;
                        this._element = null;
                        this._dialog = null;
                        this._backdrop = null;
                        this._isShown = null;
                        this._isBodyOverflowing = null;
                        this._ignoreBackdropClick = null;
                        this._isTransitioning = null;
                        this._scrollbarWidth = null;
                    };
                    _proto.handleUpdate = function handleUpdate() {
                        this._adjustDialog();
                    } // Private
                    ;
                    _proto._getConfig = function _getConfig(config) {
                        config = _extends({}, Default$4, config);
                        Util.typeCheckConfig(NAME$5, config, DefaultType$4);
                        return config;
                    };
                    _proto._triggerBackdropTransition = function _triggerBackdropTransition() {
                        var _this3 = this;
                        var hideEventPrevented = $__default["default"].Event(EVENT_HIDE_PREVENTED);
                        $__default["default"](this._element).trigger(hideEventPrevented);
                        if (hideEventPrevented.isDefaultPrevented()) return;
                        var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
                        if (!isModalOverflowing) this._element.style.overflowY = "hidden";
                        this._element.classList.add(CLASS_NAME_STATIC);
                        var modalTransitionDuration = Util.getTransitionDurationFromElement(this._dialog);
                        $__default["default"](this._element).off(Util.TRANSITION_END);
                        $__default["default"](this._element).one(Util.TRANSITION_END, function() {
                            _this3._element.classList.remove(CLASS_NAME_STATIC);
                            if (!isModalOverflowing) $__default["default"](_this3._element).one(Util.TRANSITION_END, function() {
                                _this3._element.style.overflowY = "";
                            }).emulateTransitionEnd(_this3._element, modalTransitionDuration);
                        }).emulateTransitionEnd(modalTransitionDuration);
                        this._element.focus();
                    };
                    _proto._showElement = function _showElement(relatedTarget) {
                        var _this4 = this;
                        var transition = $__default["default"](this._element).hasClass(CLASS_NAME_FADE$4);
                        var modalBody = this._dialog ? this._dialog.querySelector(SELECTOR_MODAL_BODY) : null;
                        if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) // Don't move modal's DOM position
                        document.body.appendChild(this._element);
                        this._element.style.display = "block";
                        this._element.removeAttribute("aria-hidden");
                        this._element.setAttribute("aria-modal", true);
                        this._element.setAttribute("role", "dialog");
                        if ($__default["default"](this._dialog).hasClass(CLASS_NAME_SCROLLABLE) && modalBody) modalBody.scrollTop = 0;
                        else this._element.scrollTop = 0;
                        if (transition) Util.reflow(this._element);
                        $__default["default"](this._element).addClass(CLASS_NAME_SHOW$4);
                        if (this._config.focus) this._enforceFocus();
                        var shownEvent = $__default["default"].Event(EVENT_SHOWN$2, {
                            relatedTarget: relatedTarget
                        });
                        var transitionComplete = function transitionComplete() {
                            if (_this4._config.focus) _this4._element.focus();
                            _this4._isTransitioning = false;
                            $__default["default"](_this4._element).trigger(shownEvent);
                        };
                        if (transition) {
                            var transitionDuration = Util.getTransitionDurationFromElement(this._dialog);
                            $__default["default"](this._dialog).one(Util.TRANSITION_END, transitionComplete).emulateTransitionEnd(transitionDuration);
                        } else transitionComplete();
                    };
                    _proto._enforceFocus = function _enforceFocus() {
                        var _this5 = this;
                        $__default["default"](document).off(EVENT_FOCUSIN) // Guard against infinite focus loop
                        .on(EVENT_FOCUSIN, function(event) {
                            if (document !== event.target && _this5._element !== event.target && $__default["default"](_this5._element).has(event.target).length === 0) _this5._element.focus();
                        });
                    };
                    _proto._setEscapeEvent = function _setEscapeEvent() {
                        var _this6 = this;
                        if (this._isShown) $__default["default"](this._element).on(EVENT_KEYDOWN_DISMISS, function(event) {
                            if (_this6._config.keyboard && event.which === ESCAPE_KEYCODE) {
                                event.preventDefault();
                                _this6.hide();
                            } else if (!_this6._config.keyboard && event.which === ESCAPE_KEYCODE) _this6._triggerBackdropTransition();
                        });
                        else if (!this._isShown) $__default["default"](this._element).off(EVENT_KEYDOWN_DISMISS);
                    };
                    _proto._setResizeEvent = function _setResizeEvent() {
                        var _this7 = this;
                        if (this._isShown) $__default["default"](window).on(EVENT_RESIZE, function(event) {
                            return _this7.handleUpdate(event);
                        });
                        else $__default["default"](window).off(EVENT_RESIZE);
                    };
                    _proto._hideModal = function _hideModal() {
                        var _this8 = this;
                        this._element.style.display = "none";
                        this._element.setAttribute("aria-hidden", true);
                        this._element.removeAttribute("aria-modal");
                        this._element.removeAttribute("role");
                        this._isTransitioning = false;
                        this._showBackdrop(function() {
                            $__default["default"](document.body).removeClass(CLASS_NAME_OPEN);
                            _this8._resetAdjustments();
                            _this8._resetScrollbar();
                            $__default["default"](_this8._element).trigger(EVENT_HIDDEN$2);
                        });
                    };
                    _proto._removeBackdrop = function _removeBackdrop() {
                        if (this._backdrop) {
                            $__default["default"](this._backdrop).remove();
                            this._backdrop = null;
                        }
                    };
                    _proto._showBackdrop = function _showBackdrop(callback) {
                        var _this9 = this;
                        var animate = $__default["default"](this._element).hasClass(CLASS_NAME_FADE$4) ? CLASS_NAME_FADE$4 : "";
                        if (this._isShown && this._config.backdrop) {
                            this._backdrop = document.createElement("div");
                            this._backdrop.className = CLASS_NAME_BACKDROP;
                            if (animate) this._backdrop.classList.add(animate);
                            $__default["default"](this._backdrop).appendTo(document.body);
                            $__default["default"](this._element).on(EVENT_CLICK_DISMISS$1, function(event) {
                                if (_this9._ignoreBackdropClick) {
                                    _this9._ignoreBackdropClick = false;
                                    return;
                                }
                                if (event.target !== event.currentTarget) return;
                                if (_this9._config.backdrop === "static") _this9._triggerBackdropTransition();
                                else _this9.hide();
                            });
                            if (animate) Util.reflow(this._backdrop);
                            $__default["default"](this._backdrop).addClass(CLASS_NAME_SHOW$4);
                            if (!callback) return;
                            if (!animate) {
                                callback();
                                return;
                            }
                            var backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);
                            $__default["default"](this._backdrop).one(Util.TRANSITION_END, callback).emulateTransitionEnd(backdropTransitionDuration);
                        } else if (!this._isShown && this._backdrop) {
                            $__default["default"](this._backdrop).removeClass(CLASS_NAME_SHOW$4);
                            var callbackRemove = function callbackRemove() {
                                _this9._removeBackdrop();
                                if (callback) callback();
                            };
                            if ($__default["default"](this._element).hasClass(CLASS_NAME_FADE$4)) {
                                var _backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);
                                $__default["default"](this._backdrop).one(Util.TRANSITION_END, callbackRemove).emulateTransitionEnd(_backdropTransitionDuration);
                            } else callbackRemove();
                        } else if (callback) callback();
                    } // ----------------------------------------------------------------------
                    ;
                    _proto._adjustDialog = function _adjustDialog() {
                        var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
                        if (!this._isBodyOverflowing && isModalOverflowing) this._element.style.paddingLeft = this._scrollbarWidth + "px";
                        if (this._isBodyOverflowing && !isModalOverflowing) this._element.style.paddingRight = this._scrollbarWidth + "px";
                    };
                    _proto._resetAdjustments = function _resetAdjustments() {
                        this._element.style.paddingLeft = "";
                        this._element.style.paddingRight = "";
                    };
                    _proto._checkScrollbar = function _checkScrollbar() {
                        var rect = document.body.getBoundingClientRect();
                        this._isBodyOverflowing = Math.round(rect.left + rect.right) < window.innerWidth;
                        this._scrollbarWidth = this._getScrollbarWidth();
                    };
                    _proto._setScrollbar = function _setScrollbar() {
                        var _this10 = this;
                        if (this._isBodyOverflowing) {
                            // Note: DOMNode.style.paddingRight returns the actual value or '' if not set
                            //   while $(DOMNode).css('padding-right') returns the calculated value or 0 if not set
                            var fixedContent = [].slice.call(document.querySelectorAll(SELECTOR_FIXED_CONTENT));
                            var stickyContent = [].slice.call(document.querySelectorAll(SELECTOR_STICKY_CONTENT)); // Adjust fixed content padding
                            $__default["default"](fixedContent).each(function(index, element) {
                                var actualPadding = element.style.paddingRight;
                                var calculatedPadding = $__default["default"](element).css("padding-right");
                                $__default["default"](element).data("padding-right", actualPadding).css("padding-right", parseFloat(calculatedPadding) + _this10._scrollbarWidth + "px");
                            }); // Adjust sticky content margin
                            $__default["default"](stickyContent).each(function(index, element) {
                                var actualMargin = element.style.marginRight;
                                var calculatedMargin = $__default["default"](element).css("margin-right");
                                $__default["default"](element).data("margin-right", actualMargin).css("margin-right", parseFloat(calculatedMargin) - _this10._scrollbarWidth + "px");
                            }); // Adjust body padding
                            var actualPadding = document.body.style.paddingRight;
                            var calculatedPadding = $__default["default"](document.body).css("padding-right");
                            $__default["default"](document.body).data("padding-right", actualPadding).css("padding-right", parseFloat(calculatedPadding) + this._scrollbarWidth + "px");
                        }
                        $__default["default"](document.body).addClass(CLASS_NAME_OPEN);
                    };
                    _proto._resetScrollbar = function _resetScrollbar() {
                        // Restore fixed content padding
                        var fixedContent = [].slice.call(document.querySelectorAll(SELECTOR_FIXED_CONTENT));
                        $__default["default"](fixedContent).each(function(index, element) {
                            var padding = $__default["default"](element).data("padding-right");
                            $__default["default"](element).removeData("padding-right");
                            element.style.paddingRight = padding ? padding : "";
                        }); // Restore sticky content
                        var elements = [].slice.call(document.querySelectorAll("" + SELECTOR_STICKY_CONTENT));
                        $__default["default"](elements).each(function(index, element) {
                            var margin = $__default["default"](element).data("margin-right");
                            if (typeof margin !== "undefined") $__default["default"](element).css("margin-right", margin).removeData("margin-right");
                        }); // Restore body padding
                        var padding = $__default["default"](document.body).data("padding-right");
                        $__default["default"](document.body).removeData("padding-right");
                        document.body.style.paddingRight = padding ? padding : "";
                    };
                    _proto._getScrollbarWidth = function _getScrollbarWidth() {
                        // thx d.walsh
                        var scrollDiv = document.createElement("div");
                        scrollDiv.className = CLASS_NAME_SCROLLBAR_MEASURER;
                        document.body.appendChild(scrollDiv);
                        var scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
                        document.body.removeChild(scrollDiv);
                        return scrollbarWidth;
                    } // Static
                    ;
                    Modal._jQueryInterface = function _jQueryInterface(config, relatedTarget) {
                        return this.each(function() {
                            var data = $__default["default"](this).data(DATA_KEY$5);
                            var _config = _extends({}, Default$4, $__default["default"](this).data(), typeof config === "object" && config ? config : {});
                            if (!data) {
                                data = new Modal(this, _config);
                                $__default["default"](this).data(DATA_KEY$5, data);
                            }
                            if (typeof config === "string") {
                                if (typeof data[config] === "undefined") throw new TypeError('No method named "' + config + '"');
                                data[config](relatedTarget);
                            } else if (_config.show) data.show(relatedTarget);
                        });
                    };
                    _createClass(Modal, null, [
                        {
                            key: "VERSION",
                            get: function get() {
                                return VERSION$5;
                            }
                        },
                        {
                            key: "Default",
                            get: function get() {
                                return Default$4;
                            }
                        }
                    ]);
                    return Modal;
                }();
                /**
   * Data API implementation
   */ $__default["default"](document).on(EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function(event) {
                    var _this11 = this;
                    var target;
                    var selector = Util.getSelectorFromElement(this);
                    if (selector) target = document.querySelector(selector);
                    var config = $__default["default"](target).data(DATA_KEY$5) ? "toggle" : _extends({}, $__default["default"](target).data(), $__default["default"](this).data());
                    if (this.tagName === "A" || this.tagName === "AREA") event.preventDefault();
                    var $target = $__default["default"](target).one(EVENT_SHOW$2, function(showEvent) {
                        if (showEvent.isDefaultPrevented()) // Only register focus restorer if modal will actually get shown
                        return;
                        $target.one(EVENT_HIDDEN$2, function() {
                            if ($__default["default"](_this11).is(":visible")) _this11.focus();
                        });
                    });
                    Modal._jQueryInterface.call($__default["default"](target), config, this);
                });
                /**
   * jQuery
   */ $__default["default"].fn[NAME$5] = Modal._jQueryInterface;
                $__default["default"].fn[NAME$5].Constructor = Modal;
                $__default["default"].fn[NAME$5].noConflict = function() {
                    $__default["default"].fn[NAME$5] = JQUERY_NO_CONFLICT$5;
                    return Modal._jQueryInterface;
                };
                /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.6.2): tools/sanitizer.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */ var uriAttrs = [
                    "background",
                    "cite",
                    "href",
                    "itemtype",
                    "longdesc",
                    "poster",
                    "src",
                    "xlink:href"
                ];
                var ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
                var DefaultWhitelist = {
                    // Global attributes allowed on any supplied element below.
                    "*": [
                        "class",
                        "dir",
                        "id",
                        "lang",
                        "role",
                        ARIA_ATTRIBUTE_PATTERN
                    ],
                    a: [
                        "target",
                        "href",
                        "title",
                        "rel"
                    ],
                    area: [],
                    b: [],
                    br: [],
                    col: [],
                    code: [],
                    div: [],
                    em: [],
                    hr: [],
                    h1: [],
                    h2: [],
                    h3: [],
                    h4: [],
                    h5: [],
                    h6: [],
                    i: [],
                    img: [
                        "src",
                        "srcset",
                        "alt",
                        "title",
                        "width",
                        "height"
                    ],
                    li: [],
                    ol: [],
                    p: [],
                    pre: [],
                    s: [],
                    small: [],
                    span: [],
                    sub: [],
                    sup: [],
                    strong: [],
                    u: [],
                    ul: []
                };
                /**
   * A pattern that recognizes a commonly useful subset of URLs that are safe.
   *
   * Shoutout to Angular https://github.com/angular/angular/blob/12.2.x/packages/core/src/sanitization/url_sanitizer.ts
   */ var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i;
                /**
   * A pattern that matches safe data URLs. Only matches image, video and audio types.
   *
   * Shoutout to Angular https://github.com/angular/angular/blob/12.2.x/packages/core/src/sanitization/url_sanitizer.ts
   */ var DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i;
                function allowedAttribute(attr, allowedAttributeList) {
                    var attrName = attr.nodeName.toLowerCase();
                    if (allowedAttributeList.indexOf(attrName) !== -1) {
                        if (uriAttrs.indexOf(attrName) !== -1) return Boolean(SAFE_URL_PATTERN.test(attr.nodeValue) || DATA_URL_PATTERN.test(attr.nodeValue));
                        return true;
                    }
                    var regExp = allowedAttributeList.filter(function(attrRegex) {
                        return attrRegex instanceof RegExp;
                    }); // Check if a regular expression validates the attribute.
                    for(var i = 0, len = regExp.length; i < len; i++){
                        if (regExp[i].test(attrName)) return true;
                    }
                    return false;
                }
                function sanitizeHtml(unsafeHtml, whiteList, sanitizeFn) {
                    if (unsafeHtml.length === 0) return unsafeHtml;
                    if (sanitizeFn && typeof sanitizeFn === "function") return sanitizeFn(unsafeHtml);
                    var domParser = new window.DOMParser();
                    var createdDocument = domParser.parseFromString(unsafeHtml, "text/html");
                    var whitelistKeys = Object.keys(whiteList);
                    var elements = [].slice.call(createdDocument.body.querySelectorAll("*"));
                    var _loop = function _loop(i, len) {
                        var el = elements[i];
                        var elName = el.nodeName.toLowerCase();
                        if (whitelistKeys.indexOf(el.nodeName.toLowerCase()) === -1) {
                            el.parentNode.removeChild(el);
                            return "continue";
                        }
                        var attributeList = [].slice.call(el.attributes); // eslint-disable-next-line unicorn/prefer-spread
                        var whitelistedAttributes = [].concat(whiteList["*"] || [], whiteList[elName] || []);
                        attributeList.forEach(function(attr) {
                            if (!allowedAttribute(attr, whitelistedAttributes)) el.removeAttribute(attr.nodeName);
                        });
                    };
                    for(var i = 0, len = elements.length; i < len; i++){
                        var _ret = _loop(i);
                        if (_ret === "continue") continue;
                    }
                    return createdDocument.body.innerHTML;
                }
                /**
   * Constants
   */ var NAME$4 = "tooltip";
                var VERSION$4 = "4.6.2";
                var DATA_KEY$4 = "bs.tooltip";
                var EVENT_KEY$4 = "." + DATA_KEY$4;
                var JQUERY_NO_CONFLICT$4 = $__default["default"].fn[NAME$4];
                var CLASS_PREFIX$1 = "bs-tooltip";
                var BSCLS_PREFIX_REGEX$1 = new RegExp("(^|\\s)" + CLASS_PREFIX$1 + "\\S+", "g");
                var DISALLOWED_ATTRIBUTES = [
                    "sanitize",
                    "whiteList",
                    "sanitizeFn"
                ];
                var CLASS_NAME_FADE$3 = "fade";
                var CLASS_NAME_SHOW$3 = "show";
                var HOVER_STATE_SHOW = "show";
                var HOVER_STATE_OUT = "out";
                var SELECTOR_TOOLTIP_INNER = ".tooltip-inner";
                var SELECTOR_ARROW = ".arrow";
                var TRIGGER_HOVER = "hover";
                var TRIGGER_FOCUS = "focus";
                var TRIGGER_CLICK = "click";
                var TRIGGER_MANUAL = "manual";
                var AttachmentMap = {
                    AUTO: "auto",
                    TOP: "top",
                    RIGHT: "right",
                    BOTTOM: "bottom",
                    LEFT: "left"
                };
                var Default$3 = {
                    animation: true,
                    template: '<div class="tooltip" role="tooltip"><div class="arrow"></div><div class="tooltip-inner"></div></div>',
                    trigger: "hover focus",
                    title: "",
                    delay: 0,
                    html: false,
                    selector: false,
                    placement: "top",
                    offset: 0,
                    container: false,
                    fallbackPlacement: "flip",
                    boundary: "scrollParent",
                    customClass: "",
                    sanitize: true,
                    sanitizeFn: null,
                    whiteList: DefaultWhitelist,
                    popperConfig: null
                };
                var DefaultType$3 = {
                    animation: "boolean",
                    template: "string",
                    title: "(string|element|function)",
                    trigger: "string",
                    delay: "(number|object)",
                    html: "boolean",
                    selector: "(string|boolean)",
                    placement: "(string|function)",
                    offset: "(number|string|function)",
                    container: "(string|element|boolean)",
                    fallbackPlacement: "(string|array)",
                    boundary: "(string|element)",
                    customClass: "(string|function)",
                    sanitize: "boolean",
                    sanitizeFn: "(null|function)",
                    whiteList: "object",
                    popperConfig: "(null|object)"
                };
                var Event$1 = {
                    HIDE: "hide" + EVENT_KEY$4,
                    HIDDEN: "hidden" + EVENT_KEY$4,
                    SHOW: "show" + EVENT_KEY$4,
                    SHOWN: "shown" + EVENT_KEY$4,
                    INSERTED: "inserted" + EVENT_KEY$4,
                    CLICK: "click" + EVENT_KEY$4,
                    FOCUSIN: "focusin" + EVENT_KEY$4,
                    FOCUSOUT: "focusout" + EVENT_KEY$4,
                    MOUSEENTER: "mouseenter" + EVENT_KEY$4,
                    MOUSELEAVE: "mouseleave" + EVENT_KEY$4
                };
                /**
   * Class definition
   */ var Tooltip = /*#__PURE__*/ function() {
                    function Tooltip(element, config) {
                        if (typeof Popper__default["default"] === "undefined") throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
                         // Private
                        this._isEnabled = true;
                        this._timeout = 0;
                        this._hoverState = "";
                        this._activeTrigger = {};
                        this._popper = null; // Protected
                        this.element = element;
                        this.config = this._getConfig(config);
                        this.tip = null;
                        this._setListeners();
                    } // Getters
                    var _proto = Tooltip.prototype;
                    // Public
                    _proto.enable = function enable() {
                        this._isEnabled = true;
                    };
                    _proto.disable = function disable() {
                        this._isEnabled = false;
                    };
                    _proto.toggleEnabled = function toggleEnabled() {
                        this._isEnabled = !this._isEnabled;
                    };
                    _proto.toggle = function toggle(event) {
                        if (!this._isEnabled) return;
                        if (event) {
                            var dataKey = this.constructor.DATA_KEY;
                            var context = $__default["default"](event.currentTarget).data(dataKey);
                            if (!context) {
                                context = new this.constructor(event.currentTarget, this._getDelegateConfig());
                                $__default["default"](event.currentTarget).data(dataKey, context);
                            }
                            context._activeTrigger.click = !context._activeTrigger.click;
                            if (context._isWithActiveTrigger()) context._enter(null, context);
                            else context._leave(null, context);
                        } else {
                            if ($__default["default"](this.getTipElement()).hasClass(CLASS_NAME_SHOW$3)) {
                                this._leave(null, this);
                                return;
                            }
                            this._enter(null, this);
                        }
                    };
                    _proto.dispose = function dispose() {
                        clearTimeout(this._timeout);
                        $__default["default"].removeData(this.element, this.constructor.DATA_KEY);
                        $__default["default"](this.element).off(this.constructor.EVENT_KEY);
                        $__default["default"](this.element).closest(".modal").off("hide.bs.modal", this._hideModalHandler);
                        if (this.tip) $__default["default"](this.tip).remove();
                        this._isEnabled = null;
                        this._timeout = null;
                        this._hoverState = null;
                        this._activeTrigger = null;
                        if (this._popper) this._popper.destroy();
                        this._popper = null;
                        this.element = null;
                        this.config = null;
                        this.tip = null;
                    };
                    _proto.show = function show() {
                        var _this = this;
                        if ($__default["default"](this.element).css("display") === "none") throw new Error("Please use show on visible elements");
                        var showEvent = $__default["default"].Event(this.constructor.Event.SHOW);
                        if (this.isWithContent() && this._isEnabled) {
                            $__default["default"](this.element).trigger(showEvent);
                            var shadowRoot = Util.findShadowRoot(this.element);
                            var isInTheDom = $__default["default"].contains(shadowRoot !== null ? shadowRoot : this.element.ownerDocument.documentElement, this.element);
                            if (showEvent.isDefaultPrevented() || !isInTheDom) return;
                            var tip = this.getTipElement();
                            var tipId = Util.getUID(this.constructor.NAME);
                            tip.setAttribute("id", tipId);
                            this.element.setAttribute("aria-describedby", tipId);
                            this.setContent();
                            if (this.config.animation) $__default["default"](tip).addClass(CLASS_NAME_FADE$3);
                            var placement = typeof this.config.placement === "function" ? this.config.placement.call(this, tip, this.element) : this.config.placement;
                            var attachment = this._getAttachment(placement);
                            this.addAttachmentClass(attachment);
                            var container = this._getContainer();
                            $__default["default"](tip).data(this.constructor.DATA_KEY, this);
                            if (!$__default["default"].contains(this.element.ownerDocument.documentElement, this.tip)) $__default["default"](tip).appendTo(container);
                            $__default["default"](this.element).trigger(this.constructor.Event.INSERTED);
                            this._popper = new Popper__default["default"](this.element, tip, this._getPopperConfig(attachment));
                            $__default["default"](tip).addClass(CLASS_NAME_SHOW$3);
                            $__default["default"](tip).addClass(this.config.customClass); // If this is a touch-enabled device we add extra
                            // empty mouseover listeners to the body's immediate children;
                            // only needed because of broken event delegation on iOS
                            // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html
                            if ("ontouchstart" in document.documentElement) $__default["default"](document.body).children().on("mouseover", null, $__default["default"].noop);
                            var complete = function complete() {
                                if (_this.config.animation) _this._fixTransition();
                                var prevHoverState = _this._hoverState;
                                _this._hoverState = null;
                                $__default["default"](_this.element).trigger(_this.constructor.Event.SHOWN);
                                if (prevHoverState === HOVER_STATE_OUT) _this._leave(null, _this);
                            };
                            if ($__default["default"](this.tip).hasClass(CLASS_NAME_FADE$3)) {
                                var transitionDuration = Util.getTransitionDurationFromElement(this.tip);
                                $__default["default"](this.tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
                            } else complete();
                        }
                    };
                    _proto.hide = function hide(callback) {
                        var _this2 = this;
                        var tip = this.getTipElement();
                        var hideEvent = $__default["default"].Event(this.constructor.Event.HIDE);
                        var complete = function complete() {
                            if (_this2._hoverState !== HOVER_STATE_SHOW && tip.parentNode) tip.parentNode.removeChild(tip);
                            _this2._cleanTipClass();
                            _this2.element.removeAttribute("aria-describedby");
                            $__default["default"](_this2.element).trigger(_this2.constructor.Event.HIDDEN);
                            if (_this2._popper !== null) _this2._popper.destroy();
                            if (callback) callback();
                        };
                        $__default["default"](this.element).trigger(hideEvent);
                        if (hideEvent.isDefaultPrevented()) return;
                        $__default["default"](tip).removeClass(CLASS_NAME_SHOW$3); // If this is a touch-enabled device we remove the extra
                        // empty mouseover listeners we added for iOS support
                        if ("ontouchstart" in document.documentElement) $__default["default"](document.body).children().off("mouseover", null, $__default["default"].noop);
                        this._activeTrigger[TRIGGER_CLICK] = false;
                        this._activeTrigger[TRIGGER_FOCUS] = false;
                        this._activeTrigger[TRIGGER_HOVER] = false;
                        if ($__default["default"](this.tip).hasClass(CLASS_NAME_FADE$3)) {
                            var transitionDuration = Util.getTransitionDurationFromElement(tip);
                            $__default["default"](tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
                        } else complete();
                        this._hoverState = "";
                    };
                    _proto.update = function update() {
                        if (this._popper !== null) this._popper.scheduleUpdate();
                    } // Protected
                    ;
                    _proto.isWithContent = function isWithContent() {
                        return Boolean(this.getTitle());
                    };
                    _proto.addAttachmentClass = function addAttachmentClass(attachment) {
                        $__default["default"](this.getTipElement()).addClass(CLASS_PREFIX$1 + "-" + attachment);
                    };
                    _proto.getTipElement = function getTipElement() {
                        this.tip = this.tip || $__default["default"](this.config.template)[0];
                        return this.tip;
                    };
                    _proto.setContent = function setContent() {
                        var tip = this.getTipElement();
                        this.setElementContent($__default["default"](tip.querySelectorAll(SELECTOR_TOOLTIP_INNER)), this.getTitle());
                        $__default["default"](tip).removeClass(CLASS_NAME_FADE$3 + " " + CLASS_NAME_SHOW$3);
                    };
                    _proto.setElementContent = function setElementContent($element, content) {
                        if (typeof content === "object" && (content.nodeType || content.jquery)) {
                            // Content is a DOM node or a jQuery
                            if (this.config.html) {
                                if (!$__default["default"](content).parent().is($element)) $element.empty().append(content);
                            } else $element.text($__default["default"](content).text());
                            return;
                        }
                        if (this.config.html) {
                            if (this.config.sanitize) content = sanitizeHtml(content, this.config.whiteList, this.config.sanitizeFn);
                            $element.html(content);
                        } else $element.text(content);
                    };
                    _proto.getTitle = function getTitle() {
                        var title = this.element.getAttribute("data-original-title");
                        if (!title) title = typeof this.config.title === "function" ? this.config.title.call(this.element) : this.config.title;
                        return title;
                    } // Private
                    ;
                    _proto._getPopperConfig = function _getPopperConfig(attachment) {
                        var _this3 = this;
                        var defaultBsConfig = {
                            placement: attachment,
                            modifiers: {
                                offset: this._getOffset(),
                                flip: {
                                    behavior: this.config.fallbackPlacement
                                },
                                arrow: {
                                    element: SELECTOR_ARROW
                                },
                                preventOverflow: {
                                    boundariesElement: this.config.boundary
                                }
                            },
                            onCreate: function onCreate(data) {
                                if (data.originalPlacement !== data.placement) _this3._handlePopperPlacementChange(data);
                            },
                            onUpdate: function onUpdate(data) {
                                return _this3._handlePopperPlacementChange(data);
                            }
                        };
                        return _extends({}, defaultBsConfig, this.config.popperConfig);
                    };
                    _proto._getOffset = function _getOffset() {
                        var _this4 = this;
                        var offset = {};
                        if (typeof this.config.offset === "function") offset.fn = function(data) {
                            data.offsets = _extends({}, data.offsets, _this4.config.offset(data.offsets, _this4.element));
                            return data;
                        };
                        else offset.offset = this.config.offset;
                        return offset;
                    };
                    _proto._getContainer = function _getContainer() {
                        if (this.config.container === false) return document.body;
                        if (Util.isElement(this.config.container)) return $__default["default"](this.config.container);
                        return $__default["default"](document).find(this.config.container);
                    };
                    _proto._getAttachment = function _getAttachment(placement) {
                        return AttachmentMap[placement.toUpperCase()];
                    };
                    _proto._setListeners = function _setListeners() {
                        var _this5 = this;
                        var triggers = this.config.trigger.split(" ");
                        triggers.forEach(function(trigger) {
                            if (trigger === "click") $__default["default"](_this5.element).on(_this5.constructor.Event.CLICK, _this5.config.selector, function(event) {
                                return _this5.toggle(event);
                            });
                            else if (trigger !== TRIGGER_MANUAL) {
                                var eventIn = trigger === TRIGGER_HOVER ? _this5.constructor.Event.MOUSEENTER : _this5.constructor.Event.FOCUSIN;
                                var eventOut = trigger === TRIGGER_HOVER ? _this5.constructor.Event.MOUSELEAVE : _this5.constructor.Event.FOCUSOUT;
                                $__default["default"](_this5.element).on(eventIn, _this5.config.selector, function(event) {
                                    return _this5._enter(event);
                                }).on(eventOut, _this5.config.selector, function(event) {
                                    return _this5._leave(event);
                                });
                            }
                        });
                        this._hideModalHandler = function() {
                            if (_this5.element) _this5.hide();
                        };
                        $__default["default"](this.element).closest(".modal").on("hide.bs.modal", this._hideModalHandler);
                        if (this.config.selector) this.config = _extends({}, this.config, {
                            trigger: "manual",
                            selector: ""
                        });
                        else this._fixTitle();
                    };
                    _proto._fixTitle = function _fixTitle() {
                        var titleType = (0, _typeOf._)(this.element.getAttribute("data-original-title"));
                        if (this.element.getAttribute("title") || titleType !== "string") {
                            this.element.setAttribute("data-original-title", this.element.getAttribute("title") || "");
                            this.element.setAttribute("title", "");
                        }
                    };
                    _proto._enter = function _enter(event, context) {
                        var dataKey = this.constructor.DATA_KEY;
                        context = context || $__default["default"](event.currentTarget).data(dataKey);
                        if (!context) {
                            context = new this.constructor(event.currentTarget, this._getDelegateConfig());
                            $__default["default"](event.currentTarget).data(dataKey, context);
                        }
                        if (event) context._activeTrigger[event.type === "focusin" ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;
                        if ($__default["default"](context.getTipElement()).hasClass(CLASS_NAME_SHOW$3) || context._hoverState === HOVER_STATE_SHOW) {
                            context._hoverState = HOVER_STATE_SHOW;
                            return;
                        }
                        clearTimeout(context._timeout);
                        context._hoverState = HOVER_STATE_SHOW;
                        if (!context.config.delay || !context.config.delay.show) {
                            context.show();
                            return;
                        }
                        context._timeout = setTimeout(function() {
                            if (context._hoverState === HOVER_STATE_SHOW) context.show();
                        }, context.config.delay.show);
                    };
                    _proto._leave = function _leave(event, context) {
                        var dataKey = this.constructor.DATA_KEY;
                        context = context || $__default["default"](event.currentTarget).data(dataKey);
                        if (!context) {
                            context = new this.constructor(event.currentTarget, this._getDelegateConfig());
                            $__default["default"](event.currentTarget).data(dataKey, context);
                        }
                        if (event) context._activeTrigger[event.type === "focusout" ? TRIGGER_FOCUS : TRIGGER_HOVER] = false;
                        if (context._isWithActiveTrigger()) return;
                        clearTimeout(context._timeout);
                        context._hoverState = HOVER_STATE_OUT;
                        if (!context.config.delay || !context.config.delay.hide) {
                            context.hide();
                            return;
                        }
                        context._timeout = setTimeout(function() {
                            if (context._hoverState === HOVER_STATE_OUT) context.hide();
                        }, context.config.delay.hide);
                    };
                    _proto._isWithActiveTrigger = function _isWithActiveTrigger() {
                        for(var trigger in this._activeTrigger){
                            if (this._activeTrigger[trigger]) return true;
                        }
                        return false;
                    };
                    _proto._getConfig = function _getConfig(config) {
                        var dataAttributes = $__default["default"](this.element).data();
                        Object.keys(dataAttributes).forEach(function(dataAttr) {
                            if (DISALLOWED_ATTRIBUTES.indexOf(dataAttr) !== -1) delete dataAttributes[dataAttr];
                        });
                        config = _extends({}, this.constructor.Default, dataAttributes, typeof config === "object" && config ? config : {});
                        if (typeof config.delay === "number") config.delay = {
                            show: config.delay,
                            hide: config.delay
                        };
                        if (typeof config.title === "number") config.title = config.title.toString();
                        if (typeof config.content === "number") config.content = config.content.toString();
                        Util.typeCheckConfig(NAME$4, config, this.constructor.DefaultType);
                        if (config.sanitize) config.template = sanitizeHtml(config.template, config.whiteList, config.sanitizeFn);
                        return config;
                    };
                    _proto._getDelegateConfig = function _getDelegateConfig() {
                        var config = {};
                        if (this.config) {
                            for(var key in this.config)if (this.constructor.Default[key] !== this.config[key]) config[key] = this.config[key];
                        }
                        return config;
                    };
                    _proto._cleanTipClass = function _cleanTipClass() {
                        var $tip = $__default["default"](this.getTipElement());
                        var tabClass = $tip.attr("class").match(BSCLS_PREFIX_REGEX$1);
                        if (tabClass !== null && tabClass.length) $tip.removeClass(tabClass.join(""));
                    };
                    _proto._handlePopperPlacementChange = function _handlePopperPlacementChange(popperData) {
                        this.tip = popperData.instance.popper;
                        this._cleanTipClass();
                        this.addAttachmentClass(this._getAttachment(popperData.placement));
                    };
                    _proto._fixTransition = function _fixTransition() {
                        var tip = this.getTipElement();
                        var initConfigAnimation = this.config.animation;
                        if (tip.getAttribute("x-placement") !== null) return;
                        $__default["default"](tip).removeClass(CLASS_NAME_FADE$3);
                        this.config.animation = false;
                        this.hide();
                        this.show();
                        this.config.animation = initConfigAnimation;
                    } // Static
                    ;
                    Tooltip._jQueryInterface = function _jQueryInterface(config) {
                        return this.each(function() {
                            var $element = $__default["default"](this);
                            var data = $element.data(DATA_KEY$4);
                            var _config = typeof config === "object" && config;
                            if (!data && /dispose|hide/.test(config)) return;
                            if (!data) {
                                data = new Tooltip(this, _config);
                                $element.data(DATA_KEY$4, data);
                            }
                            if (typeof config === "string") {
                                if (typeof data[config] === "undefined") throw new TypeError('No method named "' + config + '"');
                                data[config]();
                            }
                        });
                    };
                    _createClass(Tooltip, null, [
                        {
                            key: "VERSION",
                            get: function get() {
                                return VERSION$4;
                            }
                        },
                        {
                            key: "Default",
                            get: function get() {
                                return Default$3;
                            }
                        },
                        {
                            key: "NAME",
                            get: function get() {
                                return NAME$4;
                            }
                        },
                        {
                            key: "DATA_KEY",
                            get: function get() {
                                return DATA_KEY$4;
                            }
                        },
                        {
                            key: "Event",
                            get: function get() {
                                return Event$1;
                            }
                        },
                        {
                            key: "EVENT_KEY",
                            get: function get() {
                                return EVENT_KEY$4;
                            }
                        },
                        {
                            key: "DefaultType",
                            get: function get() {
                                return DefaultType$3;
                            }
                        }
                    ]);
                    return Tooltip;
                }();
                /**
   * jQuery
   */ $__default["default"].fn[NAME$4] = Tooltip._jQueryInterface;
                $__default["default"].fn[NAME$4].Constructor = Tooltip;
                $__default["default"].fn[NAME$4].noConflict = function() {
                    $__default["default"].fn[NAME$4] = JQUERY_NO_CONFLICT$4;
                    return Tooltip._jQueryInterface;
                };
                /**
   * Constants
   */ var NAME$3 = "popover";
                var VERSION$3 = "4.6.2";
                var DATA_KEY$3 = "bs.popover";
                var EVENT_KEY$3 = "." + DATA_KEY$3;
                var JQUERY_NO_CONFLICT$3 = $__default["default"].fn[NAME$3];
                var CLASS_PREFIX = "bs-popover";
                var BSCLS_PREFIX_REGEX = new RegExp("(^|\\s)" + CLASS_PREFIX + "\\S+", "g");
                var CLASS_NAME_FADE$2 = "fade";
                var CLASS_NAME_SHOW$2 = "show";
                var SELECTOR_TITLE = ".popover-header";
                var SELECTOR_CONTENT = ".popover-body";
                var Default$2 = _extends({}, Tooltip.Default, {
                    placement: "right",
                    trigger: "click",
                    content: "",
                    template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>'
                });
                var DefaultType$2 = _extends({}, Tooltip.DefaultType, {
                    content: "(string|element|function)"
                });
                var Event = {
                    HIDE: "hide" + EVENT_KEY$3,
                    HIDDEN: "hidden" + EVENT_KEY$3,
                    SHOW: "show" + EVENT_KEY$3,
                    SHOWN: "shown" + EVENT_KEY$3,
                    INSERTED: "inserted" + EVENT_KEY$3,
                    CLICK: "click" + EVENT_KEY$3,
                    FOCUSIN: "focusin" + EVENT_KEY$3,
                    FOCUSOUT: "focusout" + EVENT_KEY$3,
                    MOUSEENTER: "mouseenter" + EVENT_KEY$3,
                    MOUSELEAVE: "mouseleave" + EVENT_KEY$3
                };
                /**
   * Class definition
   */ var Popover = /*#__PURE__*/ function(_Tooltip) {
                    _inheritsLoose(Popover, _Tooltip);
                    function Popover() {
                        return _Tooltip.apply(this, arguments) || this;
                    }
                    var _proto = Popover.prototype;
                    // Overrides
                    _proto.isWithContent = function isWithContent() {
                        return this.getTitle() || this._getContent();
                    };
                    _proto.addAttachmentClass = function addAttachmentClass(attachment) {
                        $__default["default"](this.getTipElement()).addClass(CLASS_PREFIX + "-" + attachment);
                    };
                    _proto.getTipElement = function getTipElement() {
                        this.tip = this.tip || $__default["default"](this.config.template)[0];
                        return this.tip;
                    };
                    _proto.setContent = function setContent() {
                        var $tip = $__default["default"](this.getTipElement()); // We use append for html objects to maintain js events
                        this.setElementContent($tip.find(SELECTOR_TITLE), this.getTitle());
                        var content = this._getContent();
                        if (typeof content === "function") content = content.call(this.element);
                        this.setElementContent($tip.find(SELECTOR_CONTENT), content);
                        $tip.removeClass(CLASS_NAME_FADE$2 + " " + CLASS_NAME_SHOW$2);
                    } // Private
                    ;
                    _proto._getContent = function _getContent() {
                        return this.element.getAttribute("data-content") || this.config.content;
                    };
                    _proto._cleanTipClass = function _cleanTipClass() {
                        var $tip = $__default["default"](this.getTipElement());
                        var tabClass = $tip.attr("class").match(BSCLS_PREFIX_REGEX);
                        if (tabClass !== null && tabClass.length > 0) $tip.removeClass(tabClass.join(""));
                    } // Static
                    ;
                    Popover._jQueryInterface = function _jQueryInterface(config) {
                        return this.each(function() {
                            var data = $__default["default"](this).data(DATA_KEY$3);
                            var _config = typeof config === "object" ? config : null;
                            if (!data && /dispose|hide/.test(config)) return;
                            if (!data) {
                                data = new Popover(this, _config);
                                $__default["default"](this).data(DATA_KEY$3, data);
                            }
                            if (typeof config === "string") {
                                if (typeof data[config] === "undefined") throw new TypeError('No method named "' + config + '"');
                                data[config]();
                            }
                        });
                    };
                    _createClass(Popover, null, [
                        {
                            key: "VERSION",
                            get: function get() {
                                return VERSION$3;
                            }
                        },
                        {
                            key: "Default",
                            get: function get() {
                                return Default$2;
                            }
                        },
                        {
                            key: "NAME",
                            get: function get() {
                                return NAME$3;
                            }
                        },
                        {
                            key: "DATA_KEY",
                            get: function get() {
                                return DATA_KEY$3;
                            }
                        },
                        {
                            key: "Event",
                            get: function get() {
                                return Event;
                            }
                        },
                        {
                            key: "EVENT_KEY",
                            get: function get() {
                                return EVENT_KEY$3;
                            }
                        },
                        {
                            key: "DefaultType",
                            get: function get() {
                                return DefaultType$2;
                            }
                        }
                    ]);
                    return Popover;
                }(Tooltip);
                /**
   * jQuery
   */ $__default["default"].fn[NAME$3] = Popover._jQueryInterface;
                $__default["default"].fn[NAME$3].Constructor = Popover;
                $__default["default"].fn[NAME$3].noConflict = function() {
                    $__default["default"].fn[NAME$3] = JQUERY_NO_CONFLICT$3;
                    return Popover._jQueryInterface;
                };
                /**
   * Constants
   */ var NAME$2 = "scrollspy";
                var VERSION$2 = "4.6.2";
                var DATA_KEY$2 = "bs.scrollspy";
                var EVENT_KEY$2 = "." + DATA_KEY$2;
                var DATA_API_KEY$1 = ".data-api";
                var JQUERY_NO_CONFLICT$2 = $__default["default"].fn[NAME$2];
                var CLASS_NAME_DROPDOWN_ITEM = "dropdown-item";
                var CLASS_NAME_ACTIVE$1 = "active";
                var EVENT_ACTIVATE = "activate" + EVENT_KEY$2;
                var EVENT_SCROLL = "scroll" + EVENT_KEY$2;
                var EVENT_LOAD_DATA_API = "load" + EVENT_KEY$2 + DATA_API_KEY$1;
                var METHOD_OFFSET = "offset";
                var METHOD_POSITION = "position";
                var SELECTOR_DATA_SPY = '[data-spy="scroll"]';
                var SELECTOR_NAV_LIST_GROUP$1 = ".nav, .list-group";
                var SELECTOR_NAV_LINKS = ".nav-link";
                var SELECTOR_NAV_ITEMS = ".nav-item";
                var SELECTOR_LIST_ITEMS = ".list-group-item";
                var SELECTOR_DROPDOWN$1 = ".dropdown";
                var SELECTOR_DROPDOWN_ITEMS = ".dropdown-item";
                var SELECTOR_DROPDOWN_TOGGLE$1 = ".dropdown-toggle";
                var Default$1 = {
                    offset: 10,
                    method: "auto",
                    target: ""
                };
                var DefaultType$1 = {
                    offset: "number",
                    method: "string",
                    target: "(string|element)"
                };
                /**
   * Class definition
   */ var ScrollSpy = /*#__PURE__*/ function() {
                    function ScrollSpy(element, config) {
                        var _this = this;
                        this._element = element;
                        this._scrollElement = element.tagName === "BODY" ? window : element;
                        this._config = this._getConfig(config);
                        this._selector = this._config.target + " " + SELECTOR_NAV_LINKS + "," + (this._config.target + " " + SELECTOR_LIST_ITEMS + ",") + (this._config.target + " " + SELECTOR_DROPDOWN_ITEMS);
                        this._offsets = [];
                        this._targets = [];
                        this._activeTarget = null;
                        this._scrollHeight = 0;
                        $__default["default"](this._scrollElement).on(EVENT_SCROLL, function(event) {
                            return _this._process(event);
                        });
                        this.refresh();
                        this._process();
                    } // Getters
                    var _proto = ScrollSpy.prototype;
                    // Public
                    _proto.refresh = function refresh() {
                        var _this2 = this;
                        var autoMethod = this._scrollElement === this._scrollElement.window ? METHOD_OFFSET : METHOD_POSITION;
                        var offsetMethod = this._config.method === "auto" ? autoMethod : this._config.method;
                        var offsetBase = offsetMethod === METHOD_POSITION ? this._getScrollTop() : 0;
                        this._offsets = [];
                        this._targets = [];
                        this._scrollHeight = this._getScrollHeight();
                        var targets = [].slice.call(document.querySelectorAll(this._selector));
                        targets.map(function(element) {
                            var target;
                            var targetSelector = Util.getSelectorFromElement(element);
                            if (targetSelector) target = document.querySelector(targetSelector);
                            if (target) {
                                var targetBCR = target.getBoundingClientRect();
                                if (targetBCR.width || targetBCR.height) // TODO (fat): remove sketch reliance on jQuery position/offset
                                return [
                                    $__default["default"](target)[offsetMethod]().top + offsetBase,
                                    targetSelector
                                ];
                            }
                            return null;
                        }).filter(Boolean).sort(function(a, b) {
                            return a[0] - b[0];
                        }).forEach(function(item) {
                            _this2._offsets.push(item[0]);
                            _this2._targets.push(item[1]);
                        });
                    };
                    _proto.dispose = function dispose() {
                        $__default["default"].removeData(this._element, DATA_KEY$2);
                        $__default["default"](this._scrollElement).off(EVENT_KEY$2);
                        this._element = null;
                        this._scrollElement = null;
                        this._config = null;
                        this._selector = null;
                        this._offsets = null;
                        this._targets = null;
                        this._activeTarget = null;
                        this._scrollHeight = null;
                    } // Private
                    ;
                    _proto._getConfig = function _getConfig(config) {
                        config = _extends({}, Default$1, typeof config === "object" && config ? config : {});
                        if (typeof config.target !== "string" && Util.isElement(config.target)) {
                            var id = $__default["default"](config.target).attr("id");
                            if (!id) {
                                id = Util.getUID(NAME$2);
                                $__default["default"](config.target).attr("id", id);
                            }
                            config.target = "#" + id;
                        }
                        Util.typeCheckConfig(NAME$2, config, DefaultType$1);
                        return config;
                    };
                    _proto._getScrollTop = function _getScrollTop() {
                        return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
                    };
                    _proto._getScrollHeight = function _getScrollHeight() {
                        return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
                    };
                    _proto._getOffsetHeight = function _getOffsetHeight() {
                        return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
                    };
                    _proto._process = function _process() {
                        var scrollTop = this._getScrollTop() + this._config.offset;
                        var scrollHeight = this._getScrollHeight();
                        var maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();
                        if (this._scrollHeight !== scrollHeight) this.refresh();
                        if (scrollTop >= maxScroll) {
                            var target = this._targets[this._targets.length - 1];
                            if (this._activeTarget !== target) this._activate(target);
                            return;
                        }
                        if (this._activeTarget && scrollTop < this._offsets[0] && this._offsets[0] > 0) {
                            this._activeTarget = null;
                            this._clear();
                            return;
                        }
                        for(var i = this._offsets.length; i--;){
                            var isActiveTarget = this._activeTarget !== this._targets[i] && scrollTop >= this._offsets[i] && (typeof this._offsets[i + 1] === "undefined" || scrollTop < this._offsets[i + 1]);
                            if (isActiveTarget) this._activate(this._targets[i]);
                        }
                    };
                    _proto._activate = function _activate(target) {
                        this._activeTarget = target;
                        this._clear();
                        var queries = this._selector.split(",").map(function(selector) {
                            return selector + '[data-target="' + target + '"],' + selector + '[href="' + target + '"]';
                        });
                        var $link = $__default["default"]([].slice.call(document.querySelectorAll(queries.join(","))));
                        if ($link.hasClass(CLASS_NAME_DROPDOWN_ITEM)) {
                            $link.closest(SELECTOR_DROPDOWN$1).find(SELECTOR_DROPDOWN_TOGGLE$1).addClass(CLASS_NAME_ACTIVE$1);
                            $link.addClass(CLASS_NAME_ACTIVE$1);
                        } else {
                            // Set triggered link as active
                            $link.addClass(CLASS_NAME_ACTIVE$1); // Set triggered links parents as active
                            // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor
                            $link.parents(SELECTOR_NAV_LIST_GROUP$1).prev(SELECTOR_NAV_LINKS + ", " + SELECTOR_LIST_ITEMS).addClass(CLASS_NAME_ACTIVE$1); // Handle special case when .nav-link is inside .nav-item
                            $link.parents(SELECTOR_NAV_LIST_GROUP$1).prev(SELECTOR_NAV_ITEMS).children(SELECTOR_NAV_LINKS).addClass(CLASS_NAME_ACTIVE$1);
                        }
                        $__default["default"](this._scrollElement).trigger(EVENT_ACTIVATE, {
                            relatedTarget: target
                        });
                    };
                    _proto._clear = function _clear() {
                        [].slice.call(document.querySelectorAll(this._selector)).filter(function(node) {
                            return node.classList.contains(CLASS_NAME_ACTIVE$1);
                        }).forEach(function(node) {
                            return node.classList.remove(CLASS_NAME_ACTIVE$1);
                        });
                    } // Static
                    ;
                    ScrollSpy._jQueryInterface = function _jQueryInterface(config) {
                        return this.each(function() {
                            var data = $__default["default"](this).data(DATA_KEY$2);
                            var _config = typeof config === "object" && config;
                            if (!data) {
                                data = new ScrollSpy(this, _config);
                                $__default["default"](this).data(DATA_KEY$2, data);
                            }
                            if (typeof config === "string") {
                                if (typeof data[config] === "undefined") throw new TypeError('No method named "' + config + '"');
                                data[config]();
                            }
                        });
                    };
                    _createClass(ScrollSpy, null, [
                        {
                            key: "VERSION",
                            get: function get() {
                                return VERSION$2;
                            }
                        },
                        {
                            key: "Default",
                            get: function get() {
                                return Default$1;
                            }
                        }
                    ]);
                    return ScrollSpy;
                }();
                /**
   * Data API implementation
   */ $__default["default"](window).on(EVENT_LOAD_DATA_API, function() {
                    var scrollSpys = [].slice.call(document.querySelectorAll(SELECTOR_DATA_SPY));
                    var scrollSpysLength = scrollSpys.length;
                    for(var i = scrollSpysLength; i--;){
                        var $spy = $__default["default"](scrollSpys[i]);
                        ScrollSpy._jQueryInterface.call($spy, $spy.data());
                    }
                });
                /**
   * jQuery
   */ $__default["default"].fn[NAME$2] = ScrollSpy._jQueryInterface;
                $__default["default"].fn[NAME$2].Constructor = ScrollSpy;
                $__default["default"].fn[NAME$2].noConflict = function() {
                    $__default["default"].fn[NAME$2] = JQUERY_NO_CONFLICT$2;
                    return ScrollSpy._jQueryInterface;
                };
                /**
   * Constants
   */ var NAME$1 = "tab";
                var VERSION$1 = "4.6.2";
                var DATA_KEY$1 = "bs.tab";
                var EVENT_KEY$1 = "." + DATA_KEY$1;
                var DATA_API_KEY = ".data-api";
                var JQUERY_NO_CONFLICT$1 = $__default["default"].fn[NAME$1];
                var CLASS_NAME_DROPDOWN_MENU = "dropdown-menu";
                var CLASS_NAME_ACTIVE = "active";
                var CLASS_NAME_DISABLED = "disabled";
                var CLASS_NAME_FADE$1 = "fade";
                var CLASS_NAME_SHOW$1 = "show";
                var EVENT_HIDE$1 = "hide" + EVENT_KEY$1;
                var EVENT_HIDDEN$1 = "hidden" + EVENT_KEY$1;
                var EVENT_SHOW$1 = "show" + EVENT_KEY$1;
                var EVENT_SHOWN$1 = "shown" + EVENT_KEY$1;
                var EVENT_CLICK_DATA_API = "click" + EVENT_KEY$1 + DATA_API_KEY;
                var SELECTOR_DROPDOWN = ".dropdown";
                var SELECTOR_NAV_LIST_GROUP = ".nav, .list-group";
                var SELECTOR_ACTIVE = ".active";
                var SELECTOR_ACTIVE_UL = "> li > .active";
                var SELECTOR_DATA_TOGGLE = '[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]';
                var SELECTOR_DROPDOWN_TOGGLE = ".dropdown-toggle";
                var SELECTOR_DROPDOWN_ACTIVE_CHILD = "> .dropdown-menu .active";
                /**
   * Class definition
   */ var Tab = /*#__PURE__*/ function() {
                    function Tab(element) {
                        this._element = element;
                    } // Getters
                    var _proto = Tab.prototype;
                    // Public
                    _proto.show = function show() {
                        var _this = this;
                        if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && $__default["default"](this._element).hasClass(CLASS_NAME_ACTIVE) || $__default["default"](this._element).hasClass(CLASS_NAME_DISABLED) || this._element.hasAttribute("disabled")) return;
                        var target;
                        var previous;
                        var listElement = $__default["default"](this._element).closest(SELECTOR_NAV_LIST_GROUP)[0];
                        var selector = Util.getSelectorFromElement(this._element);
                        if (listElement) {
                            var itemSelector = listElement.nodeName === "UL" || listElement.nodeName === "OL" ? SELECTOR_ACTIVE_UL : SELECTOR_ACTIVE;
                            previous = $__default["default"].makeArray($__default["default"](listElement).find(itemSelector));
                            previous = previous[previous.length - 1];
                        }
                        var hideEvent = $__default["default"].Event(EVENT_HIDE$1, {
                            relatedTarget: this._element
                        });
                        var showEvent = $__default["default"].Event(EVENT_SHOW$1, {
                            relatedTarget: previous
                        });
                        if (previous) $__default["default"](previous).trigger(hideEvent);
                        $__default["default"](this._element).trigger(showEvent);
                        if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return;
                        if (selector) target = document.querySelector(selector);
                        this._activate(this._element, listElement);
                        var complete = function complete() {
                            var hiddenEvent = $__default["default"].Event(EVENT_HIDDEN$1, {
                                relatedTarget: _this._element
                            });
                            var shownEvent = $__default["default"].Event(EVENT_SHOWN$1, {
                                relatedTarget: previous
                            });
                            $__default["default"](previous).trigger(hiddenEvent);
                            $__default["default"](_this._element).trigger(shownEvent);
                        };
                        if (target) this._activate(target, target.parentNode, complete);
                        else complete();
                    };
                    _proto.dispose = function dispose() {
                        $__default["default"].removeData(this._element, DATA_KEY$1);
                        this._element = null;
                    } // Private
                    ;
                    _proto._activate = function _activate(element, container, callback) {
                        var _this2 = this;
                        var activeElements = container && (container.nodeName === "UL" || container.nodeName === "OL") ? $__default["default"](container).find(SELECTOR_ACTIVE_UL) : $__default["default"](container).children(SELECTOR_ACTIVE);
                        var active = activeElements[0];
                        var isTransitioning = callback && active && $__default["default"](active).hasClass(CLASS_NAME_FADE$1);
                        var complete = function complete() {
                            return _this2._transitionComplete(element, active, callback);
                        };
                        if (active && isTransitioning) {
                            var transitionDuration = Util.getTransitionDurationFromElement(active);
                            $__default["default"](active).removeClass(CLASS_NAME_SHOW$1).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
                        } else complete();
                    };
                    _proto._transitionComplete = function _transitionComplete(element, active, callback) {
                        if (active) {
                            $__default["default"](active).removeClass(CLASS_NAME_ACTIVE);
                            var dropdownChild = $__default["default"](active.parentNode).find(SELECTOR_DROPDOWN_ACTIVE_CHILD)[0];
                            if (dropdownChild) $__default["default"](dropdownChild).removeClass(CLASS_NAME_ACTIVE);
                            if (active.getAttribute("role") === "tab") active.setAttribute("aria-selected", false);
                        }
                        $__default["default"](element).addClass(CLASS_NAME_ACTIVE);
                        if (element.getAttribute("role") === "tab") element.setAttribute("aria-selected", true);
                        Util.reflow(element);
                        if (element.classList.contains(CLASS_NAME_FADE$1)) element.classList.add(CLASS_NAME_SHOW$1);
                        var parent = element.parentNode;
                        if (parent && parent.nodeName === "LI") parent = parent.parentNode;
                        if (parent && $__default["default"](parent).hasClass(CLASS_NAME_DROPDOWN_MENU)) {
                            var dropdownElement = $__default["default"](element).closest(SELECTOR_DROPDOWN)[0];
                            if (dropdownElement) {
                                var dropdownToggleList = [].slice.call(dropdownElement.querySelectorAll(SELECTOR_DROPDOWN_TOGGLE));
                                $__default["default"](dropdownToggleList).addClass(CLASS_NAME_ACTIVE);
                            }
                            element.setAttribute("aria-expanded", true);
                        }
                        if (callback) callback();
                    } // Static
                    ;
                    Tab._jQueryInterface = function _jQueryInterface(config) {
                        return this.each(function() {
                            var $this = $__default["default"](this);
                            var data = $this.data(DATA_KEY$1);
                            if (!data) {
                                data = new Tab(this);
                                $this.data(DATA_KEY$1, data);
                            }
                            if (typeof config === "string") {
                                if (typeof data[config] === "undefined") throw new TypeError('No method named "' + config + '"');
                                data[config]();
                            }
                        });
                    };
                    _createClass(Tab, null, [
                        {
                            key: "VERSION",
                            get: function get() {
                                return VERSION$1;
                            }
                        }
                    ]);
                    return Tab;
                }();
                /**
   * Data API implementation
   */ $__default["default"](document).on(EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function(event) {
                    event.preventDefault();
                    Tab._jQueryInterface.call($__default["default"](this), "show");
                });
                /**
   * jQuery
   */ $__default["default"].fn[NAME$1] = Tab._jQueryInterface;
                $__default["default"].fn[NAME$1].Constructor = Tab;
                $__default["default"].fn[NAME$1].noConflict = function() {
                    $__default["default"].fn[NAME$1] = JQUERY_NO_CONFLICT$1;
                    return Tab._jQueryInterface;
                };
                /**
   * Constants
   */ var NAME = "toast";
                var VERSION = "4.6.2";
                var DATA_KEY = "bs.toast";
                var EVENT_KEY = "." + DATA_KEY;
                var JQUERY_NO_CONFLICT = $__default["default"].fn[NAME];
                var CLASS_NAME_FADE = "fade";
                var CLASS_NAME_HIDE = "hide";
                var CLASS_NAME_SHOW = "show";
                var CLASS_NAME_SHOWING = "showing";
                var EVENT_CLICK_DISMISS = "click.dismiss" + EVENT_KEY;
                var EVENT_HIDE = "hide" + EVENT_KEY;
                var EVENT_HIDDEN = "hidden" + EVENT_KEY;
                var EVENT_SHOW = "show" + EVENT_KEY;
                var EVENT_SHOWN = "shown" + EVENT_KEY;
                var SELECTOR_DATA_DISMISS = '[data-dismiss="toast"]';
                var Default = {
                    animation: true,
                    autohide: true,
                    delay: 500
                };
                var DefaultType = {
                    animation: "boolean",
                    autohide: "boolean",
                    delay: "number"
                };
                /**
   * Class definition
   */ var Toast = /*#__PURE__*/ function() {
                    function Toast(element, config) {
                        this._element = element;
                        this._config = this._getConfig(config);
                        this._timeout = null;
                        this._setListeners();
                    } // Getters
                    var _proto = Toast.prototype;
                    // Public
                    _proto.show = function show() {
                        var _this = this;
                        var showEvent = $__default["default"].Event(EVENT_SHOW);
                        $__default["default"](this._element).trigger(showEvent);
                        if (showEvent.isDefaultPrevented()) return;
                        this._clearTimeout();
                        if (this._config.animation) this._element.classList.add(CLASS_NAME_FADE);
                        var complete = function complete() {
                            _this._element.classList.remove(CLASS_NAME_SHOWING);
                            _this._element.classList.add(CLASS_NAME_SHOW);
                            $__default["default"](_this._element).trigger(EVENT_SHOWN);
                            if (_this._config.autohide) _this._timeout = setTimeout(function() {
                                _this.hide();
                            }, _this._config.delay);
                        };
                        this._element.classList.remove(CLASS_NAME_HIDE);
                        Util.reflow(this._element);
                        this._element.classList.add(CLASS_NAME_SHOWING);
                        if (this._config.animation) {
                            var transitionDuration = Util.getTransitionDurationFromElement(this._element);
                            $__default["default"](this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
                        } else complete();
                    };
                    _proto.hide = function hide() {
                        if (!this._element.classList.contains(CLASS_NAME_SHOW)) return;
                        var hideEvent = $__default["default"].Event(EVENT_HIDE);
                        $__default["default"](this._element).trigger(hideEvent);
                        if (hideEvent.isDefaultPrevented()) return;
                        this._close();
                    };
                    _proto.dispose = function dispose() {
                        this._clearTimeout();
                        if (this._element.classList.contains(CLASS_NAME_SHOW)) this._element.classList.remove(CLASS_NAME_SHOW);
                        $__default["default"](this._element).off(EVENT_CLICK_DISMISS);
                        $__default["default"].removeData(this._element, DATA_KEY);
                        this._element = null;
                        this._config = null;
                    } // Private
                    ;
                    _proto._getConfig = function _getConfig(config) {
                        config = _extends({}, Default, $__default["default"](this._element).data(), typeof config === "object" && config ? config : {});
                        Util.typeCheckConfig(NAME, config, this.constructor.DefaultType);
                        return config;
                    };
                    _proto._setListeners = function _setListeners() {
                        var _this2 = this;
                        $__default["default"](this._element).on(EVENT_CLICK_DISMISS, SELECTOR_DATA_DISMISS, function() {
                            return _this2.hide();
                        });
                    };
                    _proto._close = function _close() {
                        var _this3 = this;
                        var complete = function complete() {
                            _this3._element.classList.add(CLASS_NAME_HIDE);
                            $__default["default"](_this3._element).trigger(EVENT_HIDDEN);
                        };
                        this._element.classList.remove(CLASS_NAME_SHOW);
                        if (this._config.animation) {
                            var transitionDuration = Util.getTransitionDurationFromElement(this._element);
                            $__default["default"](this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
                        } else complete();
                    };
                    _proto._clearTimeout = function _clearTimeout() {
                        clearTimeout(this._timeout);
                        this._timeout = null;
                    } // Static
                    ;
                    Toast._jQueryInterface = function _jQueryInterface(config) {
                        return this.each(function() {
                            var $element = $__default["default"](this);
                            var data = $element.data(DATA_KEY);
                            var _config = typeof config === "object" && config;
                            if (!data) {
                                data = new Toast(this, _config);
                                $element.data(DATA_KEY, data);
                            }
                            if (typeof config === "string") {
                                if (typeof data[config] === "undefined") throw new TypeError('No method named "' + config + '"');
                                data[config](this);
                            }
                        });
                    };
                    _createClass(Toast, null, [
                        {
                            key: "VERSION",
                            get: function get() {
                                return VERSION;
                            }
                        },
                        {
                            key: "DefaultType",
                            get: function get() {
                                return DefaultType;
                            }
                        },
                        {
                            key: "Default",
                            get: function get() {
                                return Default;
                            }
                        }
                    ]);
                    return Toast;
                }();
                /**
   * jQuery
   */ $__default["default"].fn[NAME] = Toast._jQueryInterface;
                $__default["default"].fn[NAME].Constructor = Toast;
                $__default["default"].fn[NAME].noConflict = function() {
                    $__default["default"].fn[NAME] = JQUERY_NO_CONFLICT;
                    return Toast._jQueryInterface;
                };
                exports.Alert = Alert;
                exports.Button = Button;
                exports.Carousel = Carousel;
                exports.Collapse = Collapse;
                exports.Dropdown = Dropdown;
                exports.Modal = Modal;
                exports.Popover = Popover;
                exports.Scrollspy = ScrollSpy;
                exports.Tab = Tab;
                exports.Toast = Toast;
                exports.Tooltip = Tooltip;
                exports.Util = Util;
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
            });
        },
        {
            "jquery": 14,
            "popper.js": 19
        }
    ],
    2: [
        function(require1, module, exports) {
            !function(e, t) {
                "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.AOS = t() : e.AOS = t();
            }(this, function() {
                return function(e) {
                    function t(o) {
                        if (n[o]) return n[o].exports;
                        var i = n[o] = {
                            exports: {},
                            id: o,
                            loaded: !1
                        };
                        return e[o].call(i.exports, i, i.exports, t), i.loaded = !0, i.exports;
                    }
                    var n = {};
                    return t.m = e, t.c = n, t.p = "dist/", t(0);
                }([
                    function(e, t, n) {
                        "use strict";
                        function o(e) {
                            return e && e.__esModule ? e : {
                                default: e
                            };
                        }
                        var i = Object.assign || function(e) {
                            for(var t = 1; t < arguments.length; t++){
                                var _$n = arguments[t];
                                for(var _$o in _$n)Object.prototype.hasOwnProperty.call(_$n, _$o) && (e[_$o] = _$n[_$o]);
                            }
                            return e;
                        }, r = n(1), a = (o(r), n(6)), u = o(a), c = n(7), s = o(c), f = n(8), d = o(f), l = n(9), p = o(l), m = n(10), b = o(m), v = n(11), y = o(v), g = n(14), h = o(g), w = [], k = !1, x = {
                            offset: 120,
                            delay: 0,
                            easing: "ease",
                            duration: 400,
                            disable: !1,
                            once: !1,
                            startEvent: "DOMContentLoaded",
                            throttleDelay: 99,
                            debounceDelay: 50,
                            disableMutationObserver: !1
                        }, j = function j() {
                            var _$e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                            if (_$e && (k = !0), k) return w = (0, y.default)(w, x), (0, b.default)(w, x.once), w;
                        }, O = function O() {
                            w = (0, h.default)(), j();
                        }, M = function M() {
                            w.forEach(function(e, t) {
                                e.node.removeAttribute("data-aos"), e.node.removeAttribute("data-aos-easing"), e.node.removeAttribute("data-aos-duration"), e.node.removeAttribute("data-aos-delay");
                            });
                        }, S = function S(e) {
                            return e === !0 || "mobile" === e && p.default.mobile() || "phone" === e && p.default.phone() || "tablet" === e && p.default.tablet() || "function" == typeof e && e() === !0;
                        }, _ = function _(e) {
                            x = i(x, e), w = (0, h.default)();
                            var t = document.all && !window.atob;
                            return S(x.disable) || t ? M() : (x.disableMutationObserver || d.default.isSupported() || (console.info('\n      aos: MutationObserver is not supported on this browser,\n      code mutations observing has been disabled.\n      You may have to call "refreshHard()" by yourself.\n    '), x.disableMutationObserver = !0), document.querySelector("body").setAttribute("data-aos-easing", x.easing), document.querySelector("body").setAttribute("data-aos-duration", x.duration), document.querySelector("body").setAttribute("data-aos-delay", x.delay), "DOMContentLoaded" === x.startEvent && [
                                "complete",
                                "interactive"
                            ].indexOf(document.readyState) > -1 ? j(!0) : "load" === x.startEvent ? window.addEventListener(x.startEvent, function() {
                                j(!0);
                            }) : document.addEventListener(x.startEvent, function() {
                                j(!0);
                            }), window.addEventListener("resize", (0, s.default)(j, x.debounceDelay, !0)), window.addEventListener("orientationchange", (0, s.default)(j, x.debounceDelay, !0)), window.addEventListener("scroll", (0, u.default)(function() {
                                (0, b.default)(w, x.once);
                            }, x.throttleDelay)), x.disableMutationObserver || d.default.ready("[data-aos]", O), w);
                        };
                        e.exports = {
                            init: _,
                            refresh: j,
                            refreshHard: O
                        };
                    },
                    function(e, t) {},
                    ,
                    ,
                    ,
                    ,
                    function(e, t) {
                        (function(t) {
                            "use strict";
                            function n(e, t, n) {
                                function o(t) {
                                    var _$n = b, _$o = v;
                                    return b = v = void 0, k = t, g = e.apply(_$o, _$n);
                                }
                                function r(e) {
                                    return k = e, h = setTimeout(f, t), M ? o(e) : g;
                                }
                                function a(e) {
                                    var _$n = e - w, _$o = e - k, _$i = t - _$n;
                                    return S ? j(_$i, y - _$o) : _$i;
                                }
                                function c(e) {
                                    var _$n = e - w, _$o = e - k;
                                    return void 0 === w || _$n >= t || _$n < 0 || S && _$o >= y;
                                }
                                function f() {
                                    var _$e = O();
                                    return c(_$e) ? d(_$e) : void (h = setTimeout(f, a(_$e)));
                                }
                                function d(e) {
                                    return h = void 0, _ && b ? o(e) : (b = v = void 0, g);
                                }
                                function l() {
                                    void 0 !== h && clearTimeout(h), k = 0, b = w = v = h = void 0;
                                }
                                function p() {
                                    return void 0 === h ? g : d(O());
                                }
                                function m() {
                                    var _$e = O(), _$n = c(_$e);
                                    if (b = arguments, v = this, w = _$e, _$n) {
                                        if (void 0 === h) return r(w);
                                        if (S) return h = setTimeout(f, t), o(w);
                                    }
                                    return void 0 === h && (h = setTimeout(f, t)), g;
                                }
                                var b, v, y, g, h, w, k = 0, M = !1, S = !1, _ = !0;
                                if ("function" != typeof e) throw new TypeError(s);
                                return t = u(t) || 0, i(n) && (M = !!n.leading, S = "maxWait" in n, y = S ? x(u(n.maxWait) || 0, t) : y, _ = "trailing" in n ? !!n.trailing : _), m.cancel = l, m.flush = p, m;
                            }
                            function o(e, t, o) {
                                var r = !0, a = !0;
                                if ("function" != typeof e) throw new TypeError(s);
                                return i(o) && (r = "leading" in o ? !!o.leading : r, a = "trailing" in o ? !!o.trailing : a), n(e, t, {
                                    leading: r,
                                    maxWait: t,
                                    trailing: a
                                });
                            }
                            function i(e) {
                                var _$t = "undefined" == typeof e ? "undefined" : c(e);
                                return !!e && ("object" == _$t || "function" == _$t);
                            }
                            function r(e) {
                                return !!e && "object" == ("undefined" == typeof e ? "undefined" : c(e));
                            }
                            function a(e) {
                                return "symbol" == ("undefined" == typeof e ? "undefined" : c(e)) || r(e) && k.call(e) == d;
                            }
                            function u(e) {
                                if ("number" == typeof e) return e;
                                if (a(e)) return f;
                                if (i(e)) {
                                    var _$t = "function" == typeof e.valueOf ? e.valueOf() : e;
                                    e = i(_$t) ? _$t + "" : _$t;
                                }
                                if ("string" != typeof e) return 0 === e ? e : +e;
                                e = e.replace(l, "");
                                var n = m.test(e);
                                return n || b.test(e) ? v(e.slice(2), n ? 2 : 8) : p.test(e) ? f : +e;
                            }
                            var c = "function" == typeof Symbol && "symbol" == (0, _typeOf._)(Symbol.iterator) ? function c(e) {
                                return typeof e === "undefined" ? "undefined" : (0, _typeOf._)(e);
                            } : function(e) {
                                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e === "undefined" ? "undefined" : (0, _typeOf._)(e);
                            }, s = "Expected a function", f = NaN, d = "[object Symbol]", l = /^\s+|\s+$/g, p = /^[-+]0x[0-9a-f]+$/i, m = /^0b[01]+$/i, b = /^0o[0-7]+$/i, v = parseInt, y = "object" == ("undefined" == typeof t ? "undefined" : c(t)) && t && t.Object === Object && t, g = "object" == ("undefined" == typeof self ? "undefined" : c(self)) && self && self.Object === Object && self, h = y || g || Function("return this")(), w = Object.prototype, k = w.toString, x = Math.max, j = Math.min, O = function O() {
                                return h.Date.now();
                            };
                            e.exports = o;
                        }).call(t, function() {
                            return this;
                        }());
                    },
                    function(e, t) {
                        (function(t) {
                            "use strict";
                            function n(e, t, n) {
                                function i(t) {
                                    var _$n = b, _$o = v;
                                    return b = v = void 0, O = t, g = e.apply(_$o, _$n);
                                }
                                function r(e) {
                                    return O = e, h = setTimeout(f, t), M ? i(e) : g;
                                }
                                function u(e) {
                                    var _$n = e - w, _$o = e - O, i = t - _$n;
                                    return S ? x(i, y - _$o) : i;
                                }
                                function s(e) {
                                    var _$n = e - w, _$o = e - O;
                                    return void 0 === w || _$n >= t || _$n < 0 || S && _$o >= y;
                                }
                                function f() {
                                    var _$e = j();
                                    return s(_$e) ? d(_$e) : void (h = setTimeout(f, u(_$e)));
                                }
                                function d(e) {
                                    return h = void 0, _ && b ? i(e) : (b = v = void 0, g);
                                }
                                function l() {
                                    void 0 !== h && clearTimeout(h), O = 0, b = w = v = h = void 0;
                                }
                                function p() {
                                    return void 0 === h ? g : d(j());
                                }
                                function m() {
                                    var _$e = j(), _$n = s(_$e);
                                    if (b = arguments, v = this, w = _$e, _$n) {
                                        if (void 0 === h) return r(w);
                                        if (S) return h = setTimeout(f, t), i(w);
                                    }
                                    return void 0 === h && (h = setTimeout(f, t)), g;
                                }
                                var b, v, y, g, h, w, O = 0, M = !1, S = !1, _ = !0;
                                if ("function" != typeof e) throw new TypeError(c);
                                return t = a(t) || 0, o(n) && (M = !!n.leading, S = "maxWait" in n, y = S ? k(a(n.maxWait) || 0, t) : y, _ = "trailing" in n ? !!n.trailing : _), m.cancel = l, m.flush = p, m;
                            }
                            function o(e) {
                                var _$t = "undefined" == typeof e ? "undefined" : u(e);
                                return !!e && ("object" == _$t || "function" == _$t);
                            }
                            function i(e) {
                                return !!e && "object" == ("undefined" == typeof e ? "undefined" : u(e));
                            }
                            function r(e) {
                                return "symbol" == ("undefined" == typeof e ? "undefined" : u(e)) || i(e) && w.call(e) == f;
                            }
                            function a(e) {
                                if ("number" == typeof e) return e;
                                if (r(e)) return s;
                                if (o(e)) {
                                    var _$t = "function" == typeof e.valueOf ? e.valueOf() : e;
                                    e = o(_$t) ? _$t + "" : _$t;
                                }
                                if ("string" != typeof e) return 0 === e ? e : +e;
                                e = e.replace(d, "");
                                var _$n = p.test(e);
                                return _$n || m.test(e) ? b(e.slice(2), _$n ? 2 : 8) : l.test(e) ? s : +e;
                            }
                            var u = "function" == typeof Symbol && "symbol" == (0, _typeOf._)(Symbol.iterator) ? function u(e) {
                                return typeof e === "undefined" ? "undefined" : (0, _typeOf._)(e);
                            } : function(e) {
                                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e === "undefined" ? "undefined" : (0, _typeOf._)(e);
                            }, c = "Expected a function", s = NaN, f = "[object Symbol]", d = /^\s+|\s+$/g, l = /^[-+]0x[0-9a-f]+$/i, p = /^0b[01]+$/i, m = /^0o[0-7]+$/i, b = parseInt, v = "object" == ("undefined" == typeof t ? "undefined" : u(t)) && t && t.Object === Object && t, y = "object" == ("undefined" == typeof self ? "undefined" : u(self)) && self && self.Object === Object && self, g = v || y || Function("return this")(), h = Object.prototype, w = h.toString, k = Math.max, x = Math.min, j = function j() {
                                return g.Date.now();
                            };
                            e.exports = n;
                        }).call(t, function() {
                            return this;
                        }());
                    },
                    function(e, t) {
                        "use strict";
                        function n(e) {
                            var _$t = void 0, o = void 0, _$i = void 0;
                            for(_$t = 0; _$t < e.length; _$t += 1){
                                if (o = e[_$t], o.dataset && o.dataset.aos) return !0;
                                if (_$i = o.children && n(o.children)) return !0;
                            }
                            return !1;
                        }
                        function o() {
                            return window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;
                        }
                        function i() {
                            return !!o();
                        }
                        function r(e, t) {
                            var n = window.document, _$i = o(), _$r = new _$i(a);
                            u = t, _$r.observe(n.documentElement, {
                                childList: !0,
                                subtree: !0,
                                removedNodes: !0
                            });
                        }
                        function a(e) {
                            e && e.forEach(function(e) {
                                var _$t = Array.prototype.slice.call(e.addedNodes), o = Array.prototype.slice.call(e.removedNodes), _$i = _$t.concat(o);
                                if (n(_$i)) return u();
                            });
                        }
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        });
                        var u = function u() {};
                        t.default = {
                            isSupported: i,
                            ready: r
                        };
                    },
                    function(e, t) {
                        "use strict";
                        function n(e, t) {
                            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
                        }
                        function o() {
                            return navigator.userAgent || navigator.vendor || window.opera || "";
                        }
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        });
                        var i = function() {
                            function e(e, t) {
                                for(var n = 0; n < t.length; n++){
                                    var o = t[n];
                                    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);
                                }
                            }
                            return function(t, n, o) {
                                return n && e(t.prototype, n), o && e(t, o), t;
                            };
                        }(), r = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i, a = /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i, u = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i, c = /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i, s = function() {
                            function e() {
                                n(this, e);
                            }
                            return i(e, [
                                {
                                    key: "phone",
                                    value: function value() {
                                        var _$e = o();
                                        return !(!r.test(_$e) && !a.test(_$e.substr(0, 4)));
                                    }
                                },
                                {
                                    key: "mobile",
                                    value: function value() {
                                        var _$e = o();
                                        return !(!u.test(_$e) && !c.test(_$e.substr(0, 4)));
                                    }
                                },
                                {
                                    key: "tablet",
                                    value: function value() {
                                        return this.mobile() && !this.phone();
                                    }
                                }
                            ]), e;
                        }();
                        t.default = new s;
                    },
                    function(e, t) {
                        "use strict";
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        });
                        var n = function n(e, t, n) {
                            var o = e.node.getAttribute("data-aos-once");
                            t > e.position ? e.node.classList.add("aos-animate") : "undefined" != typeof o && ("false" === o || !n && "true" !== o) && e.node.classList.remove("aos-animate");
                        }, o = function o(e, t) {
                            var o = window.pageYOffset, i = window.innerHeight;
                            e.forEach(function(e, r) {
                                n(e, i + o, t);
                            });
                        };
                        t.default = o;
                    },
                    function(e, t, n) {
                        "use strict";
                        function o(e) {
                            return e && e.__esModule ? e : {
                                default: e
                            };
                        }
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        });
                        var i = n(12), r = o(i), a = function a(e, t) {
                            return e.forEach(function(e, n) {
                                e.node.classList.add("aos-init"), e.position = (0, r.default)(e.node, t.offset);
                            }), e;
                        };
                        t.default = a;
                    },
                    function(e, t, n) {
                        "use strict";
                        function o(e) {
                            return e && e.__esModule ? e : {
                                default: e
                            };
                        }
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        });
                        var i = n(13), r = o(i), a = function a(e, t) {
                            var _$n = 0, _$o = 0, i = window.innerHeight, a = {
                                offset: e.getAttribute("data-aos-offset"),
                                anchor: e.getAttribute("data-aos-anchor"),
                                anchorPlacement: e.getAttribute("data-aos-anchor-placement")
                            };
                            switch(a.offset && !isNaN(a.offset) && (_$o = parseInt(a.offset)), a.anchor && document.querySelectorAll(a.anchor) && (e = document.querySelectorAll(a.anchor)[0]), _$n = (0, r.default)(e).top, a.anchorPlacement){
                                case "top-bottom":
                                    break;
                                case "center-bottom":
                                    _$n += e.offsetHeight / 2;
                                    break;
                                case "bottom-bottom":
                                    _$n += e.offsetHeight;
                                    break;
                                case "top-center":
                                    _$n += i / 2;
                                    break;
                                case "bottom-center":
                                    _$n += i / 2 + e.offsetHeight;
                                    break;
                                case "center-center":
                                    _$n += i / 2 + e.offsetHeight / 2;
                                    break;
                                case "top-top":
                                    _$n += i;
                                    break;
                                case "bottom-top":
                                    _$n += e.offsetHeight + i;
                                    break;
                                case "center-top":
                                    _$n += e.offsetHeight / 2 + i;
                            }
                            return a.anchorPlacement || a.offset || isNaN(t) || (_$o = t), _$n + _$o;
                        };
                        t.default = a;
                    },
                    function(e, t) {
                        "use strict";
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        });
                        var n = function n(e) {
                            for(var _$t = 0, n = 0; e && !isNaN(e.offsetLeft) && !isNaN(e.offsetTop);)_$t += e.offsetLeft - ("BODY" != e.tagName ? e.scrollLeft : 0), n += e.offsetTop - ("BODY" != e.tagName ? e.scrollTop : 0), e = e.offsetParent;
                            return {
                                top: n,
                                left: _$t
                            };
                        };
                        t.default = n;
                    },
                    function(e, t) {
                        "use strict";
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        });
                        var n = function n(e) {
                            return e = e || document.querySelectorAll("[data-aos]"), Array.prototype.map.call(e, function(e) {
                                return {
                                    node: e
                                };
                            });
                        };
                        t.default = n;
                    }
                ]);
            });
        },
        {}
    ],
    3: [
        function(require1, module, exports) {
            /**
 * matchesSelector v2.0.2
 * matchesSelector( element, '.selector' )
 * MIT license
 */ /*jshint browser: true, strict: true, undef: true, unused: true */ (function(window1, factory) {
                /*global define: false, module: false */ "use strict";
                // universal module definition
                if (typeof define == "function" && define.amd) // AMD
                define(factory);
                else if (typeof module == "object" && module.exports) // CommonJS
                module.exports = factory();
                else // browser global
                window1.matchesSelector = factory();
            })(window, function factory() {
                "use strict";
                var matchesMethod = function() {
                    var ElemProto = window.Element.prototype;
                    // check for the standard method name first
                    if (ElemProto.matches) return "matches";
                    // check un-prefixed
                    if (ElemProto.matchesSelector) return "matchesSelector";
                    // check vendor prefixes
                    var prefixes = [
                        "webkit",
                        "moz",
                        "ms",
                        "o"
                    ];
                    for(var i = 0; i < prefixes.length; i++){
                        var prefix = prefixes[i];
                        var method = prefix + "MatchesSelector";
                        if (ElemProto[method]) return method;
                    }
                }();
                return function matchesSelector(elem, selector) {
                    return elem[matchesMethod](selector);
                };
            });
        },
        {}
    ],
    4: [
        function(require1, module, exports) {
            /**
 * EvEmitter v1.1.0
 * Lil' event emitter
 * MIT License
 */ /* jshint unused: true, undef: true, strict: true */ (function(global, factory) {
                // universal module definition
                /* jshint strict: false */ /* globals define, module, window */ if (typeof define == "function" && define.amd) // AMD - RequireJS
                define(factory);
                else if (typeof module == "object" && module.exports) // CommonJS - Browserify, Webpack
                module.exports = factory();
                else // Browser globals
                global.EvEmitter = factory();
            })(typeof window != "undefined" ? window : this, function() {
                "use strict";
                function EvEmitter() {}
                var proto = EvEmitter.prototype;
                proto.on = function(eventName, listener) {
                    if (!eventName || !listener) return;
                    // set events hash
                    var events = this._events = this._events || {};
                    // set listeners array
                    var listeners = events[eventName] = events[eventName] || [];
                    // only add once
                    if (listeners.indexOf(listener) == -1) listeners.push(listener);
                    return this;
                };
                proto.once = function(eventName, listener) {
                    if (!eventName || !listener) return;
                    // add event
                    this.on(eventName, listener);
                    // set once flag
                    // set onceEvents hash
                    var onceEvents = this._onceEvents = this._onceEvents || {};
                    // set onceListeners object
                    var onceListeners = onceEvents[eventName] = onceEvents[eventName] || {};
                    // set flag
                    onceListeners[listener] = true;
                    return this;
                };
                proto.off = function(eventName, listener) {
                    var listeners = this._events && this._events[eventName];
                    if (!listeners || !listeners.length) return;
                    var index = listeners.indexOf(listener);
                    if (index != -1) listeners.splice(index, 1);
                    return this;
                };
                proto.emitEvent = function(eventName, args) {
                    var listeners = this._events && this._events[eventName];
                    if (!listeners || !listeners.length) return;
                    // copy over to avoid interference if .off() in listener
                    listeners = listeners.slice(0);
                    args = args || [];
                    // once stuff
                    var onceListeners = this._onceEvents && this._onceEvents[eventName];
                    for(var i = 0; i < listeners.length; i++){
                        var listener = listeners[i];
                        var isOnce = onceListeners && onceListeners[listener];
                        if (isOnce) {
                            // remove listener
                            // remove before trigger to prevent recursion
                            this.off(eventName, listener);
                            // unset once flag
                            delete onceListeners[listener];
                        }
                        // trigger listener
                        listener.apply(this, args);
                    }
                    return this;
                };
                proto.allOff = function() {
                    delete this._events;
                    delete this._onceEvents;
                };
                return EvEmitter;
            });
        },
        {}
    ],
    5: [
        function(require1, module, exports) {
            /**
 * Fizzy UI utils v2.0.7
 * MIT license
 */ /*jshint browser: true, undef: true, unused: true, strict: true */ (function(window1, factory) {
                // universal module definition
                /*jshint strict: false */ /*globals define, module, require */ if (typeof define == "function" && define.amd) // AMD
                define([
                    "desandro-matches-selector/matches-selector"
                ], function(matchesSelector) {
                    return factory(window1, matchesSelector);
                });
                else if (typeof module == "object" && module.exports) // CommonJS
                module.exports = factory(window1, require1("desandro-matches-selector"));
                else // browser global
                window1.fizzyUIUtils = factory(window1, window1.matchesSelector);
            })(window, function factory(window1, matchesSelector) {
                "use strict";
                var utils = {};
                // ----- extend ----- //
                // extends objects
                utils.extend = function(a, b) {
                    for(var prop in b)a[prop] = b[prop];
                    return a;
                };
                // ----- modulo ----- //
                utils.modulo = function(num, div) {
                    return (num % div + div) % div;
                };
                // ----- makeArray ----- //
                var arraySlice = Array.prototype.slice;
                // turn element or nodeList into an array
                utils.makeArray = function(obj) {
                    if (Array.isArray(obj)) // use object if already an array
                    return obj;
                    // return empty array if undefined or null. #6
                    if (obj === null || obj === undefined) return [];
                    var isArrayLike = typeof obj == "object" && typeof obj.length == "number";
                    if (isArrayLike) // convert nodeList to array
                    return arraySlice.call(obj);
                    // array of single index
                    return [
                        obj
                    ];
                };
                // ----- removeFrom ----- //
                utils.removeFrom = function(ary, obj) {
                    var index = ary.indexOf(obj);
                    if (index != -1) ary.splice(index, 1);
                };
                // ----- getParent ----- //
                utils.getParent = function(elem, selector) {
                    while(elem.parentNode && elem != document.body){
                        elem = elem.parentNode;
                        if (matchesSelector(elem, selector)) return elem;
                    }
                };
                // ----- getQueryElement ----- //
                // use element as selector string
                utils.getQueryElement = function(elem) {
                    if (typeof elem == "string") return document.querySelector(elem);
                    return elem;
                };
                // ----- handleEvent ----- //
                // enable .ontype to trigger from .addEventListener( elem, 'type' )
                utils.handleEvent = function(event) {
                    var method = "on" + event.type;
                    if (this[method]) this[method](event);
                };
                // ----- filterFindElements ----- //
                utils.filterFindElements = function(elems, selector) {
                    // make array of elems
                    elems = utils.makeArray(elems);
                    var ffElems = [];
                    elems.forEach(function(elem) {
                        // check that elem is an actual element
                        if (!(elem instanceof HTMLElement)) return;
                        // add elem if no selector
                        if (!selector) {
                            ffElems.push(elem);
                            return;
                        }
                        // filter & find items if we have a selector
                        // filter
                        if (matchesSelector(elem, selector)) ffElems.push(elem);
                        // find children
                        var childElems = elem.querySelectorAll(selector);
                        // concat childElems to filterFound array
                        for(var i = 0; i < childElems.length; i++)ffElems.push(childElems[i]);
                    });
                    return ffElems;
                };
                // ----- debounceMethod ----- //
                utils.debounceMethod = function(_class, methodName, threshold) {
                    threshold = threshold || 100;
                    // original method
                    var method = _class.prototype[methodName];
                    var timeoutName = methodName + "Timeout";
                    _class.prototype[methodName] = function() {
                        var timeout = this[timeoutName];
                        clearTimeout(timeout);
                        var args = arguments;
                        var _this = this;
                        this[timeoutName] = setTimeout(function() {
                            method.apply(_this, args);
                            delete _this[timeoutName];
                        }, threshold);
                    };
                };
                // ----- docReady ----- //
                utils.docReady = function(callback) {
                    var readyState = document.readyState;
                    if (readyState == "complete" || readyState == "interactive") // do async to allow for other scripts to run. metafizzy/flickity#441
                    setTimeout(callback);
                    else document.addEventListener("DOMContentLoaded", callback);
                };
                // ----- htmlInit ----- //
                // http://jamesroberts.name/blog/2010/02/22/string-functions-for-javascript-trim-to-camel-case-to-dashed-and-to-underscore/
                utils.toDashed = function(str) {
                    return str.replace(/(.)([A-Z])/g, function(match, $1, $2) {
                        return $1 + "-" + $2;
                    }).toLowerCase();
                };
                var console1 = window1.console;
                /**
 * allow user to initialize classes via [data-namespace] or .js-namespace class
 * htmlInit( Widget, 'widgetName' )
 * options are parsed from data-namespace-options
 */ utils.htmlInit = function(WidgetClass, namespace) {
                    utils.docReady(function() {
                        var dashedNamespace = utils.toDashed(namespace);
                        var dataAttr = "data-" + dashedNamespace;
                        var dataAttrElems = document.querySelectorAll("[" + dataAttr + "]");
                        var jsDashElems = document.querySelectorAll(".js-" + dashedNamespace);
                        var elems = utils.makeArray(dataAttrElems).concat(utils.makeArray(jsDashElems));
                        var dataOptionsAttr = dataAttr + "-options";
                        var jQuery1 = window1.jQuery;
                        elems.forEach(function(elem) {
                            var attr = elem.getAttribute(dataAttr) || elem.getAttribute(dataOptionsAttr);
                            var options;
                            try {
                                options = attr && JSON.parse(attr);
                            } catch (error) {
                                // log error, do not initialize
                                if (console1) console1.error("Error parsing " + dataAttr + " on " + elem.className + ": " + error);
                                return;
                            }
                            // initialize
                            var instance = new WidgetClass(elem, options);
                            // make available via $().data('namespace')
                            if (jQuery1) jQuery1.data(elem, namespace, instance);
                        });
                    });
                };
                // -----  ----- //
                return utils;
            });
        },
        {
            "desandro-matches-selector": 3
        }
    ],
    6: [
        function(require1, module, exports) {
            /*!
 * getSize v2.0.3
 * measure size of elements
 * MIT license
 */ /* jshint browser: true, strict: true, undef: true, unused: true */ /* globals console: false */ (function(window1, factory) {
                /* jshint strict: false */ /* globals define, module */ if (typeof define == "function" && define.amd) // AMD
                define(factory);
                else if (typeof module == "object" && module.exports) // CommonJS
                module.exports = factory();
                else // browser global
                window1.getSize = factory();
            })(window, function factory() {
                "use strict";
                // -------------------------- helpers -------------------------- //
                // get a number from a string, not a percentage
                function getStyleSize(value) {
                    var num = parseFloat(value);
                    // not a percent like '100%', and a number
                    var isValid = value.indexOf("%") == -1 && !isNaN(num);
                    return isValid && num;
                }
                function noop() {}
                var logError = typeof console == "undefined" ? noop : function logError(message) {
                    console.error(message);
                };
                // -------------------------- measurements -------------------------- //
                var measurements = [
                    "paddingLeft",
                    "paddingRight",
                    "paddingTop",
                    "paddingBottom",
                    "marginLeft",
                    "marginRight",
                    "marginTop",
                    "marginBottom",
                    "borderLeftWidth",
                    "borderRightWidth",
                    "borderTopWidth",
                    "borderBottomWidth"
                ];
                var measurementsLength = measurements.length;
                function getZeroSize() {
                    var size = {
                        width: 0,
                        height: 0,
                        innerWidth: 0,
                        innerHeight: 0,
                        outerWidth: 0,
                        outerHeight: 0
                    };
                    for(var i = 0; i < measurementsLength; i++){
                        var measurement = measurements[i];
                        size[measurement] = 0;
                    }
                    return size;
                }
                // -------------------------- getStyle -------------------------- //
                /**
 * getStyle, get style of element, check for Firefox bug
 * https://bugzilla.mozilla.org/show_bug.cgi?id=548397
 */ function getStyle(elem) {
                    var style = getComputedStyle(elem);
                    if (!style) logError("Style returned " + style + ". Are you running this code in a hidden iframe on Firefox? " + "See https://bit.ly/getsizebug1");
                    return style;
                }
                // -------------------------- setup -------------------------- //
                var isSetup = false;
                var isBoxSizeOuter;
                /**
 * setup
 * check isBoxSizerOuter
 * do on first getSize() rather than on page load for Firefox bug
 */ function setup() {
                    // setup once
                    if (isSetup) return;
                    isSetup = true;
                    // -------------------------- box sizing -------------------------- //
                    /**
   * Chrome & Safari measure the outer-width on style.width on border-box elems
   * IE11 & Firefox<29 measures the inner-width
   */ var div = document.createElement("div");
                    div.style.width = "200px";
                    div.style.padding = "1px 2px 3px 4px";
                    div.style.borderStyle = "solid";
                    div.style.borderWidth = "1px 2px 3px 4px";
                    div.style.boxSizing = "border-box";
                    var body = document.body || document.documentElement;
                    body.appendChild(div);
                    var style = getStyle(div);
                    // round value for browser zoom. desandro/masonry#928
                    isBoxSizeOuter = Math.round(getStyleSize(style.width)) == 200;
                    getSize.isBoxSizeOuter = isBoxSizeOuter;
                    body.removeChild(div);
                }
                // -------------------------- getSize -------------------------- //
                function getSize(elem) {
                    setup();
                    // use querySeletor if elem is string
                    if (typeof elem == "string") elem = document.querySelector(elem);
                    // do not proceed on non-objects
                    if (!elem || typeof elem != "object" || !elem.nodeType) return;
                    var style = getStyle(elem);
                    // if hidden, everything is 0
                    if (style.display == "none") return getZeroSize();
                    var size = {};
                    size.width = elem.offsetWidth;
                    size.height = elem.offsetHeight;
                    var isBorderBox = size.isBorderBox = style.boxSizing == "border-box";
                    // get all measurements
                    for(var i = 0; i < measurementsLength; i++){
                        var measurement = measurements[i];
                        var value = style[measurement];
                        var num = parseFloat(value);
                        // any 'auto', 'medium' value will be 0
                        size[measurement] = !isNaN(num) ? num : 0;
                    }
                    var paddingWidth = size.paddingLeft + size.paddingRight;
                    var paddingHeight = size.paddingTop + size.paddingBottom;
                    var marginWidth = size.marginLeft + size.marginRight;
                    var marginHeight = size.marginTop + size.marginBottom;
                    var borderWidth = size.borderLeftWidth + size.borderRightWidth;
                    var borderHeight = size.borderTopWidth + size.borderBottomWidth;
                    var isBorderBoxSizeOuter = isBorderBox && isBoxSizeOuter;
                    // overwrite width and height if we can get it from style
                    var styleWidth = getStyleSize(style.width);
                    if (styleWidth !== false) size.width = styleWidth + // add padding and border unless it's already including it
                    (isBorderBoxSizeOuter ? 0 : paddingWidth + borderWidth);
                    var styleHeight = getStyleSize(style.height);
                    if (styleHeight !== false) size.height = styleHeight + // add padding and border unless it's already including it
                    (isBorderBoxSizeOuter ? 0 : paddingHeight + borderHeight);
                    size.innerWidth = size.width - (paddingWidth + borderWidth);
                    size.innerHeight = size.height - (paddingHeight + borderHeight);
                    size.outerWidth = size.width + marginWidth;
                    size.outerHeight = size.height + marginHeight;
                    return size;
                }
                return getSize;
            });
        },
        {}
    ],
    7: [
        function(require1, module, exports) {
            /*!
 * imagesLoaded v4.1.4
 * JavaScript is all like "You images are done yet or what?"
 * MIT License
 */ (function(window1, factory) {
                "use strict";
                // universal module definition
                /*global define: false, module: false, require: false */ if (typeof define == "function" && define.amd) // AMD
                define([
                    "ev-emitter/ev-emitter"
                ], function(EvEmitter) {
                    return factory(window1, EvEmitter);
                });
                else if (typeof module == "object" && module.exports) // CommonJS
                module.exports = factory(window1, require1("ev-emitter"));
                else // browser global
                window1.imagesLoaded = factory(window1, window1.EvEmitter);
            })(typeof window !== "undefined" ? window : this, // --------------------------  factory -------------------------- //
            function factory(window1, EvEmitter) {
                "use strict";
                var $ = window1.jQuery;
                var console1 = window1.console;
                // -------------------------- helpers -------------------------- //
                // extend objects
                function extend(a, b) {
                    for(var prop in b)a[prop] = b[prop];
                    return a;
                }
                var arraySlice = Array.prototype.slice;
                // turn element or nodeList into an array
                function makeArray(obj) {
                    if (Array.isArray(obj)) // use object if already an array
                    return obj;
                    var isArrayLike = typeof obj == "object" && typeof obj.length == "number";
                    if (isArrayLike) // convert nodeList to array
                    return arraySlice.call(obj);
                    // array of single index
                    return [
                        obj
                    ];
                }
                // -------------------------- imagesLoaded -------------------------- //
                /**
 * @param {Array, Element, NodeList, String} elem
 * @param {Object or Function} options - if function, use as callback
 * @param {Function} onAlways - callback function
 */ function ImagesLoaded(elem, options, onAlways) {
                    // coerce ImagesLoaded() without new, to be new ImagesLoaded()
                    if (!(this instanceof ImagesLoaded)) return new ImagesLoaded(elem, options, onAlways);
                    // use elem as selector string
                    var queryElem = elem;
                    if (typeof elem == "string") queryElem = document.querySelectorAll(elem);
                    // bail if bad element
                    if (!queryElem) {
                        console1.error("Bad element for imagesLoaded " + (queryElem || elem));
                        return;
                    }
                    this.elements = makeArray(queryElem);
                    this.options = extend({}, this.options);
                    // shift arguments if no options set
                    if (typeof options == "function") onAlways = options;
                    else extend(this.options, options);
                    if (onAlways) this.on("always", onAlways);
                    this.getImages();
                    if ($) // add jQuery Deferred object
                    this.jqDeferred = new $.Deferred();
                    // HACK check async to allow time to bind listeners
                    setTimeout(this.check.bind(this));
                }
                ImagesLoaded.prototype = Object.create(EvEmitter.prototype);
                ImagesLoaded.prototype.options = {};
                ImagesLoaded.prototype.getImages = function() {
                    this.images = [];
                    // filter & find items if we have an item selector
                    this.elements.forEach(this.addElementImages, this);
                };
                /**
 * @param {Node} element
 */ ImagesLoaded.prototype.addElementImages = function(elem) {
                    // filter siblings
                    if (elem.nodeName == "IMG") this.addImage(elem);
                    // get background image on element
                    if (this.options.background === true) this.addElementBackgroundImages(elem);
                    // find children
                    // no non-element nodes, #143
                    var nodeType = elem.nodeType;
                    if (!nodeType || !elementNodeTypes[nodeType]) return;
                    var childImgs = elem.querySelectorAll("img");
                    // concat childElems to filterFound array
                    for(var i = 0; i < childImgs.length; i++){
                        var img = childImgs[i];
                        this.addImage(img);
                    }
                    // get child background images
                    if (typeof this.options.background == "string") {
                        var children = elem.querySelectorAll(this.options.background);
                        for(i = 0; i < children.length; i++){
                            var child = children[i];
                            this.addElementBackgroundImages(child);
                        }
                    }
                };
                var elementNodeTypes = {
                    1: true,
                    9: true,
                    11: true
                };
                ImagesLoaded.prototype.addElementBackgroundImages = function(elem) {
                    var style = getComputedStyle(elem);
                    if (!style) // Firefox returns null if in a hidden iframe https://bugzil.la/548397
                    return;
                    // get url inside url("...")
                    var reURL = /url\((['"])?(.*?)\1\)/gi;
                    var matches = reURL.exec(style.backgroundImage);
                    while(matches !== null){
                        var url = matches && matches[2];
                        if (url) this.addBackground(url, elem);
                        matches = reURL.exec(style.backgroundImage);
                    }
                };
                /**
 * @param {Image} img
 */ ImagesLoaded.prototype.addImage = function(img) {
                    var loadingImage = new LoadingImage(img);
                    this.images.push(loadingImage);
                };
                ImagesLoaded.prototype.addBackground = function(url, elem) {
                    var background = new Background(url, elem);
                    this.images.push(background);
                };
                ImagesLoaded.prototype.check = function() {
                    var _this = this;
                    this.progressedCount = 0;
                    this.hasAnyBroken = false;
                    // complete if no images
                    if (!this.images.length) {
                        this.complete();
                        return;
                    }
                    function onProgress(image, elem, message) {
                        // HACK - Chrome triggers event before object properties have changed. #83
                        setTimeout(function() {
                            _this.progress(image, elem, message);
                        });
                    }
                    this.images.forEach(function(loadingImage) {
                        loadingImage.once("progress", onProgress);
                        loadingImage.check();
                    });
                };
                ImagesLoaded.prototype.progress = function(image, elem, message) {
                    this.progressedCount++;
                    this.hasAnyBroken = this.hasAnyBroken || !image.isLoaded;
                    // progress event
                    this.emitEvent("progress", [
                        this,
                        image,
                        elem
                    ]);
                    if (this.jqDeferred && this.jqDeferred.notify) this.jqDeferred.notify(this, image);
                    // check if completed
                    if (this.progressedCount == this.images.length) this.complete();
                    if (this.options.debug && console1) console1.log("progress: " + message, image, elem);
                };
                ImagesLoaded.prototype.complete = function() {
                    var eventName = this.hasAnyBroken ? "fail" : "done";
                    this.isComplete = true;
                    this.emitEvent(eventName, [
                        this
                    ]);
                    this.emitEvent("always", [
                        this
                    ]);
                    if (this.jqDeferred) {
                        var jqMethod = this.hasAnyBroken ? "reject" : "resolve";
                        this.jqDeferred[jqMethod](this);
                    }
                };
                // --------------------------  -------------------------- //
                function LoadingImage(img) {
                    this.img = img;
                }
                LoadingImage.prototype = Object.create(EvEmitter.prototype);
                LoadingImage.prototype.check = function() {
                    // If complete is true and browser supports natural sizes,
                    // try to check for image status manually.
                    var isComplete = this.getIsImageComplete();
                    if (isComplete) {
                        // report based on naturalWidth
                        this.confirm(this.img.naturalWidth !== 0, "naturalWidth");
                        return;
                    }
                    // If none of the checks above matched, simulate loading on detached element.
                    this.proxyImage = new Image();
                    this.proxyImage.addEventListener("load", this);
                    this.proxyImage.addEventListener("error", this);
                    // bind to image as well for Firefox. #191
                    this.img.addEventListener("load", this);
                    this.img.addEventListener("error", this);
                    this.proxyImage.src = this.img.src;
                };
                LoadingImage.prototype.getIsImageComplete = function() {
                    // check for non-zero, non-undefined naturalWidth
                    // fixes Safari+InfiniteScroll+Masonry bug infinite-scroll#671
                    return this.img.complete && this.img.naturalWidth;
                };
                LoadingImage.prototype.confirm = function(isLoaded, message) {
                    this.isLoaded = isLoaded;
                    this.emitEvent("progress", [
                        this,
                        this.img,
                        message
                    ]);
                };
                // ----- events ----- //
                // trigger specified handler for event type
                LoadingImage.prototype.handleEvent = function(event) {
                    var method = "on" + event.type;
                    if (this[method]) this[method](event);
                };
                LoadingImage.prototype.onload = function() {
                    this.confirm(true, "onload");
                    this.unbindEvents();
                };
                LoadingImage.prototype.onerror = function() {
                    this.confirm(false, "onerror");
                    this.unbindEvents();
                };
                LoadingImage.prototype.unbindEvents = function() {
                    this.proxyImage.removeEventListener("load", this);
                    this.proxyImage.removeEventListener("error", this);
                    this.img.removeEventListener("load", this);
                    this.img.removeEventListener("error", this);
                };
                // -------------------------- Background -------------------------- //
                function Background(url, element) {
                    this.url = url;
                    this.element = element;
                    this.img = new Image();
                }
                // inherit LoadingImage prototype
                Background.prototype = Object.create(LoadingImage.prototype);
                Background.prototype.check = function() {
                    this.img.addEventListener("load", this);
                    this.img.addEventListener("error", this);
                    this.img.src = this.url;
                    // check if image is already complete
                    var isComplete = this.getIsImageComplete();
                    if (isComplete) {
                        this.confirm(this.img.naturalWidth !== 0, "naturalWidth");
                        this.unbindEvents();
                    }
                };
                Background.prototype.unbindEvents = function() {
                    this.img.removeEventListener("load", this);
                    this.img.removeEventListener("error", this);
                };
                Background.prototype.confirm = function(isLoaded, message) {
                    this.isLoaded = isLoaded;
                    this.emitEvent("progress", [
                        this,
                        this.element,
                        message
                    ]);
                };
                // -------------------------- jQuery -------------------------- //
                ImagesLoaded.makeJQueryPlugin = function(jQuery1) {
                    jQuery1 = jQuery1 || window1.jQuery;
                    if (!jQuery1) return;
                    // set local variable
                    $ = jQuery1;
                    // $().imagesLoaded()
                    $.fn.imagesLoaded = function(options, callback) {
                        var instance = new ImagesLoaded(this, options, callback);
                        return instance.jqDeferred.promise($(this));
                    };
                };
                // try making plugin
                ImagesLoaded.makeJQueryPlugin();
                // --------------------------  -------------------------- //
                return ImagesLoaded;
            });
        },
        {
            "ev-emitter": 4
        }
    ],
    8: [
        function(require1, module, exports) {
            /*!
 * Isotope v3.0.6
 *
 * Licensed GPLv3 for open source use
 * or Isotope Commercial License for commercial use
 *
 * https://isotope.metafizzy.co
 * Copyright 2010-2018 Metafizzy
 */ (function(window1, factory) {
                // universal module definition
                /* jshint strict: false */ /*globals define, module, require */ if (typeof define == "function" && define.amd) // AMD
                define([
                    "outlayer/outlayer",
                    "get-size/get-size",
                    "desandro-matches-selector/matches-selector",
                    "fizzy-ui-utils/utils",
                    "./item",
                    "./layout-mode",
                    // include default layout modes
                    "./layout-modes/masonry",
                    "./layout-modes/fit-rows",
                    "./layout-modes/vertical"
                ], function(Outlayer, getSize, matchesSelector, utils, Item, LayoutMode) {
                    return factory(window1, Outlayer, getSize, matchesSelector, utils, Item, LayoutMode);
                });
                else if (typeof module == "object" && module.exports) // CommonJS
                module.exports = factory(window1, require1("outlayer"), require1("get-size"), require1("desandro-matches-selector"), require1("fizzy-ui-utils"), require1("./item"), require1("./layout-mode"), // include default layout modes
                require1("./layout-modes/masonry"), require1("./layout-modes/fit-rows"), require1("./layout-modes/vertical"));
                else // browser global
                window1.Isotope = factory(window1, window1.Outlayer, window1.getSize, window1.matchesSelector, window1.fizzyUIUtils, window1.Isotope.Item, window1.Isotope.LayoutMode);
            })(window, function factory(window1, Outlayer, getSize, matchesSelector, utils, Item, LayoutMode) {
                "use strict";
                // -------------------------- vars -------------------------- //
                var jQuery1 = window1.jQuery;
                // -------------------------- helpers -------------------------- //
                var trim = String.prototype.trim ? function trim(str) {
                    return str.trim();
                } : function(str) {
                    return str.replace(/^\s+|\s+$/g, "");
                };
                // -------------------------- isotopeDefinition -------------------------- //
                // create an Outlayer layout class
                var Isotope = Outlayer.create("isotope", {
                    layoutMode: "masonry",
                    isJQueryFiltering: true,
                    sortAscending: true
                });
                Isotope.Item = Item;
                Isotope.LayoutMode = LayoutMode;
                var proto = Isotope.prototype;
                proto._create = function() {
                    this.itemGUID = 0;
                    // functions that sort items
                    this._sorters = {};
                    this._getSorters();
                    // call super
                    Outlayer.prototype._create.call(this);
                    // create layout modes
                    this.modes = {};
                    // start filteredItems with all items
                    this.filteredItems = this.items;
                    // keep of track of sortBys
                    this.sortHistory = [
                        "original-order"
                    ];
                    // create from registered layout modes
                    for(var name in LayoutMode.modes)this._initLayoutMode(name);
                };
                proto.reloadItems = function() {
                    // reset item ID counter
                    this.itemGUID = 0;
                    // call super
                    Outlayer.prototype.reloadItems.call(this);
                };
                proto._itemize = function() {
                    var items = Outlayer.prototype._itemize.apply(this, arguments);
                    // assign ID for original-order
                    for(var i = 0; i < items.length; i++){
                        var item = items[i];
                        item.id = this.itemGUID++;
                    }
                    this._updateItemsSortData(items);
                    return items;
                };
                // -------------------------- layout -------------------------- //
                proto._initLayoutMode = function(name) {
                    var Mode = LayoutMode.modes[name];
                    // set mode options
                    // HACK extend initial options, back-fill in default options
                    var initialOpts = this.options[name] || {};
                    this.options[name] = Mode.options ? utils.extend(Mode.options, initialOpts) : initialOpts;
                    // init layout mode instance
                    this.modes[name] = new Mode(this);
                };
                proto.layout = function() {
                    // if first time doing layout, do all magic
                    if (!this._isLayoutInited && this._getOption("initLayout")) {
                        this.arrange();
                        return;
                    }
                    this._layout();
                };
                // private method to be used in layout() & magic()
                proto._layout = function() {
                    // don't animate first layout
                    var isInstant = this._getIsInstant();
                    // layout flow
                    this._resetLayout();
                    this._manageStamps();
                    this.layoutItems(this.filteredItems, isInstant);
                    // flag for initalized
                    this._isLayoutInited = true;
                };
                // filter + sort + layout
                proto.arrange = function(opts) {
                    // set any options pass
                    this.option(opts);
                    this._getIsInstant();
                    // filter, sort, and layout
                    // filter
                    var filtered = this._filter(this.items);
                    this.filteredItems = filtered.matches;
                    this._bindArrangeComplete();
                    if (this._isInstant) this._noTransition(this._hideReveal, [
                        filtered
                    ]);
                    else this._hideReveal(filtered);
                    this._sort();
                    this._layout();
                };
                // alias to _init for main plugin method
                proto._init = proto.arrange;
                proto._hideReveal = function(filtered) {
                    this.reveal(filtered.needReveal);
                    this.hide(filtered.needHide);
                };
                // HACK
                // Don't animate/transition first layout
                // Or don't animate/transition other layouts
                proto._getIsInstant = function() {
                    var isLayoutInstant = this._getOption("layoutInstant");
                    var isInstant = isLayoutInstant !== undefined ? isLayoutInstant : !this._isLayoutInited;
                    this._isInstant = isInstant;
                    return isInstant;
                };
                // listen for layoutComplete, hideComplete and revealComplete
                // to trigger arrangeComplete
                proto._bindArrangeComplete = function() {
                    // listen for 3 events to trigger arrangeComplete
                    var isLayoutComplete, isHideComplete, isRevealComplete;
                    var _this = this;
                    function arrangeParallelCallback() {
                        if (isLayoutComplete && isHideComplete && isRevealComplete) _this.dispatchEvent("arrangeComplete", null, [
                            _this.filteredItems
                        ]);
                    }
                    this.once("layoutComplete", function() {
                        isLayoutComplete = true;
                        arrangeParallelCallback();
                    });
                    this.once("hideComplete", function() {
                        isHideComplete = true;
                        arrangeParallelCallback();
                    });
                    this.once("revealComplete", function() {
                        isRevealComplete = true;
                        arrangeParallelCallback();
                    });
                };
                // -------------------------- filter -------------------------- //
                proto._filter = function(items) {
                    var filter = this.options.filter;
                    filter = filter || "*";
                    var matches = [];
                    var hiddenMatched = [];
                    var visibleUnmatched = [];
                    var test = this._getFilterTest(filter);
                    // test each item
                    for(var i = 0; i < items.length; i++){
                        var item = items[i];
                        if (item.isIgnored) continue;
                        // add item to either matched or unmatched group
                        var isMatched = test(item);
                        // item.isFilterMatched = isMatched;
                        // add to matches if its a match
                        if (isMatched) matches.push(item);
                        // add to additional group if item needs to be hidden or revealed
                        if (isMatched && item.isHidden) hiddenMatched.push(item);
                        else if (!isMatched && !item.isHidden) visibleUnmatched.push(item);
                    }
                    // return collections of items to be manipulated
                    return {
                        matches: matches,
                        needReveal: hiddenMatched,
                        needHide: visibleUnmatched
                    };
                };
                // get a jQuery, function, or a matchesSelector test given the filter
                proto._getFilterTest = function(filter) {
                    if (jQuery1 && this.options.isJQueryFiltering) // use jQuery
                    return function(item) {
                        return jQuery1(item.element).is(filter);
                    };
                    if (typeof filter == "function") // use filter as function
                    return function(item) {
                        return filter(item.element);
                    };
                    // default, use filter as selector string
                    return function(item) {
                        return matchesSelector(item.element, filter);
                    };
                };
                // -------------------------- sorting -------------------------- //
                /**
   * @params {Array} elems
   * @public
   */ proto.updateSortData = function(elems) {
                    // get items
                    var items;
                    if (elems) {
                        elems = utils.makeArray(elems);
                        items = this.getItems(elems);
                    } else // update all items if no elems provided
                    items = this.items;
                    this._getSorters();
                    this._updateItemsSortData(items);
                };
                proto._getSorters = function() {
                    var getSortData = this.options.getSortData;
                    for(var key in getSortData){
                        var sorter = getSortData[key];
                        this._sorters[key] = mungeSorter(sorter);
                    }
                };
                /**
   * @params {Array} items - of Isotope.Items
   * @private
   */ proto._updateItemsSortData = function(items) {
                    // do not update if no items
                    var len = items && items.length;
                    for(var i = 0; len && i < len; i++){
                        var item = items[i];
                        item.updateSortData();
                    }
                };
                // ----- munge sorter ----- //
                // encapsulate this, as we just need mungeSorter
                // other functions in here are just for munging
                var mungeSorter = function() {
                    // add a magic layer to sorters for convienent shorthands
                    // `.foo-bar` will use the text of .foo-bar querySelector
                    // `[foo-bar]` will use attribute
                    // you can also add parser
                    // `.foo-bar parseInt` will parse that as a number
                    function mungeSorter(sorter) {
                        // if not a string, return function or whatever it is
                        if (typeof sorter != "string") return sorter;
                        // parse the sorter string
                        var args = trim(sorter).split(" ");
                        var query = args[0];
                        // check if query looks like [an-attribute]
                        var attrMatch = query.match(/^\[(.+)\]$/);
                        var attr = attrMatch && attrMatch[1];
                        var getValue = getValueGetter(attr, query);
                        // use second argument as a parser
                        var parser = Isotope.sortDataParsers[args[1]];
                        // parse the value, if there was a parser
                        sorter = parser ? function sorter(elem) {
                            return elem && parser(getValue(elem));
                        } : // otherwise just return value
                        function(elem) {
                            return elem && getValue(elem);
                        };
                        return sorter;
                    }
                    // get an attribute getter, or get text of the querySelector
                    function getValueGetter(attr, query) {
                        // if query looks like [foo-bar], get attribute
                        if (attr) return function getAttribute(elem) {
                            return elem.getAttribute(attr);
                        };
                        // otherwise, assume its a querySelector, and get its text
                        return function getChildText(elem) {
                            var child = elem.querySelector(query);
                            return child && child.textContent;
                        };
                    }
                    return mungeSorter;
                }();
                // parsers used in getSortData shortcut strings
                Isotope.sortDataParsers = {
                    "parseInt": function(val) {
                        return parseInt(val, 10);
                    },
                    "parseFloat": function(val) {
                        return parseFloat(val);
                    }
                };
                // ----- sort method ----- //
                // sort filteredItem order
                proto._sort = function() {
                    if (!this.options.sortBy) return;
                    // keep track of sortBy History
                    var sortBys = utils.makeArray(this.options.sortBy);
                    if (!this._getIsSameSortBy(sortBys)) // concat all sortBy and sortHistory, add to front, oldest goes in last
                    this.sortHistory = sortBys.concat(this.sortHistory);
                    // sort magic
                    var itemSorter = getItemSorter(this.sortHistory, this.options.sortAscending);
                    this.filteredItems.sort(itemSorter);
                };
                // check if sortBys is same as start of sortHistory
                proto._getIsSameSortBy = function(sortBys) {
                    for(var i = 0; i < sortBys.length; i++){
                        if (sortBys[i] != this.sortHistory[i]) return false;
                    }
                    return true;
                };
                // returns a function used for sorting
                function getItemSorter(sortBys, sortAsc) {
                    return function sorter(itemA, itemB) {
                        // cycle through all sortKeys
                        for(var i = 0; i < sortBys.length; i++){
                            var sortBy = sortBys[i];
                            var a = itemA.sortData[sortBy];
                            var b = itemB.sortData[sortBy];
                            if (a > b || a < b) {
                                // if sortAsc is an object, use the value given the sortBy key
                                var isAscending = sortAsc[sortBy] !== undefined ? sortAsc[sortBy] : sortAsc;
                                var direction = isAscending ? 1 : -1;
                                return (a > b ? 1 : -1) * direction;
                            }
                        }
                        return 0;
                    };
                }
                // -------------------------- methods -------------------------- //
                // get layout mode
                proto._mode = function() {
                    var layoutMode = this.options.layoutMode;
                    var mode = this.modes[layoutMode];
                    if (!mode) // TODO console.error
                    throw new Error("No layout mode: " + layoutMode);
                    // HACK sync mode's options
                    // any options set after init for layout mode need to be synced
                    mode.options = this.options[layoutMode];
                    return mode;
                };
                proto._resetLayout = function() {
                    // trigger original reset layout
                    Outlayer.prototype._resetLayout.call(this);
                    this._mode()._resetLayout();
                };
                proto._getItemLayoutPosition = function(item) {
                    return this._mode()._getItemLayoutPosition(item);
                };
                proto._manageStamp = function(stamp) {
                    this._mode()._manageStamp(stamp);
                };
                proto._getContainerSize = function() {
                    return this._mode()._getContainerSize();
                };
                proto.needsResizeLayout = function() {
                    return this._mode().needsResizeLayout();
                };
                // -------------------------- adding & removing -------------------------- //
                // HEADS UP overwrites default Outlayer appended
                proto.appended = function(elems) {
                    var items = this.addItems(elems);
                    if (!items.length) return;
                    // filter, layout, reveal new items
                    var filteredItems = this._filterRevealAdded(items);
                    // add to filteredItems
                    this.filteredItems = this.filteredItems.concat(filteredItems);
                };
                // HEADS UP overwrites default Outlayer prepended
                proto.prepended = function(elems) {
                    var items = this._itemize(elems);
                    if (!items.length) return;
                    // start new layout
                    this._resetLayout();
                    this._manageStamps();
                    // filter, layout, reveal new items
                    var filteredItems = this._filterRevealAdded(items);
                    // layout previous items
                    this.layoutItems(this.filteredItems);
                    // add to items and filteredItems
                    this.filteredItems = filteredItems.concat(this.filteredItems);
                    this.items = items.concat(this.items);
                };
                proto._filterRevealAdded = function(items) {
                    var filtered = this._filter(items);
                    this.hide(filtered.needHide);
                    // reveal all new items
                    this.reveal(filtered.matches);
                    // layout new items, no transition
                    this.layoutItems(filtered.matches, true);
                    return filtered.matches;
                };
                /**
   * Filter, sort, and layout newly-appended item elements
   * @param {Array or NodeList or Element} elems
   */ proto.insert = function(elems) {
                    var items = this.addItems(elems);
                    if (!items.length) return;
                    // append item elements
                    var i, item;
                    var len = items.length;
                    for(i = 0; i < len; i++){
                        item = items[i];
                        this.element.appendChild(item.element);
                    }
                    // filter new stuff
                    var filteredInsertItems = this._filter(items).matches;
                    // set flag
                    for(i = 0; i < len; i++)items[i].isLayoutInstant = true;
                    this.arrange();
                    // reset flag
                    for(i = 0; i < len; i++)delete items[i].isLayoutInstant;
                    this.reveal(filteredInsertItems);
                };
                var _remove = proto.remove;
                proto.remove = function(elems) {
                    elems = utils.makeArray(elems);
                    var removeItems = this.getItems(elems);
                    // do regular thing
                    _remove.call(this, elems);
                    // bail if no items to remove
                    var len = removeItems && removeItems.length;
                    // remove elems from filteredItems
                    for(var i = 0; len && i < len; i++){
                        var item = removeItems[i];
                        // remove item from collection
                        utils.removeFrom(this.filteredItems, item);
                    }
                };
                proto.shuffle = function() {
                    // update random sortData
                    for(var i = 0; i < this.items.length; i++){
                        var item = this.items[i];
                        item.sortData.random = Math.random();
                    }
                    this.options.sortBy = "random";
                    this._sort();
                    this._layout();
                };
                /**
   * trigger fn without transition
   * kind of hacky to have this in the first place
   * @param {Function} fn
   * @param {Array} args
   * @returns ret
   * @private
   */ proto._noTransition = function(fn, args) {
                    // save transitionDuration before disabling
                    var transitionDuration = this.options.transitionDuration;
                    // disable transition
                    this.options.transitionDuration = 0;
                    // do it
                    var returnValue = fn.apply(this, args);
                    // re-enable transition for reveal
                    this.options.transitionDuration = transitionDuration;
                    return returnValue;
                };
                // ----- helper methods ----- //
                /**
   * getter method for getting filtered item elements
   * @returns {Array} elems - collection of item elements
   */ proto.getFilteredItemElements = function() {
                    return this.filteredItems.map(function(item) {
                        return item.element;
                    });
                };
                // -----  ----- //
                return Isotope;
            });
        },
        {
            "./item": 9,
            "./layout-mode": 10,
            "./layout-modes/fit-rows": 11,
            "./layout-modes/masonry": 12,
            "./layout-modes/vertical": 13,
            "desandro-matches-selector": 3,
            "fizzy-ui-utils": 5,
            "get-size": 6,
            "outlayer": 17
        }
    ],
    9: [
        function(require1, module, exports) {
            /**
 * Isotope Item
**/ (function(window1, factory) {
                // universal module definition
                /* jshint strict: false */ /*globals define, module, require */ if (typeof define == "function" && define.amd) // AMD
                define([
                    "outlayer/outlayer"
                ], factory);
                else if (typeof module == "object" && module.exports) // CommonJS
                module.exports = factory(require1("outlayer"));
                else {
                    // browser global
                    window1.Isotope = window1.Isotope || {};
                    window1.Isotope.Item = factory(window1.Outlayer);
                }
            })(window, function factory(Outlayer) {
                "use strict";
                // -------------------------- Item -------------------------- //
                // sub-class Outlayer Item
                function Item() {
                    Outlayer.Item.apply(this, arguments);
                }
                var proto = Item.prototype = Object.create(Outlayer.Item.prototype);
                var _create = proto._create;
                proto._create = function() {
                    // assign id, used for original-order sorting
                    this.id = this.layout.itemGUID++;
                    _create.call(this);
                    this.sortData = {};
                };
                proto.updateSortData = function() {
                    if (this.isIgnored) return;
                    // default sorters
                    this.sortData.id = this.id;
                    // for backward compatibility
                    this.sortData["original-order"] = this.id;
                    this.sortData.random = Math.random();
                    // go thru getSortData obj and apply the sorters
                    var getSortData = this.layout.options.getSortData;
                    var sorters = this.layout._sorters;
                    for(var key in getSortData){
                        var sorter = sorters[key];
                        this.sortData[key] = sorter(this.element, this);
                    }
                };
                var _destroy = proto.destroy;
                proto.destroy = function() {
                    // call super
                    _destroy.apply(this, arguments);
                    // reset display, #741
                    this.css({
                        display: ""
                    });
                };
                return Item;
            });
        },
        {
            "outlayer": 17
        }
    ],
    10: [
        function(require1, module, exports) {
            /**
 * Isotope LayoutMode
 */ (function(window1, factory) {
                // universal module definition
                /* jshint strict: false */ /*globals define, module, require */ if (typeof define == "function" && define.amd) // AMD
                define([
                    "get-size/get-size",
                    "outlayer/outlayer"
                ], factory);
                else if (typeof module == "object" && module.exports) // CommonJS
                module.exports = factory(require1("get-size"), require1("outlayer"));
                else {
                    // browser global
                    window1.Isotope = window1.Isotope || {};
                    window1.Isotope.LayoutMode = factory(window1.getSize, window1.Outlayer);
                }
            })(window, function factory(getSize, Outlayer) {
                "use strict";
                // layout mode class
                function LayoutMode(isotope) {
                    this.isotope = isotope;
                    // link properties
                    if (isotope) {
                        this.options = isotope.options[this.namespace];
                        this.element = isotope.element;
                        this.items = isotope.filteredItems;
                        this.size = isotope.size;
                    }
                }
                var proto = LayoutMode.prototype;
                /**
   * some methods should just defer to default Outlayer method
   * and reference the Isotope instance as `this`
  **/ var facadeMethods = [
                    "_resetLayout",
                    "_getItemLayoutPosition",
                    "_manageStamp",
                    "_getContainerSize",
                    "_getElementOffset",
                    "needsResizeLayout",
                    "_getOption"
                ];
                facadeMethods.forEach(function(methodName) {
                    proto[methodName] = function() {
                        return Outlayer.prototype[methodName].apply(this.isotope, arguments);
                    };
                });
                // -----  ----- //
                // for horizontal layout modes, check vertical size
                proto.needsVerticalResizeLayout = function() {
                    // don't trigger if size did not change
                    var size = getSize(this.isotope.element);
                    // check that this.size and size are there
                    // IE8 triggers resize on body size change, so they might not be
                    var hasSizes = this.isotope.size && size;
                    return hasSizes && size.innerHeight != this.isotope.size.innerHeight;
                };
                // ----- measurements ----- //
                proto._getMeasurement = function() {
                    this.isotope._getMeasurement.apply(this, arguments);
                };
                proto.getColumnWidth = function() {
                    this.getSegmentSize("column", "Width");
                };
                proto.getRowHeight = function() {
                    this.getSegmentSize("row", "Height");
                };
                /**
   * get columnWidth or rowHeight
   * segment: 'column' or 'row'
   * size 'Width' or 'Height'
  **/ proto.getSegmentSize = function(segment, size) {
                    var segmentName = segment + size;
                    var outerSize = "outer" + size;
                    // columnWidth / outerWidth // rowHeight / outerHeight
                    this._getMeasurement(segmentName, outerSize);
                    // got rowHeight or columnWidth, we can chill
                    if (this[segmentName]) return;
                    // fall back to item of first element
                    var firstItemSize = this.getFirstItemSize();
                    this[segmentName] = firstItemSize && firstItemSize[outerSize] || // or size of container
                    this.isotope.size["inner" + size];
                };
                proto.getFirstItemSize = function() {
                    var firstItem = this.isotope.filteredItems[0];
                    return firstItem && firstItem.element && getSize(firstItem.element);
                };
                // ----- methods that should reference isotope ----- //
                proto.layout = function() {
                    this.isotope.layout.apply(this.isotope, arguments);
                };
                proto.getSize = function() {
                    this.isotope.getSize();
                    this.size = this.isotope.size;
                };
                // -------------------------- create -------------------------- //
                LayoutMode.modes = {};
                LayoutMode.create = function(namespace, options) {
                    function Mode() {
                        LayoutMode.apply(this, arguments);
                    }
                    Mode.prototype = Object.create(proto);
                    Mode.prototype.constructor = Mode;
                    // default options
                    if (options) Mode.options = options;
                    Mode.prototype.namespace = namespace;
                    // register in Isotope
                    LayoutMode.modes[namespace] = Mode;
                    return Mode;
                };
                return LayoutMode;
            });
        },
        {
            "get-size": 6,
            "outlayer": 17
        }
    ],
    11: [
        function(require1, module, exports) {
            /**
 * fitRows layout mode
 */ (function(window1, factory) {
                // universal module definition
                /* jshint strict: false */ /*globals define, module, require */ if (typeof define == "function" && define.amd) // AMD
                define([
                    "../layout-mode"
                ], factory);
                else if (typeof exports == "object") // CommonJS
                module.exports = factory(require1("../layout-mode"));
                else // browser global
                factory(window1.Isotope.LayoutMode);
            })(window, function factory(LayoutMode) {
                "use strict";
                var FitRows = LayoutMode.create("fitRows");
                var proto = FitRows.prototype;
                proto._resetLayout = function() {
                    this.x = 0;
                    this.y = 0;
                    this.maxY = 0;
                    this._getMeasurement("gutter", "outerWidth");
                };
                proto._getItemLayoutPosition = function(item) {
                    item.getSize();
                    var itemWidth = item.size.outerWidth + this.gutter;
                    // if this element cannot fit in the current row
                    var containerWidth = this.isotope.size.innerWidth + this.gutter;
                    if (this.x !== 0 && itemWidth + this.x > containerWidth) {
                        this.x = 0;
                        this.y = this.maxY;
                    }
                    var position = {
                        x: this.x,
                        y: this.y
                    };
                    this.maxY = Math.max(this.maxY, this.y + item.size.outerHeight);
                    this.x += itemWidth;
                    return position;
                };
                proto._getContainerSize = function() {
                    return {
                        height: this.maxY
                    };
                };
                return FitRows;
            });
        },
        {
            "../layout-mode": 10
        }
    ],
    12: [
        function(require1, module, exports) {
            /*!
 * Masonry layout mode
 * sub-classes Masonry
 * https://masonry.desandro.com
 */ (function(window1, factory) {
                // universal module definition
                /* jshint strict: false */ /*globals define, module, require */ if (typeof define == "function" && define.amd) // AMD
                define([
                    "../layout-mode",
                    "masonry-layout/masonry"
                ], factory);
                else if (typeof module == "object" && module.exports) // CommonJS
                module.exports = factory(require1("../layout-mode"), require1("masonry-layout"));
                else // browser global
                factory(window1.Isotope.LayoutMode, window1.Masonry);
            })(window, function factory(LayoutMode, Masonry) {
                "use strict";
                // -------------------------- masonryDefinition -------------------------- //
                // create an Outlayer layout class
                var MasonryMode = LayoutMode.create("masonry");
                var proto = MasonryMode.prototype;
                var keepModeMethods = {
                    _getElementOffset: true,
                    layout: true,
                    _getMeasurement: true
                };
                // inherit Masonry prototype
                for(var method in Masonry.prototype)// do not inherit mode methods
                if (!keepModeMethods[method]) proto[method] = Masonry.prototype[method];
                var measureColumns = proto.measureColumns;
                proto.measureColumns = function() {
                    // set items, used if measuring first item
                    this.items = this.isotope.filteredItems;
                    measureColumns.call(this);
                };
                // point to mode options for fitWidth
                var _getOption = proto._getOption;
                proto._getOption = function(option) {
                    if (option == "fitWidth") return this.options.isFitWidth !== undefined ? this.options.isFitWidth : this.options.fitWidth;
                    return _getOption.apply(this.isotope, arguments);
                };
                return MasonryMode;
            });
        },
        {
            "../layout-mode": 10,
            "masonry-layout": 15
        }
    ],
    13: [
        function(require1, module, exports) {
            /**
 * vertical layout mode
 */ (function(window1, factory) {
                // universal module definition
                /* jshint strict: false */ /*globals define, module, require */ if (typeof define == "function" && define.amd) // AMD
                define([
                    "../layout-mode"
                ], factory);
                else if (typeof module == "object" && module.exports) // CommonJS
                module.exports = factory(require1("../layout-mode"));
                else // browser global
                factory(window1.Isotope.LayoutMode);
            })(window, function factory(LayoutMode) {
                "use strict";
                var Vertical = LayoutMode.create("vertical", {
                    horizontalAlignment: 0
                });
                var proto = Vertical.prototype;
                proto._resetLayout = function() {
                    this.y = 0;
                };
                proto._getItemLayoutPosition = function(item) {
                    item.getSize();
                    var x = (this.isotope.size.innerWidth - item.size.outerWidth) * this.options.horizontalAlignment;
                    var y = this.y;
                    this.y += item.size.outerHeight;
                    return {
                        x: x,
                        y: y
                    };
                };
                proto._getContainerSize = function() {
                    return {
                        height: this.y
                    };
                };
                return Vertical;
            });
        },
        {
            "../layout-mode": 10
        }
    ],
    14: [
        function(require1, module, exports) {
            /*!
 * jQuery JavaScript Library v3.7.1
 * https://jquery.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2023-08-28T13:37Z
 */ (function(global, factory) {
                "use strict";
                if (typeof module === "object" && typeof module.exports === "object") // For CommonJS and CommonJS-like environments where a proper `window`
                // is present, execute the factory and get jQuery.
                // For environments that do not have a `window` with a `document`
                // (such as Node.js), expose a factory as module.exports.
                // This accentuates the need for the creation of a real `window`.
                // e.g. var jQuery = require("jquery")(window);
                // See ticket trac-14549 for more info.
                module.exports = global.document ? factory(global, true) : function(w) {
                    if (!w.document) throw new Error("jQuery requires a window with a document");
                    return factory(w);
                };
                else factory(global);
            // Pass this if window is not defined yet
            })(typeof window !== "undefined" ? window : this, function(window1, noGlobal) {
                // Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
                // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
                // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
                // enough that all such attempts are guarded in a try block.
                "use strict";
                var arr = [];
                var getProto = Object.getPrototypeOf;
                var slice = arr.slice;
                var flat = arr.flat ? function flat(array) {
                    return arr.flat.call(array);
                } : function(array) {
                    return arr.concat.apply([], array);
                };
                var push = arr.push;
                var indexOf = arr.indexOf;
                var class2type = {};
                var toString = class2type.toString;
                var hasOwn = class2type.hasOwnProperty;
                var fnToString = hasOwn.toString;
                var ObjectFunctionString = fnToString.call(Object);
                var support = {};
                var isFunction = function isFunction(obj) {
                    // Support: Chrome <=57, Firefox <=52
                    // In some browsers, typeof returns "function" for HTML <object> elements
                    // (i.e., `typeof document.createElement( "object" ) === "function"`).
                    // We don't want to classify *any* DOM node as a function.
                    // Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
                    // Plus for old WebKit, typeof returns "function" for HTML collections
                    // (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
                    return typeof obj === "function" && typeof obj.nodeType !== "number" && typeof obj.item !== "function";
                };
                var isWindow = function isWindow(obj) {
                    return obj != null && obj === obj.window;
                };
                var document1 = window1.document;
                var preservedScriptAttributes = {
                    type: true,
                    src: true,
                    nonce: true,
                    noModule: true
                };
                function DOMEval(code, node, doc) {
                    doc = doc || document1;
                    var i, val, script = doc.createElement("script");
                    script.text = code;
                    if (node) for(i in preservedScriptAttributes){
                        // Support: Firefox 64+, Edge 18+
                        // Some browsers don't support the "nonce" property on scripts.
                        // On the other hand, just using `getAttribute` is not enough as
                        // the `nonce` attribute is reset to an empty string whenever it
                        // becomes browsing-context connected.
                        // See https://github.com/whatwg/html/issues/2369
                        // See https://html.spec.whatwg.org/#nonce-attributes
                        // The `node.getAttribute` check was added for the sake of
                        // `jQuery.globalEval` so that it can fake a nonce-containing node
                        // via an object.
                        val = node[i] || node.getAttribute && node.getAttribute(i);
                        if (val) script.setAttribute(i, val);
                    }
                    doc.head.appendChild(script).parentNode.removeChild(script);
                }
                function toType(obj) {
                    if (obj == null) return obj + "";
                    // Support: Android <=2.3 only (functionish RegExp)
                    return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj === "undefined" ? "undefined" : (0, _typeOf._)(obj);
                }
                /* global Symbol */ // Defining this global in .eslintrc.json would create a danger of using the global
                // unguarded in another place, it seems safer to define global only for this module
                var version = "3.7.1", rhtmlSuffix = /HTML$/i, // Define a local copy of jQuery
                jQuery1 = function jQuery2(selector, context) {
                    // The jQuery object is actually just the init constructor 'enhanced'
                    // Need init if jQuery is called (just allow error to be thrown if not included)
                    return new jQuery1.fn.init(selector, context);
                };
                jQuery1.fn = jQuery1.prototype = {
                    // The current version of jQuery being used
                    jquery: version,
                    constructor: jQuery1,
                    // The default length of a jQuery object is 0
                    length: 0,
                    toArray: function toArray() {
                        return slice.call(this);
                    },
                    // Get the Nth element in the matched element set OR
                    // Get the whole matched element set as a clean array
                    get: function get(num) {
                        // Return all the elements in a clean array
                        if (num == null) return slice.call(this);
                        // Return just the one element from the set
                        return num < 0 ? this[num + this.length] : this[num];
                    },
                    // Take an array of elements and push it onto the stack
                    // (returning the new matched element set)
                    pushStack: function pushStack(elems) {
                        // Build a new jQuery matched element set
                        var ret = jQuery1.merge(this.constructor(), elems);
                        // Add the old object onto the stack (as a reference)
                        ret.prevObject = this;
                        // Return the newly-formed element set
                        return ret;
                    },
                    // Execute a callback for every element in the matched set.
                    each: function each(callback) {
                        return jQuery1.each(this, callback);
                    },
                    map: function map(callback) {
                        return this.pushStack(jQuery1.map(this, function(elem, i) {
                            return callback.call(elem, i, elem);
                        }));
                    },
                    slice: function slice1() {
                        return this.pushStack(slice.apply(this, arguments));
                    },
                    first: function first() {
                        return this.eq(0);
                    },
                    last: function last() {
                        return this.eq(-1);
                    },
                    even: function even() {
                        return this.pushStack(jQuery1.grep(this, function(_elem, i) {
                            return (i + 1) % 2;
                        }));
                    },
                    odd: function odd() {
                        return this.pushStack(jQuery1.grep(this, function(_elem, i) {
                            return i % 2;
                        }));
                    },
                    eq: function eq(i) {
                        var len = this.length, j = +i + (i < 0 ? len : 0);
                        return this.pushStack(j >= 0 && j < len ? [
                            this[j]
                        ] : []);
                    },
                    end: function end() {
                        return this.prevObject || this.constructor();
                    },
                    // For internal use only.
                    // Behaves like an Array's method, not like a jQuery method.
                    push: push,
                    sort: arr.sort,
                    splice: arr.splice
                };
                jQuery1.extend = jQuery1.fn.extend = function() {
                    var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
                    // Handle a deep copy situation
                    if (typeof target === "boolean") {
                        deep = target;
                        // Skip the boolean and the target
                        target = arguments[i] || {};
                        i++;
                    }
                    // Handle case when target is a string or something (possible in deep copy)
                    if (typeof target !== "object" && !isFunction(target)) target = {};
                    // Extend jQuery itself if only one argument is passed
                    if (i === length) {
                        target = this;
                        i--;
                    }
                    for(; i < length; i++){
                        // Only deal with non-null/undefined values
                        if ((options = arguments[i]) != null) // Extend the base object
                        for(name in options){
                            copy = options[name];
                            // Prevent Object.prototype pollution
                            // Prevent never-ending loop
                            if (name === "__proto__" || target === copy) continue;
                            // Recurse if we're merging plain objects or arrays
                            if (deep && copy && (jQuery1.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
                                src = target[name];
                                // Ensure proper type for the source value
                                if (copyIsArray && !Array.isArray(src)) clone = [];
                                else if (!copyIsArray && !jQuery1.isPlainObject(src)) clone = {};
                                else clone = src;
                                copyIsArray = false;
                                // Never move original objects, clone them
                                target[name] = jQuery1.extend(deep, clone, copy);
                            // Don't bring in undefined values
                            } else if (copy !== undefined) target[name] = copy;
                        }
                    }
                    // Return the modified object
                    return target;
                };
                jQuery1.extend({
                    // Unique for each copy of jQuery on the page
                    expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
                    // Assume jQuery is ready without the ready module
                    isReady: true,
                    error: function error(msg) {
                        throw new Error(msg);
                    },
                    noop: function noop() {},
                    isPlainObject: function isPlainObject(obj) {
                        var proto, Ctor;
                        // Detect obvious negatives
                        // Use toString instead of jQuery.type to catch host objects
                        if (!obj || toString.call(obj) !== "[object Object]") return false;
                        proto = getProto(obj);
                        // Objects with no prototype (e.g., `Object.create( null )`) are plain
                        if (!proto) return true;
                        // Objects with prototype are plain iff they were constructed by a global Object function
                        Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
                        return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
                    },
                    isEmptyObject: function isEmptyObject(obj) {
                        var name;
                        for(name in obj)return false;
                        return true;
                    },
                    // Evaluates a script in a provided context; falls back to the global one
                    // if not specified.
                    globalEval: function globalEval(code, options, doc) {
                        DOMEval(code, {
                            nonce: options && options.nonce
                        }, doc);
                    },
                    each: function each(obj, callback) {
                        var length, i = 0;
                        if (isArrayLike(obj)) {
                            length = obj.length;
                            for(; i < length; i++){
                                if (callback.call(obj[i], i, obj[i]) === false) break;
                            }
                        } else for(i in obj){
                            if (callback.call(obj[i], i, obj[i]) === false) break;
                        }
                        return obj;
                    },
                    // Retrieve the text value of an array of DOM nodes
                    text: function text(elem) {
                        var node, ret = "", i = 0, nodeType = elem.nodeType;
                        if (!nodeType) // If no nodeType, this is expected to be an array
                        while(node = elem[i++])// Do not traverse comment nodes
                        ret += jQuery1.text(node);
                        if (nodeType === 1 || nodeType === 11) return elem.textContent;
                        if (nodeType === 9) return elem.documentElement.textContent;
                        if (nodeType === 3 || nodeType === 4) return elem.nodeValue;
                        // Do not include comment or processing instruction nodes
                        return ret;
                    },
                    // results is for internal usage only
                    makeArray: function makeArray(arr, results) {
                        var ret = results || [];
                        if (arr != null) {
                            if (isArrayLike(Object(arr))) jQuery1.merge(ret, typeof arr === "string" ? [
                                arr
                            ] : arr);
                            else push.call(ret, arr);
                        }
                        return ret;
                    },
                    inArray: function inArray(elem, arr, i) {
                        return arr == null ? -1 : indexOf.call(arr, elem, i);
                    },
                    isXMLDoc: function isXMLDoc(elem) {
                        var namespace = elem && elem.namespaceURI, docElem = elem && (elem.ownerDocument || elem).documentElement;
                        // Assume HTML when documentElement doesn't yet exist, such as inside
                        // document fragments.
                        return !rhtmlSuffix.test(namespace || docElem && docElem.nodeName || "HTML");
                    },
                    // Support: Android <=4.0 only, PhantomJS 1 only
                    // push.apply(_, arraylike) throws on ancient WebKit
                    merge: function merge(first, second) {
                        var len = +second.length, j = 0, i = first.length;
                        for(; j < len; j++)first[i++] = second[j];
                        first.length = i;
                        return first;
                    },
                    grep: function grep(elems, callback, invert) {
                        var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;
                        // Go through the array, only saving the items
                        // that pass the validator function
                        for(; i < length; i++){
                            callbackInverse = !callback(elems[i], i);
                            if (callbackInverse !== callbackExpect) matches.push(elems[i]);
                        }
                        return matches;
                    },
                    // arg is for internal usage only
                    map: function map(elems, callback, arg) {
                        var length, value, i = 0, ret = [];
                        // Go through the array, translating each of the items to their new values
                        if (isArrayLike(elems)) {
                            length = elems.length;
                            for(; i < length; i++){
                                value = callback(elems[i], i, arg);
                                if (value != null) ret.push(value);
                            }
                        // Go through every key on the object,
                        } else for(i in elems){
                            value = callback(elems[i], i, arg);
                            if (value != null) ret.push(value);
                        }
                        // Flatten any nested arrays
                        return flat(ret);
                    },
                    // A global GUID counter for objects
                    guid: 1,
                    // jQuery.support is not used in Core but other projects attach their
                    // properties to it so it needs to exist.
                    support: support
                });
                if (typeof Symbol === "function") jQuery1.fn[Symbol.iterator] = arr[Symbol.iterator];
                // Populate the class2type map
                jQuery1.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(_i, name) {
                    class2type["[object " + name + "]"] = name.toLowerCase();
                });
                function isArrayLike(obj) {
                    // Support: real iOS 8.2 only (not reproducible in simulator)
                    // `in` check used to prevent JIT error (gh-2145)
                    // hasOwn isn't used here due to false negatives
                    // regarding Nodelist length in IE
                    var length = !!obj && "length" in obj && obj.length, type = toType(obj);
                    if (isFunction(obj) || isWindow(obj)) return false;
                    return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
                }
                function nodeName(elem, name) {
                    return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
                }
                var pop = arr.pop;
                var sort = arr.sort;
                var splice = arr.splice;
                var whitespace = "[\\x20\\t\\r\\n\\f]";
                var rtrimCSS = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g");
                // Note: an element does not contain itself
                jQuery1.contains = function(a, b) {
                    var bup = b && b.parentNode;
                    return a === bup || !!(bup && bup.nodeType === 1 && // Support: IE 9 - 11+
                    // IE doesn't have `contains` on SVG.
                    (a.contains ? a.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
                };
                // CSS string/identifier serialization
                // https://drafts.csswg.org/cssom/#common-serializing-idioms
                var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;
                function fcssescape(ch, asCodePoint) {
                    if (asCodePoint) {
                        // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
                        if (ch === "\0") return "\uFFFD";
                        // Control characters and (dependent upon position) numbers get escaped as code points
                        return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
                    }
                    // Other potentially-special ASCII characters get backslash-escaped
                    return "\\" + ch;
                }
                jQuery1.escapeSelector = function(sel) {
                    return (sel + "").replace(rcssescape, fcssescape);
                };
                var preferredDoc = document1, pushNative = push;
                (function() {
                    var i, Expr, outermostContext, sortInput, hasDuplicate, push = pushNative, // Local document vars
                    document1, documentElement, documentIsHTML, rbuggyQSA, matches, // Instance-specific data
                    expando = jQuery1.expando, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), nonnativeSelectorCache = createCache(), sortOrder = function sortOrder(a, b) {
                        if (a === b) hasDuplicate = true;
                        return 0;
                    }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", // Regular expressions
                    // https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
                    identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", // Attribute selectors: https://www.w3.org/TR/selectors/#attribute-selectors
                    attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + // Operator (capture 2)
                    "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
                    "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + identifier + ")(?:\\((" + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
                    // 1. quoted (capture 3; capture 4 or capture 5)
                    "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + // 2. simple (capture 6)
                    "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + // 3. anything else (capture 2)
                    ".*" + ")\\)|)", // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
                    rwhitespace = new RegExp(whitespace + "+", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rleadingCombinator = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rdescend = new RegExp(whitespace + "|>"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
                        ID: new RegExp("^#(" + identifier + ")"),
                        CLASS: new RegExp("^\\.(" + identifier + ")"),
                        TAG: new RegExp("^(" + identifier + "|[*])"),
                        ATTR: new RegExp("^" + attributes),
                        PSEUDO: new RegExp("^" + pseudos),
                        CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
                        bool: new RegExp("^(?:" + booleans + ")$", "i"),
                        // For use in libraries implementing .is()
                        // We use this for POS matching in `select`
                        needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
                    }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, // Easily-parseable/retrievable ID or TAG or CLASS selectors
                    rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, // CSS escapes
                    // https://www.w3.org/TR/CSS21/syndata.html#escaped-characters
                    runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g"), funescape = function funescape(escape, nonHex) {
                        var high = "0x" + escape.slice(1) - 0x10000;
                        if (nonHex) // Strip the backslash prefix from a non-hex escape sequence
                        return nonHex;
                        // Replace a hexadecimal escape sequence with the encoded Unicode code point
                        // Support: IE <=11+
                        // For values outside the Basic Multilingual Plane (BMP), manually construct a
                        // surrogate pair
                        return high < 0 ? String.fromCharCode(high + 0x10000) : String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
                    }, // Used for iframes; see `setDocument`.
                    // Support: IE 9 - 11+, Edge 12 - 18+
                    // Removing the function wrapper causes a "Permission Denied"
                    // error in IE/Edge.
                    unloadHandler = function unloadHandler() {
                        setDocument();
                    }, inDisabledFieldset = addCombinator(function(elem) {
                        return elem.disabled === true && nodeName(elem, "fieldset");
                    }, {
                        dir: "parentNode",
                        next: "legend"
                    });
                    // Support: IE <=9 only
                    // Accessing document.activeElement can throw unexpectedly
                    // https://bugs.jquery.com/ticket/13393
                    function safeActiveElement() {
                        try {
                            return document1.activeElement;
                        } catch (err) {}
                    }
                    // Optimize for push.apply( _, NodeList )
                    try {
                        push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
                        // Support: Android <=4.0
                        // Detect silently failing push.apply
                        // eslint-disable-next-line no-unused-expressions
                        arr[preferredDoc.childNodes.length].nodeType;
                    } catch (e) {
                        push = {
                            apply: function apply(target, els) {
                                pushNative.apply(target, slice.call(els));
                            },
                            call: function call(target) {
                                pushNative.apply(target, slice.call(arguments, 1));
                            }
                        };
                    }
                    function find(selector, context, results, seed) {
                        var m, i, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, // nodeType defaults to 9, since context defaults to document
                        nodeType = context ? context.nodeType : 9;
                        results = results || [];
                        // Return early from calls with invalid selector or context
                        if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) return results;
                        // Try to shortcut find operations (as opposed to filters) in HTML documents
                        if (!seed) {
                            setDocument(context);
                            context = context || document1;
                            if (documentIsHTML) {
                                // If the selector is sufficiently simple, try using a "get*By*" DOM method
                                // (excepting DocumentFragment context, where the methods don't exist)
                                if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
                                    // ID selector
                                    if (m = match[1]) {
                                        // Document context
                                        if (nodeType === 9) {
                                            if (elem = context.getElementById(m)) // Support: IE 9 only
                                            // getElementById can match elements by name instead of ID
                                            {
                                                if (elem.id === m) {
                                                    push.call(results, elem);
                                                    return results;
                                                }
                                            } else return results;
                                        // Element context
                                        } else // Support: IE 9 only
                                        // getElementById can match elements by name instead of ID
                                        if (newContext && (elem = newContext.getElementById(m)) && find.contains(context, elem) && elem.id === m) {
                                            push.call(results, elem);
                                            return results;
                                        }
                                    // Type selector
                                    } else if (match[2]) {
                                        push.apply(results, context.getElementsByTagName(selector));
                                        return results;
                                    // Class selector
                                    } else if ((m = match[3]) && context.getElementsByClassName) {
                                        push.apply(results, context.getElementsByClassName(m));
                                        return results;
                                    }
                                }
                                // Take advantage of querySelectorAll
                                if (!nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                                    newSelector = selector;
                                    newContext = context;
                                    // qSA considers elements outside a scoping root when evaluating child or
                                    // descendant combinators, which is not what we want.
                                    // In such cases, we work around the behavior by prefixing every selector in the
                                    // list with an ID selector referencing the scope context.
                                    // The technique has to be used as well when a leading combinator is used
                                    // as such selectors are not recognized by querySelectorAll.
                                    // Thanks to Andrew Dupont for this technique.
                                    if (nodeType === 1 && (rdescend.test(selector) || rleadingCombinator.test(selector))) {
                                        // Expand context for sibling selectors
                                        newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                                        // We can use :scope instead of the ID hack if the browser
                                        // supports it & if we're not changing the context.
                                        // Support: IE 11+, Edge 17 - 18+
                                        // IE/Edge sometimes throw a "Permission denied" error when
                                        // strict-comparing two documents; shallow comparisons work.
                                        // eslint-disable-next-line eqeqeq
                                        if (newContext != context || !support.scope) {
                                            // Capture the context ID, setting it first if necessary
                                            if (nid = context.getAttribute("id")) nid = jQuery1.escapeSelector(nid);
                                            else context.setAttribute("id", nid = expando);
                                        }
                                        // Prefix every selector in the list
                                        groups = tokenize(selector);
                                        i = groups.length;
                                        while(i--)groups[i] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i]);
                                        newSelector = groups.join(",");
                                    }
                                    try {
                                        push.apply(results, newContext.querySelectorAll(newSelector));
                                        return results;
                                    } catch (qsaError) {
                                        nonnativeSelectorCache(selector, true);
                                    } finally{
                                        if (nid === expando) context.removeAttribute("id");
                                    }
                                }
                            }
                        }
                        // All others
                        return select(selector.replace(rtrimCSS, "$1"), context, results, seed);
                    }
                    /**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */ function createCache() {
                        var keys = [];
                        function cache(key, value) {
                            // Use (key + " ") to avoid collision with native prototype properties
                            // (see https://github.com/jquery/sizzle/issues/157)
                            if (keys.push(key + " ") > Expr.cacheLength) // Only keep the most recent entries
                            delete cache[keys.shift()];
                            return cache[key + " "] = value;
                        }
                        return cache;
                    }
                    /**
 * Mark a function for special use by jQuery selector module
 * @param {Function} fn The function to mark
 */ function markFunction(fn) {
                        fn[expando] = true;
                        return fn;
                    }
                    /**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */ function assert(fn) {
                        var el = document1.createElement("fieldset");
                        try {
                            return !!fn(el);
                        } catch (e) {
                            return false;
                        } finally{
                            // Remove from its parent by default
                            if (el.parentNode) el.parentNode.removeChild(el);
                            // release memory in IE
                            el = null;
                        }
                    }
                    /**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */ function createInputPseudo(type) {
                        return function(elem) {
                            return nodeName(elem, "input") && elem.type === type;
                        };
                    }
                    /**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */ function createButtonPseudo(type) {
                        return function(elem) {
                            return (nodeName(elem, "input") || nodeName(elem, "button")) && elem.type === type;
                        };
                    }
                    /**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */ function createDisabledPseudo(disabled) {
                        // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
                        return function(elem) {
                            // Only certain elements can match :enabled or :disabled
                            // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
                            // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
                            if ("form" in elem) {
                                // Check for inherited disabledness on relevant non-disabled elements:
                                // * listed form-associated elements in a disabled fieldset
                                //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
                                //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
                                // * option elements in a disabled optgroup
                                //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
                                // All such elements have a "form" property.
                                if (elem.parentNode && elem.disabled === false) {
                                    // Option elements defer to a parent optgroup if present
                                    if ("label" in elem) {
                                        if ("label" in elem.parentNode) return elem.parentNode.disabled === disabled;
                                        else return elem.disabled === disabled;
                                    }
                                    // Support: IE 6 - 11+
                                    // Use the isDisabled shortcut property to check for disabled fieldset ancestors
                                    return elem.isDisabled === disabled || // Where there is no isDisabled, check manually
                                    elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
                                }
                                return elem.disabled === disabled;
                            // Try to winnow out elements that can't be disabled before trusting the disabled property.
                            // Some victims get caught in our net (label, legend, menu, track), but it shouldn't
                            // even exist on them, let alone have a boolean value.
                            } else if ("label" in elem) return elem.disabled === disabled;
                            // Remaining elements are neither :enabled nor :disabled
                            return false;
                        };
                    }
                    /**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */ function createPositionalPseudo(fn) {
                        return markFunction(function(argument) {
                            argument = +argument;
                            return markFunction(function(seed, matches) {
                                var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
                                // Match elements found at the specified indexes
                                while(i--)if (seed[j = matchIndexes[i]]) seed[j] = !(matches[j] = seed[j]);
                            });
                        });
                    }
                    /**
 * Checks a node for validity as a jQuery selector context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */ function testContext(context) {
                        return context && typeof context.getElementsByTagName !== "undefined" && context;
                    }
                    /**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [node] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */ function setDocument(node) {
                        var subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
                        // Return early if doc is invalid or already selected
                        // Support: IE 11+, Edge 17 - 18+
                        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                        // two documents; shallow comparisons work.
                        // eslint-disable-next-line eqeqeq
                        if (doc == document1 || doc.nodeType !== 9 || !doc.documentElement) return document1;
                        // Update global variables
                        document1 = doc;
                        documentElement = document1.documentElement;
                        documentIsHTML = !jQuery1.isXMLDoc(document1);
                        // Support: iOS 7 only, IE 9 - 11+
                        // Older browsers didn't support unprefixed `matches`.
                        matches = documentElement.matches || documentElement.webkitMatchesSelector || documentElement.msMatchesSelector;
                        // Support: IE 9 - 11+, Edge 12 - 18+
                        // Accessing iframe documents after unload throws "permission denied" errors
                        // (see trac-13936).
                        // Limit the fix to IE & Edge Legacy; despite Edge 15+ implementing `matches`,
                        // all IE 9+ and Edge Legacy versions implement `msMatchesSelector` as well.
                        if (documentElement.msMatchesSelector && // Support: IE 11+, Edge 17 - 18+
                        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                        // two documents; shallow comparisons work.
                        // eslint-disable-next-line eqeqeq
                        preferredDoc != document1 && (subWindow = document1.defaultView) && subWindow.top !== subWindow) // Support: IE 9 - 11+, Edge 12 - 18+
                        subWindow.addEventListener("unload", unloadHandler);
                        // Support: IE <10
                        // Check if getElementById returns elements by name
                        // The broken getElementById methods don't pick up programmatically-set names,
                        // so use a roundabout getElementsByName test
                        support.getById = assert(function(el) {
                            documentElement.appendChild(el).id = jQuery1.expando;
                            return !document1.getElementsByName || !document1.getElementsByName(jQuery1.expando).length;
                        });
                        // Support: IE 9 only
                        // Check to see if it's possible to do matchesSelector
                        // on a disconnected node.
                        support.disconnectedMatch = assert(function(el) {
                            return matches.call(el, "*");
                        });
                        // Support: IE 9 - 11+, Edge 12 - 18+
                        // IE/Edge don't support the :scope pseudo-class.
                        support.scope = assert(function() {
                            return document1.querySelectorAll(":scope");
                        });
                        // Support: Chrome 105 - 111 only, Safari 15.4 - 16.3 only
                        // Make sure the `:has()` argument is parsed unforgivingly.
                        // We include `*` in the test to detect buggy implementations that are
                        // _selectively_ forgiving (specifically when the list includes at least
                        // one valid selector).
                        // Note that we treat complete lack of support for `:has()` as if it were
                        // spec-compliant support, which is fine because use of `:has()` in such
                        // environments will fail in the qSA path and fall back to jQuery traversal
                        // anyway.
                        support.cssHas = assert(function() {
                            try {
                                document1.querySelector(":has(*,:jqfake)");
                                return false;
                            } catch (e) {
                                return true;
                            }
                        });
                        // ID filter and find
                        if (support.getById) {
                            Expr.filter.ID = function(id) {
                                var attrId = id.replace(runescape, funescape);
                                return function(elem) {
                                    return elem.getAttribute("id") === attrId;
                                };
                            };
                            Expr.find.ID = function(id, context) {
                                if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                                    var elem = context.getElementById(id);
                                    return elem ? [
                                        elem
                                    ] : [];
                                }
                            };
                        } else {
                            Expr.filter.ID = function(id) {
                                var attrId = id.replace(runescape, funescape);
                                return function(elem) {
                                    var _$node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                                    return _$node && _$node.value === attrId;
                                };
                            };
                            // Support: IE 6 - 7 only
                            // getElementById is not reliable as a find shortcut
                            Expr.find.ID = function(id, context) {
                                if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                                    var _$node, i, elems, elem = context.getElementById(id);
                                    if (elem) {
                                        // Verify the id attribute
                                        _$node = elem.getAttributeNode("id");
                                        if (_$node && _$node.value === id) return [
                                            elem
                                        ];
                                        // Fall back on getElementsByName
                                        elems = context.getElementsByName(id);
                                        i = 0;
                                        while(elem = elems[i++]){
                                            _$node = elem.getAttributeNode("id");
                                            if (_$node && _$node.value === id) return [
                                                elem
                                            ];
                                        }
                                    }
                                    return [];
                                }
                            };
                        }
                        // Tag
                        Expr.find.TAG = function(tag, context) {
                            if (typeof context.getElementsByTagName !== "undefined") return context.getElementsByTagName(tag);
                            else return context.querySelectorAll(tag);
                        };
                        // Class
                        Expr.find.CLASS = function(className, context) {
                            if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) return context.getElementsByClassName(className);
                        };
                        /* QSA/matchesSelector
	---------------------------------------------------------------------- */ // QSA and matchesSelector support
                        rbuggyQSA = [];
                        // Build QSA regex
                        // Regex strategy adopted from Diego Perini
                        assert(function(el) {
                            var input;
                            documentElement.appendChild(el).innerHTML = "<a id='" + expando + "' href='' disabled='disabled'></a>" + "<select id='" + expando + "-\r\\' disabled='disabled'>" + "<option selected=''></option></select>";
                            // Support: iOS <=7 - 8 only
                            // Boolean attributes and "value" are not treated correctly in some XML documents
                            if (!el.querySelectorAll("[selected]").length) rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
                            // Support: iOS <=7 - 8 only
                            if (!el.querySelectorAll("[id~=" + expando + "-]").length) rbuggyQSA.push("~=");
                            // Support: iOS 8 only
                            // https://bugs.webkit.org/show_bug.cgi?id=136851
                            // In-page `selector#id sibling-combinator selector` fails
                            if (!el.querySelectorAll("a#" + expando + "+*").length) rbuggyQSA.push(".#.+[+~]");
                            // Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
                            // In some of the document kinds, these selectors wouldn't work natively.
                            // This is probably OK but for backwards compatibility we want to maintain
                            // handling them through jQuery traversal in jQuery 3.x.
                            if (!el.querySelectorAll(":checked").length) rbuggyQSA.push(":checked");
                            // Support: Windows 8 Native Apps
                            // The type and name attributes are restricted during .innerHTML assignment
                            input = document1.createElement("input");
                            input.setAttribute("type", "hidden");
                            el.appendChild(input).setAttribute("name", "D");
                            // Support: IE 9 - 11+
                            // IE's :disabled selector does not pick up the children of disabled fieldsets
                            // Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
                            // In some of the document kinds, these selectors wouldn't work natively.
                            // This is probably OK but for backwards compatibility we want to maintain
                            // handling them through jQuery traversal in jQuery 3.x.
                            documentElement.appendChild(el).disabled = true;
                            if (el.querySelectorAll(":disabled").length !== 2) rbuggyQSA.push(":enabled", ":disabled");
                            // Support: IE 11+, Edge 15 - 18+
                            // IE 11/Edge don't find elements on a `[name='']` query in some cases.
                            // Adding a temporary attribute to the document before the selection works
                            // around the issue.
                            // Interestingly, IE 10 & older don't seem to have the issue.
                            input = document1.createElement("input");
                            input.setAttribute("name", "");
                            el.appendChild(input);
                            if (!el.querySelectorAll("[name='']").length) rbuggyQSA.push("\\[" + whitespace + "*name" + whitespace + "*=" + whitespace + "*(?:''|\"\")");
                        });
                        if (!support.cssHas) // Support: Chrome 105 - 110+, Safari 15.4 - 16.3+
                        // Our regular `try-catch` mechanism fails to detect natively-unsupported
                        // pseudo-classes inside `:has()` (such as `:has(:contains("Foo"))`)
                        // in browsers that parse the `:has()` argument as a forgiving selector list.
                        // https://drafts.csswg.org/selectors/#relational now requires the argument
                        // to be parsed unforgivingly, but browsers have not yet fully adjusted.
                        rbuggyQSA.push(":has");
                        rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
                        /* Sorting
	---------------------------------------------------------------------- */ // Document order sorting
                        sortOrder = function sortOrder(a, b) {
                            // Flag for duplicate removal
                            if (a === b) {
                                hasDuplicate = true;
                                return 0;
                            }
                            // Sort on method existence if only one input has compareDocumentPosition
                            var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                            if (compare) return compare;
                            // Calculate position if both inputs belong to the same document
                            // Support: IE 11+, Edge 17 - 18+
                            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                            // two documents; shallow comparisons work.
                            // eslint-disable-next-line eqeqeq
                            compare = (a.ownerDocument || a) == (b.ownerDocument || b) ? a.compareDocumentPosition(b) : // Otherwise we know they are disconnected
                            1;
                            // Disconnected nodes
                            if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
                                // Choose the first element that is related to our preferred document
                                // Support: IE 11+, Edge 17 - 18+
                                // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                                // two documents; shallow comparisons work.
                                // eslint-disable-next-line eqeqeq
                                if (a === document1 || a.ownerDocument == preferredDoc && find.contains(preferredDoc, a)) return -1;
                                // Support: IE 11+, Edge 17 - 18+
                                // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                                // two documents; shallow comparisons work.
                                // eslint-disable-next-line eqeqeq
                                if (b === document1 || b.ownerDocument == preferredDoc && find.contains(preferredDoc, b)) return 1;
                                // Maintain original order
                                return sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
                            }
                            return compare & 4 ? -1 : 1;
                        };
                        return document1;
                    }
                    find.matches = function(expr, elements) {
                        return find(expr, null, null, elements);
                    };
                    find.matchesSelector = function(elem, expr) {
                        setDocument(elem);
                        if (documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyQSA || !rbuggyQSA.test(expr))) try {
                            var ret = matches.call(elem, expr);
                            // IE 9's matchesSelector returns false on disconnected nodes
                            if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
                            // fragment in IE 9
                            elem.document && elem.document.nodeType !== 11) return ret;
                        } catch (e) {
                            nonnativeSelectorCache(expr, true);
                        }
                        return find(expr, document1, null, [
                            elem
                        ]).length > 0;
                    };
                    find.contains = function(context, elem) {
                        // Set document vars if needed
                        // Support: IE 11+, Edge 17 - 18+
                        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                        // two documents; shallow comparisons work.
                        // eslint-disable-next-line eqeqeq
                        if ((context.ownerDocument || context) != document1) setDocument(context);
                        return jQuery1.contains(context, elem);
                    };
                    find.attr = function(elem, name) {
                        // Set document vars if needed
                        // Support: IE 11+, Edge 17 - 18+
                        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                        // two documents; shallow comparisons work.
                        // eslint-disable-next-line eqeqeq
                        if ((elem.ownerDocument || elem) != document1) setDocument(elem);
                        var fn = Expr.attrHandle[name.toLowerCase()], // Don't get fooled by Object.prototype properties (see trac-13807)
                        val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
                        if (val !== undefined) return val;
                        return elem.getAttribute(name);
                    };
                    find.error = function(msg) {
                        throw new Error("Syntax error, unrecognized expression: " + msg);
                    };
                    /**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */ jQuery1.uniqueSort = function(results) {
                        var elem, duplicates = [], j = 0, i = 0;
                        // Unless we *know* we can detect duplicates, assume their presence
                        //
                        // Support: Android <=4.0+
                        // Testing for detecting duplicates is unpredictable so instead assume we can't
                        // depend on duplicate detection in all browsers without a stable sort.
                        hasDuplicate = !support.sortStable;
                        sortInput = !support.sortStable && slice.call(results, 0);
                        sort.call(results, sortOrder);
                        if (hasDuplicate) {
                            while(elem = results[i++])if (elem === results[i]) j = duplicates.push(i);
                            while(j--)splice.call(results, duplicates[j], 1);
                        }
                        // Clear input after sorting to release objects
                        // See https://github.com/jquery/sizzle/pull/225
                        sortInput = null;
                        return results;
                    };
                    jQuery1.fn.uniqueSort = function() {
                        return this.pushStack(jQuery1.uniqueSort(slice.apply(this)));
                    };
                    Expr = jQuery1.expr = {
                        // Can be adjusted by the user
                        cacheLength: 50,
                        createPseudo: markFunction,
                        match: matchExpr,
                        attrHandle: {},
                        find: {},
                        relative: {
                            ">": {
                                dir: "parentNode",
                                first: true
                            },
                            " ": {
                                dir: "parentNode"
                            },
                            "+": {
                                dir: "previousSibling",
                                first: true
                            },
                            "~": {
                                dir: "previousSibling"
                            }
                        },
                        preFilter: {
                            ATTR: function ATTR(match) {
                                match[1] = match[1].replace(runescape, funescape);
                                // Move the given value to match[3] whether quoted or unquoted
                                match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
                                if (match[2] === "~=") match[3] = " " + match[3] + " ";
                                return match.slice(0, 4);
                            },
                            CHILD: function CHILD(match) {
                                /* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/ match[1] = match[1].toLowerCase();
                                if (match[1].slice(0, 3) === "nth") {
                                    // nth-* requires argument
                                    if (!match[3]) find.error(match[0]);
                                    // numeric x and y parameters for Expr.filter.CHILD
                                    // remember that false/true cast respectively to 0/1
                                    match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                                    match[5] = +(match[7] + match[8] || match[3] === "odd");
                                // other types prohibit arguments
                                } else if (match[3]) find.error(match[0]);
                                return match;
                            },
                            PSEUDO: function PSEUDO(match) {
                                var excess, unquoted = !match[6] && match[2];
                                if (matchExpr.CHILD.test(match[0])) return null;
                                // Accept quoted arguments as-is
                                if (match[3]) match[2] = match[4] || match[5] || "";
                                else if (unquoted && rpseudo.test(unquoted) && // Get excess from tokenize (recursively)
                                (excess = tokenize(unquoted, true)) && // advance to the next closing parenthesis
                                (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                                    // excess is a negative index
                                    match[0] = match[0].slice(0, excess);
                                    match[2] = unquoted.slice(0, excess);
                                }
                                // Return only captures needed by the pseudo filter method (type and argument)
                                return match.slice(0, 3);
                            }
                        },
                        filter: {
                            TAG: function TAG(nodeNameSelector) {
                                var expectedNodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                                return nodeNameSelector === "*" ? function() {
                                    return true;
                                } : function(elem) {
                                    return nodeName(elem, expectedNodeName);
                                };
                            },
                            CLASS: function CLASS(className) {
                                var pattern = classCache[className + " "];
                                return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)"), classCache(className, function(elem) {
                                    return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
                                }));
                            },
                            ATTR: function ATTR(name, operator, check) {
                                return function(elem) {
                                    var result = find.attr(elem, name);
                                    if (result == null) return operator === "!=";
                                    if (!operator) return true;
                                    result += "";
                                    if (operator === "=") return result === check;
                                    if (operator === "!=") return result !== check;
                                    if (operator === "^=") return check && result.indexOf(check) === 0;
                                    if (operator === "*=") return check && result.indexOf(check) > -1;
                                    if (operator === "$=") return check && result.slice(-check.length) === check;
                                    if (operator === "~=") return (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1;
                                    if (operator === "|=") return result === check || result.slice(0, check.length + 1) === check + "-";
                                    return false;
                                };
                            },
                            CHILD: function CHILD(type, what, _argument, first, last) {
                                var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
                                return first === 1 && last === 0 ? // Shortcut for :nth-*(n)
                                function(elem) {
                                    return !!elem.parentNode;
                                } : function(elem, _context, xml) {
                                    var cache, outerCache, node, nodeIndex, start, dir = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
                                    if (parent) {
                                        // :(first|last|only)-(child|of-type)
                                        if (simple) {
                                            while(dir){
                                                node = elem;
                                                while(node = node[dir]){
                                                    if (ofType ? nodeName(node, name) : node.nodeType === 1) return false;
                                                }
                                                // Reverse direction for :only-* (if we haven't yet done so)
                                                start = dir = type === "only" && !start && "nextSibling";
                                            }
                                            return true;
                                        }
                                        start = [
                                            forward ? parent.firstChild : parent.lastChild
                                        ];
                                        // non-xml :nth-child(...) stores cache data on `parent`
                                        if (forward && useCache) {
                                            // Seek `elem` from a previously-cached index
                                            outerCache = parent[expando] || (parent[expando] = {});
                                            cache = outerCache[type] || [];
                                            nodeIndex = cache[0] === dirruns && cache[1];
                                            diff = nodeIndex && cache[2];
                                            node = nodeIndex && parent.childNodes[nodeIndex];
                                            while(node = ++nodeIndex && node && node[dir] || // Fallback to seeking `elem` from the start
                                            (diff = nodeIndex = 0) || start.pop())// When found, cache indexes on `parent` and break
                                            if (node.nodeType === 1 && ++diff && node === elem) {
                                                outerCache[type] = [
                                                    dirruns,
                                                    nodeIndex,
                                                    diff
                                                ];
                                                break;
                                            }
                                        } else {
                                            // Use previously-cached element index if available
                                            if (useCache) {
                                                outerCache = elem[expando] || (elem[expando] = {});
                                                cache = outerCache[type] || [];
                                                nodeIndex = cache[0] === dirruns && cache[1];
                                                diff = nodeIndex;
                                            }
                                            // xml :nth-child(...)
                                            // or :nth-last-child(...) or :nth(-last)?-of-type(...)
                                            if (diff === false) {
                                                // Use the same loop as above to seek `elem` from the start
                                                while(node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())if ((ofType ? nodeName(node, name) : node.nodeType === 1) && ++diff) {
                                                    // Cache the index of each encountered element
                                                    if (useCache) {
                                                        outerCache = node[expando] || (node[expando] = {});
                                                        outerCache[type] = [
                                                            dirruns,
                                                            diff
                                                        ];
                                                    }
                                                    if (node === elem) break;
                                                }
                                            }
                                        }
                                        // Incorporate the offset, then check against cycle size
                                        diff -= last;
                                        return diff === first || diff % first === 0 && diff / first >= 0;
                                    }
                                };
                            },
                            PSEUDO: function PSEUDO(pseudo, argument) {
                                // pseudo-class names are case-insensitive
                                // https://www.w3.org/TR/selectors/#pseudo-classes
                                // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
                                // Remember that setFilters inherits from pseudos
                                var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || find.error("unsupported pseudo: " + pseudo);
                                // The user may use createPseudo to indicate that
                                // arguments are needed to create the filter function
                                // just as jQuery does
                                if (fn[expando]) return fn(argument);
                                // But maintain support for old signatures
                                if (fn.length > 1) {
                                    args = [
                                        pseudo,
                                        pseudo,
                                        "",
                                        argument
                                    ];
                                    return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
                                        var idx, matched = fn(seed, argument), i = matched.length;
                                        while(i--){
                                            idx = indexOf.call(seed, matched[i]);
                                            seed[idx] = !(matches[idx] = matched[i]);
                                        }
                                    }) : function(elem) {
                                        return fn(elem, 0, args);
                                    };
                                }
                                return fn;
                            }
                        },
                        pseudos: {
                            // Potentially complex pseudos
                            not: markFunction(function(selector) {
                                // Trim the selector passed to compile
                                // to avoid treating leading and trailing
                                // spaces as combinators
                                var input = [], results = [], matcher = compile(selector.replace(rtrimCSS, "$1"));
                                return matcher[expando] ? markFunction(function(seed, matches, _context, xml) {
                                    var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
                                    // Match elements unmatched by `matcher`
                                    while(i--)if (elem = unmatched[i]) seed[i] = !(matches[i] = elem);
                                }) : function(elem, _context, xml) {
                                    input[0] = elem;
                                    matcher(input, null, xml, results);
                                    // Don't keep the element
                                    // (see https://github.com/jquery/sizzle/issues/299)
                                    input[0] = null;
                                    return !results.pop();
                                };
                            }),
                            has: markFunction(function(selector) {
                                return function(elem) {
                                    return find(selector, elem).length > 0;
                                };
                            }),
                            contains: markFunction(function(text) {
                                text = text.replace(runescape, funescape);
                                return function(elem) {
                                    return (elem.textContent || jQuery1.text(elem)).indexOf(text) > -1;
                                };
                            }),
                            // "Whether an element is represented by a :lang() selector
                            // is based solely on the element's language value
                            // being equal to the identifier C,
                            // or beginning with the identifier C immediately followed by "-".
                            // The matching of C against the element's language value is performed case-insensitively.
                            // The identifier C does not have to be a valid language name."
                            // https://www.w3.org/TR/selectors/#lang-pseudo
                            lang: markFunction(function(lang) {
                                // lang value must be a valid identifier
                                if (!ridentifier.test(lang || "")) find.error("unsupported lang: " + lang);
                                lang = lang.replace(runescape, funescape).toLowerCase();
                                return function(elem) {
                                    var elemLang;
                                    do if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                                        elemLang = elemLang.toLowerCase();
                                        return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                                    }
                                    while ((elem = elem.parentNode) && elem.nodeType === 1);
                                    return false;
                                };
                            }),
                            // Miscellaneous
                            target: function target(elem) {
                                var hash = window1.location && window1.location.hash;
                                return hash && hash.slice(1) === elem.id;
                            },
                            root: function root(elem) {
                                return elem === documentElement;
                            },
                            focus: function focus(elem) {
                                return elem === safeActiveElement() && document1.hasFocus() && !!(elem.type || elem.href || ~elem.tabIndex);
                            },
                            // Boolean properties
                            enabled: createDisabledPseudo(false),
                            disabled: createDisabledPseudo(true),
                            checked: function checked(elem) {
                                // In CSS3, :checked should return both checked and selected elements
                                // https://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                                return nodeName(elem, "input") && !!elem.checked || nodeName(elem, "option") && !!elem.selected;
                            },
                            selected: function selected(elem) {
                                // Support: IE <=11+
                                // Accessing the selectedIndex property
                                // forces the browser to treat the default option as
                                // selected when in an optgroup.
                                if (elem.parentNode) // eslint-disable-next-line no-unused-expressions
                                elem.parentNode.selectedIndex;
                                return elem.selected === true;
                            },
                            // Contents
                            empty: function empty(elem) {
                                // https://www.w3.org/TR/selectors/#empty-pseudo
                                // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
                                //   but not by others (comment: 8; processing instruction: 7; etc.)
                                // nodeType < 6 works because attributes (2) do not appear as children
                                for(elem = elem.firstChild; elem; elem = elem.nextSibling){
                                    if (elem.nodeType < 6) return false;
                                }
                                return true;
                            },
                            parent: function parent(elem) {
                                return !Expr.pseudos.empty(elem);
                            },
                            // Element/input types
                            header: function header(elem) {
                                return rheader.test(elem.nodeName);
                            },
                            input: function input(elem) {
                                return rinputs.test(elem.nodeName);
                            },
                            button: function button(elem) {
                                return nodeName(elem, "input") && elem.type === "button" || nodeName(elem, "button");
                            },
                            text: function text(elem) {
                                var attr;
                                return nodeName(elem, "input") && elem.type === "text" && // Support: IE <10 only
                                // New HTML5 attribute values (e.g., "search") appear
                                // with elem.type === "text"
                                ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
                            },
                            // Position-in-collection
                            first: createPositionalPseudo(function() {
                                return [
                                    0
                                ];
                            }),
                            last: createPositionalPseudo(function(_matchIndexes, length) {
                                return [
                                    length - 1
                                ];
                            }),
                            eq: createPositionalPseudo(function(_matchIndexes, length, argument) {
                                return [
                                    argument < 0 ? argument + length : argument
                                ];
                            }),
                            even: createPositionalPseudo(function(matchIndexes, length) {
                                var i = 0;
                                for(; i < length; i += 2)matchIndexes.push(i);
                                return matchIndexes;
                            }),
                            odd: createPositionalPseudo(function(matchIndexes, length) {
                                var i = 1;
                                for(; i < length; i += 2)matchIndexes.push(i);
                                return matchIndexes;
                            }),
                            lt: createPositionalPseudo(function(matchIndexes, length, argument) {
                                var i;
                                if (argument < 0) i = argument + length;
                                else if (argument > length) i = length;
                                else i = argument;
                                for(; --i >= 0;)matchIndexes.push(i);
                                return matchIndexes;
                            }),
                            gt: createPositionalPseudo(function(matchIndexes, length, argument) {
                                var i = argument < 0 ? argument + length : argument;
                                for(; ++i < length;)matchIndexes.push(i);
                                return matchIndexes;
                            })
                        }
                    };
                    Expr.pseudos.nth = Expr.pseudos.eq;
                    // Add button/input type pseudos
                    for(i in {
                        radio: true,
                        checkbox: true,
                        file: true,
                        password: true,
                        image: true
                    })Expr.pseudos[i] = createInputPseudo(i);
                    for(i in {
                        submit: true,
                        reset: true
                    })Expr.pseudos[i] = createButtonPseudo(i);
                    // Easy API for creating new setFilters
                    function setFilters() {}
                    setFilters.prototype = Expr.filters = Expr.pseudos;
                    Expr.setFilters = new setFilters();
                    function tokenize(selector, parseOnly) {
                        var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
                        if (cached) return parseOnly ? 0 : cached.slice(0);
                        soFar = selector;
                        groups = [];
                        preFilters = Expr.preFilter;
                        while(soFar){
                            // Comma and first run
                            if (!matched || (match = rcomma.exec(soFar))) {
                                if (match) // Don't consume trailing commas as valid
                                soFar = soFar.slice(match[0].length) || soFar;
                                groups.push(tokens = []);
                            }
                            matched = false;
                            // Combinators
                            if (match = rleadingCombinator.exec(soFar)) {
                                matched = match.shift();
                                tokens.push({
                                    value: matched,
                                    // Cast descendant combinators to space
                                    type: match[0].replace(rtrimCSS, " ")
                                });
                                soFar = soFar.slice(matched.length);
                            }
                            // Filters
                            for(type in Expr.filter)if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                                matched = match.shift();
                                tokens.push({
                                    value: matched,
                                    type: type,
                                    matches: match
                                });
                                soFar = soFar.slice(matched.length);
                            }
                            if (!matched) break;
                        }
                        // Return the length of the invalid excess
                        // if we're just parsing
                        // Otherwise, throw an error or return tokens
                        if (parseOnly) return soFar.length;
                        return soFar ? find.error(selector) : // Cache the tokens
                        tokenCache(selector, groups).slice(0);
                    }
                    function toSelector(tokens) {
                        var i = 0, len = tokens.length, selector = "";
                        for(; i < len; i++)selector += tokens[i].value;
                        return selector;
                    }
                    function addCombinator(matcher, combinator, base) {
                        var dir = combinator.dir, skip = combinator.next, key = skip || dir, checkNonElements = base && key === "parentNode", doneName = done++;
                        return combinator.first ? // Check against closest ancestor/preceding element
                        function(elem, context, xml) {
                            while(elem = elem[dir]){
                                if (elem.nodeType === 1 || checkNonElements) return matcher(elem, context, xml);
                            }
                            return false;
                        } : // Check against all ancestor/preceding elements
                        function(elem, context, xml) {
                            var oldCache, outerCache, newCache = [
                                dirruns,
                                doneName
                            ];
                            // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
                            if (xml) {
                                while(elem = elem[dir])if (elem.nodeType === 1 || checkNonElements) {
                                    if (matcher(elem, context, xml)) return true;
                                }
                            } else {
                                while(elem = elem[dir])if (elem.nodeType === 1 || checkNonElements) {
                                    outerCache = elem[expando] || (elem[expando] = {});
                                    if (skip && nodeName(elem, skip)) elem = elem[dir] || elem;
                                    else if ((oldCache = outerCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) // Assign to newCache so results back-propagate to previous elements
                                    return newCache[2] = oldCache[2];
                                    else {
                                        // Reuse newcache so results back-propagate to previous elements
                                        outerCache[key] = newCache;
                                        // A match means we're done; a fail means we have to keep checking
                                        if (newCache[2] = matcher(elem, context, xml)) return true;
                                    }
                                }
                            }
                            return false;
                        };
                    }
                    function elementMatcher(matchers) {
                        return matchers.length > 1 ? function(elem, context, xml) {
                            var i = matchers.length;
                            while(i--){
                                if (!matchers[i](elem, context, xml)) return false;
                            }
                            return true;
                        } : matchers[0];
                    }
                    function multipleContexts(selector, contexts, results) {
                        var i = 0, len = contexts.length;
                        for(; i < len; i++)find(selector, contexts[i], results);
                        return results;
                    }
                    function condense(unmatched, map, filter, context, xml) {
                        var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
                        for(; i < len; i++){
                            if (elem = unmatched[i]) {
                                if (!filter || filter(elem, context, xml)) {
                                    newUnmatched.push(elem);
                                    if (mapped) map.push(i);
                                }
                            }
                        }
                        return newUnmatched;
                    }
                    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
                        if (postFilter && !postFilter[expando]) postFilter = setMatcher(postFilter);
                        if (postFinder && !postFinder[expando]) postFinder = setMatcher(postFinder, postSelector);
                        return markFunction(function(seed, results, context, xml) {
                            var temp, i, elem, matcherOut, preMap = [], postMap = [], preexisting = results.length, // Get initial elements from seed or context
                            elems = seed || multipleContexts(selector || "*", context.nodeType ? [
                                context
                            ] : context, []), // Prefilter to get matcher input, preserving a map for seed-results synchronization
                            matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems;
                            if (matcher) {
                                // If we have a postFinder, or filtered seed, or non-seed postFilter
                                // or preexisting results,
                                matcherOut = postFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary
                                [] : // ...otherwise use results directly
                                results;
                                // Find primary matches
                                matcher(matcherIn, matcherOut, context, xml);
                            } else matcherOut = matcherIn;
                            // Apply postFilter
                            if (postFilter) {
                                temp = condense(matcherOut, postMap);
                                postFilter(temp, [], context, xml);
                                // Un-match failing elements by moving them back to matcherIn
                                i = temp.length;
                                while(i--)if (elem = temp[i]) matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                            }
                            if (seed) {
                                if (postFinder || preFilter) {
                                    if (postFinder) {
                                        // Get the final matcherOut by condensing this intermediate into postFinder contexts
                                        temp = [];
                                        i = matcherOut.length;
                                        while(i--)if (elem = matcherOut[i]) // Restore matcherIn since elem is not yet a final match
                                        temp.push(matcherIn[i] = elem);
                                        postFinder(null, matcherOut = [], temp, xml);
                                    }
                                    // Move matched elements from seed to results to keep them synchronized
                                    i = matcherOut.length;
                                    while(i--)if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1) seed[temp] = !(results[temp] = elem);
                                }
                            } else {
                                matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
                                if (postFinder) postFinder(null, results, matcherOut, xml);
                                else push.apply(results, matcherOut);
                            }
                        });
                    }
                    function matcherFromTokens(tokens) {
                        var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i = leadingRelative ? 1 : 0, // The foundational matcher ensures that elements are reachable from top-level context(s)
                        matchContext = addCombinator(function(elem) {
                            return elem === checkContext;
                        }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
                            return indexOf.call(checkContext, elem) > -1;
                        }, implicitRelative, true), matchers = [
                            function(elem, context, xml) {
                                // Support: IE 11+, Edge 17 - 18+
                                // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                                // two documents; shallow comparisons work.
                                // eslint-disable-next-line eqeqeq
                                var ret = !leadingRelative && (xml || context != outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                                // Avoid hanging onto element
                                // (see https://github.com/jquery/sizzle/issues/299)
                                checkContext = null;
                                return ret;
                            }
                        ];
                        for(; i < len; i++)if (matcher = Expr.relative[tokens[i].type]) matchers = [
                            addCombinator(elementMatcher(matchers), matcher)
                        ];
                        else {
                            matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
                            // Return special upon seeing a positional matcher
                            if (matcher[expando]) {
                                // Find the next relative operator (if any) for proper handling
                                j = ++i;
                                for(; j < len; j++){
                                    if (Expr.relative[tokens[j].type]) break;
                                }
                                return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(// If the preceding token was a descendant combinator, insert an implicit any-element `*`
                                tokens.slice(0, i - 1).concat({
                                    value: tokens[i - 2].type === " " ? "*" : ""
                                })).replace(rtrimCSS, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
                            }
                            matchers.push(matcher);
                        }
                        return elementMatcher(matchers);
                    }
                    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
                        var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function superMatcher(seed, context, xml, results, outermost) {
                            var elem, j, matcher, matchedCount = 0, i = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, // We must always have either seed elements or outermost context
                            elems = seed || byElement && Expr.find.TAG("*", outermost), // Use integer dirruns iff this is the outermost matcher
                            dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
                            if (outermost) // Support: IE 11+, Edge 17 - 18+
                            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                            // two documents; shallow comparisons work.
                            // eslint-disable-next-line eqeqeq
                            outermostContext = context == document1 || context || outermost;
                            // Add elements passing elementMatchers directly to results
                            // Support: iOS <=7 - 9 only
                            // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching
                            // elements by id. (see trac-14142)
                            for(; i !== len && (elem = elems[i]) != null; i++){
                                if (byElement && elem) {
                                    j = 0;
                                    // Support: IE 11+, Edge 17 - 18+
                                    // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                                    // two documents; shallow comparisons work.
                                    // eslint-disable-next-line eqeqeq
                                    if (!context && elem.ownerDocument != document1) {
                                        setDocument(elem);
                                        xml = !documentIsHTML;
                                    }
                                    while(matcher = elementMatchers[j++])if (matcher(elem, context || document1, xml)) {
                                        push.call(results, elem);
                                        break;
                                    }
                                    if (outermost) dirruns = dirrunsUnique;
                                }
                                // Track unmatched elements for set filters
                                if (bySet) {
                                    // They will have gone through all possible matchers
                                    if (elem = !matcher && elem) matchedCount--;
                                    // Lengthen the array for every element, matched or not
                                    if (seed) unmatched.push(elem);
                                }
                            }
                            // `i` is now the count of elements visited above, and adding it to `matchedCount`
                            // makes the latter nonnegative.
                            matchedCount += i;
                            // Apply set filters to unmatched elements
                            // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
                            // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
                            // no element matchers and no seed.
                            // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
                            // case, which will result in a "00" `matchedCount` that differs from `i` but is also
                            // numerically zero.
                            if (bySet && i !== matchedCount) {
                                j = 0;
                                while(matcher = setMatchers[j++])matcher(unmatched, setMatched, context, xml);
                                if (seed) {
                                    // Reintegrate element matches to eliminate the need for sorting
                                    if (matchedCount > 0) {
                                        while(i--)if (!(unmatched[i] || setMatched[i])) setMatched[i] = pop.call(results);
                                    }
                                    // Discard index placeholder values to get only actual matches
                                    setMatched = condense(setMatched);
                                }
                                // Add matches to results
                                push.apply(results, setMatched);
                                // Seedless set matches succeeding multiple successful matchers stipulate sorting
                                if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) jQuery1.uniqueSort(results);
                            }
                            // Override manipulation of globals by nested matchers
                            if (outermost) {
                                dirruns = dirrunsUnique;
                                outermostContext = contextBackup;
                            }
                            return unmatched;
                        };
                        return bySet ? markFunction(superMatcher) : superMatcher;
                    }
                    function compile(selector, match /* Internal Use Only */ ) {
                        var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
                        if (!cached) {
                            // Generate a function of recursive functions that can be used to check each element
                            if (!match) match = tokenize(selector);
                            i = match.length;
                            while(i--){
                                cached = matcherFromTokens(match[i]);
                                if (cached[expando]) setMatchers.push(cached);
                                else elementMatchers.push(cached);
                            }
                            // Cache the compiled function
                            cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
                            // Save selector and tokenization
                            cached.selector = selector;
                        }
                        return cached;
                    }
                    /**
 * A low-level selection function that works with jQuery's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with jQuery selector compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */ function select(selector, context, results, seed) {
                        var i, tokens, token, type, _$find, compiled = typeof selector === "function" && selector, match = !seed && tokenize(selector = compiled.selector || selector);
                        results = results || [];
                        // Try to minimize operations if there is only one selector in the list and no seed
                        // (the latter of which guarantees us context)
                        if (match.length === 1) {
                            // Reduce context if the leading compound selector is an ID
                            tokens = match[0] = match[0].slice(0);
                            if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                                context = (Expr.find.ID(token.matches[0].replace(runescape, funescape), context) || [])[0];
                                if (!context) return results;
                                else if (compiled) context = context.parentNode;
                                selector = selector.slice(tokens.shift().value.length);
                            }
                            // Fetch a seed set for right-to-left matching
                            i = matchExpr.needsContext.test(selector) ? 0 : tokens.length;
                            while(i--){
                                token = tokens[i];
                                // Abort if we hit a combinator
                                if (Expr.relative[type = token.type]) break;
                                if (_$find = Expr.find[type]) // Search, expanding context for leading sibling combinators
                                {
                                    if (seed = _$find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
                                        // If seed is empty or no tokens remain, we can return early
                                        tokens.splice(i, 1);
                                        selector = seed.length && toSelector(tokens);
                                        if (!selector) {
                                            push.apply(results, seed);
                                            return results;
                                        }
                                        break;
                                    }
                                }
                            }
                        }
                        // Compile and execute a filtering function if one is not provided
                        // Provide `match` to avoid retokenization if we modified the selector above
                        (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
                        return results;
                    }
                    // One-time assignments
                    // Support: Android <=4.0 - 4.1+
                    // Sort stability
                    support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
                    // Initialize against the default document
                    setDocument();
                    // Support: Android <=4.0 - 4.1+
                    // Detached nodes confoundingly follow *each other*
                    support.sortDetached = assert(function(el) {
                        // Should return 1, but returns 4 (following)
                        return el.compareDocumentPosition(document1.createElement("fieldset")) & 1;
                    });
                    jQuery1.find = find;
                    // Deprecated
                    jQuery1.expr[":"] = jQuery1.expr.pseudos;
                    jQuery1.unique = jQuery1.uniqueSort;
                    // These have always been private, but they used to be documented as part of
                    // Sizzle so let's maintain them for now for backwards compatibility purposes.
                    find.compile = compile;
                    find.select = select;
                    find.setDocument = setDocument;
                    find.tokenize = tokenize;
                    find.escape = jQuery1.escapeSelector;
                    find.getText = jQuery1.text;
                    find.isXML = jQuery1.isXMLDoc;
                    find.selectors = jQuery1.expr;
                    find.support = jQuery1.support;
                    find.uniqueSort = jQuery1.uniqueSort;
                /* eslint-enable */ })();
                var dir = function dir(elem, dir, until) {
                    var matched = [], truncate = until !== undefined;
                    while((elem = elem[dir]) && elem.nodeType !== 9)if (elem.nodeType === 1) {
                        if (truncate && jQuery1(elem).is(until)) break;
                        matched.push(elem);
                    }
                    return matched;
                };
                var siblings = function siblings(n, elem) {
                    var matched = [];
                    for(; n; n = n.nextSibling)if (n.nodeType === 1 && n !== elem) matched.push(n);
                    return matched;
                };
                var rneedsContext = jQuery1.expr.match.needsContext;
                var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
                // Implement the identical functionality for filter and not
                function winnow(elements, qualifier, not) {
                    if (isFunction(qualifier)) return jQuery1.grep(elements, function(elem, i) {
                        return !!qualifier.call(elem, i, elem) !== not;
                    });
                    // Single element
                    if (qualifier.nodeType) return jQuery1.grep(elements, function(elem) {
                        return elem === qualifier !== not;
                    });
                    // Arraylike of elements (jQuery, arguments, Array)
                    if (typeof qualifier !== "string") return jQuery1.grep(elements, function(elem) {
                        return indexOf.call(qualifier, elem) > -1 !== not;
                    });
                    // Filtered directly for both simple and complex selectors
                    return jQuery1.filter(qualifier, elements, not);
                }
                jQuery1.filter = function(expr, elems, not) {
                    var elem = elems[0];
                    if (not) expr = ":not(" + expr + ")";
                    if (elems.length === 1 && elem.nodeType === 1) return jQuery1.find.matchesSelector(elem, expr) ? [
                        elem
                    ] : [];
                    return jQuery1.find.matches(expr, jQuery1.grep(elems, function(elem) {
                        return elem.nodeType === 1;
                    }));
                };
                jQuery1.fn.extend({
                    find: function find(selector) {
                        var i, ret, len = this.length, self1 = this;
                        if (typeof selector !== "string") return this.pushStack(jQuery1(selector).filter(function() {
                            for(i = 0; i < len; i++){
                                if (jQuery1.contains(self1[i], this)) return true;
                            }
                        }));
                        ret = this.pushStack([]);
                        for(i = 0; i < len; i++)jQuery1.find(selector, self1[i], ret);
                        return len > 1 ? jQuery1.uniqueSort(ret) : ret;
                    },
                    filter: function filter(selector) {
                        return this.pushStack(winnow(this, selector || [], false));
                    },
                    not: function not(selector) {
                        return this.pushStack(winnow(this, selector || [], true));
                    },
                    is: function is(selector) {
                        return !!winnow(this, // If this is a positional/relative selector, check membership in the returned set
                        // so $("p:first").is("p:last") won't return true for a doc with two "p".
                        typeof selector === "string" && rneedsContext.test(selector) ? jQuery1(selector) : selector || [], false).length;
                    }
                });
                // Initialize a jQuery object
                // A central reference to the root jQuery(document)
                var rootjQuery, // A simple way to check for HTML strings
                // Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)
                // Strict HTML recognition (trac-11290: must start with <)
                // Shortcut simple #id case for speed
                rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, init = jQuery1.fn.init = function init(selector, context, root) {
                    var match, elem;
                    // HANDLE: $(""), $(null), $(undefined), $(false)
                    if (!selector) return this;
                    // Method init() accepts an alternate rootjQuery
                    // so migrate can support jQuery.sub (gh-2101)
                    root = root || rootjQuery;
                    // Handle HTML strings
                    if (typeof selector === "string") {
                        if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) // Assume that strings that start and end with <> are HTML and skip the regex check
                        match = [
                            null,
                            selector,
                            null
                        ];
                        else match = rquickExpr.exec(selector);
                        // Match html or make sure no context is specified for #id
                        if (match && (match[1] || !context)) {
                            // HANDLE: $(html) -> $(array)
                            if (match[1]) {
                                context = context instanceof jQuery1 ? context[0] : context;
                                // Option to run scripts is true for back-compat
                                // Intentionally let the error be thrown if parseHTML is not present
                                jQuery1.merge(this, jQuery1.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document1, true));
                                // HANDLE: $(html, props)
                                if (rsingleTag.test(match[1]) && jQuery1.isPlainObject(context)) {
                                    for(match in context)// Properties of context are called as methods if possible
                                    if (isFunction(this[match])) this[match](context[match]);
                                    else this.attr(match, context[match]);
                                }
                                return this;
                            // HANDLE: $(#id)
                            } else {
                                elem = document1.getElementById(match[2]);
                                if (elem) {
                                    // Inject the element directly into the jQuery object
                                    this[0] = elem;
                                    this.length = 1;
                                }
                                return this;
                            }
                        } else if (!context || context.jquery) return (context || root).find(selector);
                        else return this.constructor(context).find(selector);
                    // HANDLE: $(DOMElement)
                    } else if (selector.nodeType) {
                        this[0] = selector;
                        this.length = 1;
                        return this;
                    // HANDLE: $(function)
                    // Shortcut for document ready
                    } else if (isFunction(selector)) return root.ready !== undefined ? root.ready(selector) : // Execute immediately if ready is not present
                    selector(jQuery1);
                    return jQuery1.makeArray(selector, this);
                };
                // Give the init function the jQuery prototype for later instantiation
                init.prototype = jQuery1.fn;
                // Initialize central reference
                rootjQuery = jQuery1(document1);
                var rparentsprev = /^(?:parents|prev(?:Until|All))/, // Methods guaranteed to produce a unique set when starting from a unique set
                guaranteedUnique = {
                    children: true,
                    contents: true,
                    next: true,
                    prev: true
                };
                jQuery1.fn.extend({
                    has: function has(target) {
                        var targets = jQuery1(target, this), l = targets.length;
                        return this.filter(function() {
                            var i = 0;
                            for(; i < l; i++){
                                if (jQuery1.contains(this, targets[i])) return true;
                            }
                        });
                    },
                    closest: function closest(selectors, context) {
                        var cur, i = 0, l = this.length, matched = [], targets = typeof selectors !== "string" && jQuery1(selectors);
                        // Positional selectors never match, since there's no _selection_ context
                        if (!rneedsContext.test(selectors)) for(; i < l; i++){
                            for(cur = this[i]; cur && cur !== context; cur = cur.parentNode)// Always skip document fragments
                            if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : // Don't pass non-elements to jQuery#find
                            cur.nodeType === 1 && jQuery1.find.matchesSelector(cur, selectors))) {
                                matched.push(cur);
                                break;
                            }
                        }
                        return this.pushStack(matched.length > 1 ? jQuery1.uniqueSort(matched) : matched);
                    },
                    // Determine the position of an element within the set
                    index: function index(elem) {
                        // No argument, return index in parent
                        if (!elem) return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
                        // Index in selector
                        if (typeof elem === "string") return indexOf.call(jQuery1(elem), this[0]);
                        // Locate the position of the desired element
                        return indexOf.call(this, // If it receives a jQuery object, the first element is used
                        elem.jquery ? elem[0] : elem);
                    },
                    add: function add(selector, context) {
                        return this.pushStack(jQuery1.uniqueSort(jQuery1.merge(this.get(), jQuery1(selector, context))));
                    },
                    addBack: function addBack(selector) {
                        return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
                    }
                });
                function sibling(cur, dir) {
                    while((cur = cur[dir]) && cur.nodeType !== 1);
                    return cur;
                }
                jQuery1.each({
                    parent: function parent(elem) {
                        var parent = elem.parentNode;
                        return parent && parent.nodeType !== 11 ? parent : null;
                    },
                    parents: function parents(elem) {
                        return dir(elem, "parentNode");
                    },
                    parentsUntil: function parentsUntil(elem, _i, until) {
                        return dir(elem, "parentNode", until);
                    },
                    next: function next(elem) {
                        return sibling(elem, "nextSibling");
                    },
                    prev: function prev(elem) {
                        return sibling(elem, "previousSibling");
                    },
                    nextAll: function nextAll(elem) {
                        return dir(elem, "nextSibling");
                    },
                    prevAll: function prevAll(elem) {
                        return dir(elem, "previousSibling");
                    },
                    nextUntil: function nextUntil(elem, _i, until) {
                        return dir(elem, "nextSibling", until);
                    },
                    prevUntil: function prevUntil(elem, _i, until) {
                        return dir(elem, "previousSibling", until);
                    },
                    siblings: function siblings1(elem) {
                        return siblings((elem.parentNode || {}).firstChild, elem);
                    },
                    children: function children(elem) {
                        return siblings(elem.firstChild);
                    },
                    contents: function contents(elem) {
                        if (elem.contentDocument != null && // Support: IE 11+
                        // <object> elements with no `data` attribute has an object
                        // `contentDocument` with a `null` prototype.
                        getProto(elem.contentDocument)) return elem.contentDocument;
                        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
                        // Treat the template element as a regular one in browsers that
                        // don't support it.
                        if (nodeName(elem, "template")) elem = elem.content || elem;
                        return jQuery1.merge([], elem.childNodes);
                    }
                }, function(name, fn) {
                    jQuery1.fn[name] = function(until, selector) {
                        var matched = jQuery1.map(this, fn, until);
                        if (name.slice(-5) !== "Until") selector = until;
                        if (selector && typeof selector === "string") matched = jQuery1.filter(selector, matched);
                        if (this.length > 1) {
                            // Remove duplicates
                            if (!guaranteedUnique[name]) jQuery1.uniqueSort(matched);
                            // Reverse order for parents* and prev-derivatives
                            if (rparentsprev.test(name)) matched.reverse();
                        }
                        return this.pushStack(matched);
                    };
                });
                var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
                // Convert String-formatted options into Object-formatted ones
                function createOptions(options) {
                    var object = {};
                    jQuery1.each(options.match(rnothtmlwhite) || [], function(_, flag) {
                        object[flag] = true;
                    });
                    return object;
                }
                /*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */ jQuery1.Callbacks = function(options) {
                    // Convert options from String-formatted to Object-formatted if needed
                    // (we check in cache first)
                    options = typeof options === "string" ? createOptions(options) : jQuery1.extend({}, options);
                    var firing, // Last fire value for non-forgettable lists
                    memory, // Flag to know if list was already fired
                    fired, // Flag to prevent firing
                    locked, // Actual callback list
                    list = [], // Queue of execution data for repeatable lists
                    queue = [], // Index of currently firing callback (modified by add/remove as needed)
                    firingIndex = -1, // Fire callbacks
                    fire = function fire() {
                        // Enforce single-firing
                        locked = locked || options.once;
                        // Execute callbacks for all pending executions,
                        // respecting firingIndex overrides and runtime changes
                        fired = firing = true;
                        for(; queue.length; firingIndex = -1){
                            memory = queue.shift();
                            while(++firingIndex < list.length)// Run callback and check for early termination
                            if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
                                // Jump to end and forget the data so .add doesn't re-fire
                                firingIndex = list.length;
                                memory = false;
                            }
                        }
                        // Forget the data if we're done with it
                        if (!options.memory) memory = false;
                        firing = false;
                        // Clean up if we're done firing for good
                        if (locked) {
                            // Keep an empty list if we have data for future add calls
                            if (memory) list = [];
                            else list = "";
                        }
                    }, // Actual Callbacks object
                    self1 = {
                        // Add a callback or a collection of callbacks to the list
                        add: function add() {
                            if (list) {
                                // If we have memory from a past run, we should fire after adding
                                if (memory && !firing) {
                                    firingIndex = list.length - 1;
                                    queue.push(memory);
                                }
                                (function add(args) {
                                    jQuery1.each(args, function(_, arg) {
                                        if (isFunction(arg)) {
                                            if (!options.unique || !self1.has(arg)) list.push(arg);
                                        } else if (arg && arg.length && toType(arg) !== "string") // Inspect recursively
                                        add(arg);
                                    });
                                })(arguments);
                                if (memory && !firing) fire();
                            }
                            return this;
                        },
                        // Remove a callback from the list
                        remove: function remove() {
                            jQuery1.each(arguments, function(_, arg) {
                                var index;
                                while((index = jQuery1.inArray(arg, list, index)) > -1){
                                    list.splice(index, 1);
                                    // Handle firing indexes
                                    if (index <= firingIndex) firingIndex--;
                                }
                            });
                            return this;
                        },
                        // Check if a given callback is in the list.
                        // If no argument is given, return whether or not list has callbacks attached.
                        has: function has(fn) {
                            return fn ? jQuery1.inArray(fn, list) > -1 : list.length > 0;
                        },
                        // Remove all callbacks from the list
                        empty: function empty() {
                            if (list) list = [];
                            return this;
                        },
                        // Disable .fire and .add
                        // Abort any current/pending executions
                        // Clear all callbacks and values
                        disable: function disable() {
                            locked = queue = [];
                            list = memory = "";
                            return this;
                        },
                        disabled: function disabled() {
                            return !list;
                        },
                        // Disable .fire
                        // Also disable .add unless we have memory (since it would have no effect)
                        // Abort any pending executions
                        lock: function lock() {
                            locked = queue = [];
                            if (!memory && !firing) list = memory = "";
                            return this;
                        },
                        locked: function locked1() {
                            return !!locked;
                        },
                        // Call all callbacks with the given context and arguments
                        fireWith: function fireWith(context, args) {
                            if (!locked) {
                                args = args || [];
                                args = [
                                    context,
                                    args.slice ? args.slice() : args
                                ];
                                queue.push(args);
                                if (!firing) fire();
                            }
                            return this;
                        },
                        // Call all the callbacks with the given arguments
                        fire: function fire() {
                            self1.fireWith(this, arguments);
                            return this;
                        },
                        // To know if the callbacks have already been called at least once
                        fired: function fired1() {
                            return !!fired;
                        }
                    };
                    return self1;
                };
                function Identity(v) {
                    return v;
                }
                function Thrower(ex) {
                    throw ex;
                }
                function adoptValue(value, resolve, reject, noValue) {
                    var method;
                    try {
                        // Check for promise aspect first to privilege synchronous behavior
                        if (value && isFunction(method = value.promise)) method.call(value).done(resolve).fail(reject);
                        else if (value && isFunction(method = value.then)) method.call(value, resolve, reject);
                        else // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
                        // * false: [ value ].slice( 0 ) => resolve( value )
                        // * true: [ value ].slice( 1 ) => resolve()
                        resolve.apply(undefined, [
                            value
                        ].slice(noValue));
                    // For Promises/A+, convert exceptions into rejections
                    // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
                    // Deferred#then to conditionally suppress rejection.
                    } catch (value) {
                        // Support: Android 4.0 only
                        // Strict mode functions invoked without .call/.apply get global-object context
                        reject.apply(undefined, [
                            value
                        ]);
                    }
                }
                jQuery1.extend({
                    Deferred: function Deferred(func) {
                        var tuples = [
                            // action, add listener, callbacks,
                            // ... .then handlers, argument index, [final state]
                            [
                                "notify",
                                "progress",
                                jQuery1.Callbacks("memory"),
                                jQuery1.Callbacks("memory"),
                                2
                            ],
                            [
                                "resolve",
                                "done",
                                jQuery1.Callbacks("once memory"),
                                jQuery1.Callbacks("once memory"),
                                0,
                                "resolved"
                            ],
                            [
                                "reject",
                                "fail",
                                jQuery1.Callbacks("once memory"),
                                jQuery1.Callbacks("once memory"),
                                1,
                                "rejected"
                            ]
                        ], state = "pending", promise = {
                            state: function state1() {
                                return state;
                            },
                            always: function always() {
                                deferred.done(arguments).fail(arguments);
                                return this;
                            },
                            "catch": function(fn) {
                                return promise.then(null, fn);
                            },
                            // Keep pipe for back-compat
                            pipe: function pipe() {
                                var fns = arguments;
                                return jQuery1.Deferred(function(newDefer) {
                                    jQuery1.each(tuples, function(_i, tuple) {
                                        // Map tuples (progress, done, fail) to arguments (done, fail, progress)
                                        var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]];
                                        // deferred.progress(function() { bind to newDefer or newDefer.notify })
                                        // deferred.done(function() { bind to newDefer or newDefer.resolve })
                                        // deferred.fail(function() { bind to newDefer or newDefer.reject })
                                        deferred[tuple[1]](function() {
                                            var returned = fn && fn.apply(this, arguments);
                                            if (returned && isFunction(returned.promise)) returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                                            else newDefer[tuple[0] + "With"](this, fn ? [
                                                returned
                                            ] : arguments);
                                        });
                                    });
                                    fns = null;
                                }).promise();
                            },
                            then: function then(onFulfilled, onRejected, onProgress) {
                                var maxDepth = 0;
                                function resolve(depth, deferred, handler, special) {
                                    return function() {
                                        var that = this, args = arguments, mightThrow = function mightThrow() {
                                            var returned, then;
                                            // Support: Promises/A+ section 2.3.3.3.3
                                            // https://promisesaplus.com/#point-59
                                            // Ignore double-resolution attempts
                                            if (depth < maxDepth) return;
                                            returned = handler.apply(that, args);
                                            // Support: Promises/A+ section 2.3.1
                                            // https://promisesaplus.com/#point-48
                                            if (returned === deferred.promise()) throw new TypeError("Thenable self-resolution");
                                            // Support: Promises/A+ sections 2.3.3.1, 3.5
                                            // https://promisesaplus.com/#point-54
                                            // https://promisesaplus.com/#point-75
                                            // Retrieve `then` only once
                                            then = returned && // Support: Promises/A+ section 2.3.4
                                            // https://promisesaplus.com/#point-64
                                            // Only check objects and functions for thenability
                                            (typeof returned === "object" || typeof returned === "function") && returned.then;
                                            // Handle a returned thenable
                                            if (isFunction(then)) {
                                                // Special processors (notify) just wait for resolution
                                                if (special) then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special));
                                                else {
                                                    // ...and disregard older resolution values
                                                    maxDepth++;
                                                    then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));
                                                }
                                            } else {
                                                // Only substitute handlers pass on context
                                                // and multiple values (non-spec behavior)
                                                if (handler !== Identity) {
                                                    that = undefined;
                                                    args = [
                                                        returned
                                                    ];
                                                }
                                                // Process the value(s)
                                                // Default process is resolve
                                                (special || deferred.resolveWith)(that, args);
                                            }
                                        }, // Only normal processors (resolve) catch and reject exceptions
                                        process = special ? mightThrow : function process1() {
                                            try {
                                                mightThrow();
                                            } catch (e) {
                                                if (jQuery1.Deferred.exceptionHook) jQuery1.Deferred.exceptionHook(e, process.error);
                                                // Support: Promises/A+ section 2.3.3.3.4.1
                                                // https://promisesaplus.com/#point-61
                                                // Ignore post-resolution exceptions
                                                if (depth + 1 >= maxDepth) {
                                                    // Only substitute handlers pass on context
                                                    // and multiple values (non-spec behavior)
                                                    if (handler !== Thrower) {
                                                        that = undefined;
                                                        args = [
                                                            e
                                                        ];
                                                    }
                                                    deferred.rejectWith(that, args);
                                                }
                                            }
                                        };
                                        // Support: Promises/A+ section 2.3.3.3.1
                                        // https://promisesaplus.com/#point-57
                                        // Re-resolve promises immediately to dodge false rejection from
                                        // subsequent errors
                                        if (depth) process();
                                        else {
                                            // Call an optional hook to record the error, in case of exception
                                            // since it's otherwise lost when execution goes async
                                            if (jQuery1.Deferred.getErrorHook) process.error = jQuery1.Deferred.getErrorHook();
                                            else if (jQuery1.Deferred.getStackHook) process.error = jQuery1.Deferred.getStackHook();
                                            window1.setTimeout(process);
                                        }
                                    };
                                }
                                return jQuery1.Deferred(function(newDefer) {
                                    // progress_handlers.add( ... )
                                    tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith));
                                    // fulfilled_handlers.add( ... )
                                    tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity));
                                    // rejected_handlers.add( ... )
                                    tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower));
                                }).promise();
                            },
                            // Get a promise for this deferred
                            // If obj is provided, the promise aspect is added to the object
                            promise: function promise1(obj) {
                                return obj != null ? jQuery1.extend(obj, promise) : promise;
                            }
                        }, deferred = {};
                        // Add list-specific methods
                        jQuery1.each(tuples, function(i, tuple) {
                            var list = tuple[2], stateString = tuple[5];
                            // promise.progress = list.add
                            // promise.done = list.add
                            // promise.fail = list.add
                            promise[tuple[1]] = list.add;
                            // Handle state
                            if (stateString) list.add(function() {
                                // state = "resolved" (i.e., fulfilled)
                                // state = "rejected"
                                state = stateString;
                            }, // rejected_callbacks.disable
                            // fulfilled_callbacks.disable
                            tuples[3 - i][2].disable, // rejected_handlers.disable
                            // fulfilled_handlers.disable
                            tuples[3 - i][3].disable, // progress_callbacks.lock
                            tuples[0][2].lock, // progress_handlers.lock
                            tuples[0][3].lock);
                            // progress_handlers.fire
                            // fulfilled_handlers.fire
                            // rejected_handlers.fire
                            list.add(tuple[3].fire);
                            // deferred.notify = function() { deferred.notifyWith(...) }
                            // deferred.resolve = function() { deferred.resolveWith(...) }
                            // deferred.reject = function() { deferred.rejectWith(...) }
                            deferred[tuple[0]] = function() {
                                deferred[tuple[0] + "With"](this === deferred ? undefined : this, arguments);
                                return this;
                            };
                            // deferred.notifyWith = list.fireWith
                            // deferred.resolveWith = list.fireWith
                            // deferred.rejectWith = list.fireWith
                            deferred[tuple[0] + "With"] = list.fireWith;
                        });
                        // Make the deferred a promise
                        promise.promise(deferred);
                        // Call given func if any
                        if (func) func.call(deferred, deferred);
                        // All done!
                        return deferred;
                    },
                    // Deferred helper
                    when: function when(singleValue) {
                        var // count of uncompleted subordinates
                        remaining = arguments.length, // count of unprocessed arguments
                        i = remaining, // subordinate fulfillment data
                        resolveContexts = Array(i), resolveValues = slice.call(arguments), // the primary Deferred
                        primary = jQuery1.Deferred(), // subordinate callback factory
                        updateFunc = function updateFunc(i) {
                            return function(value) {
                                resolveContexts[i] = this;
                                resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value;
                                if (!--remaining) primary.resolveWith(resolveContexts, resolveValues);
                            };
                        };
                        // Single- and empty arguments are adopted like Promise.resolve
                        if (remaining <= 1) {
                            adoptValue(singleValue, primary.done(updateFunc(i)).resolve, primary.reject, !remaining);
                            // Use .then() to unwrap secondary thenables (cf. gh-3000)
                            if (primary.state() === "pending" || isFunction(resolveValues[i] && resolveValues[i].then)) return primary.then();
                        }
                        // Multiple arguments are aggregated like Promise.all array elements
                        while(i--)adoptValue(resolveValues[i], updateFunc(i), primary.reject);
                        return primary.promise();
                    }
                });
                // These usually indicate a programmer mistake during development,
                // warn about them ASAP rather than swallowing them by default.
                var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
                // If `jQuery.Deferred.getErrorHook` is defined, `asyncError` is an error
                // captured before the async barrier to get the original error cause
                // which may otherwise be hidden.
                jQuery1.Deferred.exceptionHook = function(error, asyncError) {
                    // Support: IE 8 - 9 only
                    // Console exists when dev tools are open, which can happen at any time
                    if (window1.console && window1.console.warn && error && rerrorNames.test(error.name)) window1.console.warn("jQuery.Deferred exception: " + error.message, error.stack, asyncError);
                };
                jQuery1.readyException = function(error) {
                    window1.setTimeout(function() {
                        throw error;
                    });
                };
                // The deferred used on DOM ready
                var readyList = jQuery1.Deferred();
                jQuery1.fn.ready = function(fn) {
                    readyList.then(fn)// Wrap jQuery.readyException in a function so that the lookup
                    // happens at the time of error handling instead of callback
                    // registration.
                    .catch(function(error) {
                        jQuery1.readyException(error);
                    });
                    return this;
                };
                jQuery1.extend({
                    // Is the DOM ready to be used? Set to true once it occurs.
                    isReady: false,
                    // A counter to track how many items to wait for before
                    // the ready event fires. See trac-6781
                    readyWait: 1,
                    // Handle when the DOM is ready
                    ready: function ready(wait) {
                        // Abort if there are pending holds or we're already ready
                        if (wait === true ? --jQuery1.readyWait : jQuery1.isReady) return;
                        // Remember that the DOM is ready
                        jQuery1.isReady = true;
                        // If a normal DOM Ready event fired, decrement, and wait if need be
                        if (wait !== true && --jQuery1.readyWait > 0) return;
                        // If there are functions bound, to execute
                        readyList.resolveWith(document1, [
                            jQuery1
                        ]);
                    }
                });
                jQuery1.ready.then = readyList.then;
                // The ready event handler and self cleanup method
                function completed() {
                    document1.removeEventListener("DOMContentLoaded", completed);
                    window1.removeEventListener("load", completed);
                    jQuery1.ready();
                }
                // Catch cases where $(document).ready() is called
                // after the browser event has already occurred.
                // Support: IE <=9 - 10 only
                // Older IE sometimes signals "interactive" too soon
                if (document1.readyState === "complete" || document1.readyState !== "loading" && !document1.documentElement.doScroll) // Handle it asynchronously to allow scripts the opportunity to delay ready
                window1.setTimeout(jQuery1.ready);
                else {
                    // Use the handy event callback
                    document1.addEventListener("DOMContentLoaded", completed);
                    // A fallback to window.onload, that will always work
                    window1.addEventListener("load", completed);
                }
                // Multifunctional method to get and set values of a collection
                // The value/s can optionally be executed if it's a function
                var access = function access1(elems, fn, key, value, chainable, emptyGet, raw) {
                    var i = 0, len = elems.length, bulk = key == null;
                    // Sets many values
                    if (toType(key) === "object") {
                        chainable = true;
                        for(i in key)access(elems, fn, i, key[i], true, emptyGet, raw);
                    // Sets one value
                    } else if (value !== undefined) {
                        chainable = true;
                        if (!isFunction(value)) raw = true;
                        if (bulk) {
                            // Bulk operations run against the entire set
                            if (raw) {
                                fn.call(elems, value);
                                fn = null;
                            // ...except when executing function values
                            } else {
                                bulk = fn;
                                fn = function fn(elem, _key, value) {
                                    return bulk.call(jQuery1(elem), value);
                                };
                            }
                        }
                        if (fn) for(; i < len; i++)fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
                    }
                    if (chainable) return elems;
                    // Gets
                    if (bulk) return fn.call(elems);
                    return len ? fn(elems[0], key) : emptyGet;
                };
                // Matches dashed string for camelizing
                var rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g;
                // Used by camelCase as callback to replace()
                function fcamelCase(_all, letter) {
                    return letter.toUpperCase();
                }
                // Convert dashed to camelCase; used by the css and data modules
                // Support: IE <=9 - 11, Edge 12 - 15
                // Microsoft forgot to hump their vendor prefix (trac-9572)
                function camelCase(string) {
                    return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
                }
                var acceptData = function acceptData(owner) {
                    // Accepts only:
                    //  - Node
                    //    - Node.ELEMENT_NODE
                    //    - Node.DOCUMENT_NODE
                    //  - Object
                    //    - Any
                    return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
                };
                function Data() {
                    this.expando = jQuery1.expando + Data.uid++;
                }
                Data.uid = 1;
                Data.prototype = {
                    cache: function cache(owner) {
                        // Check if the owner object already has a cache
                        var value = owner[this.expando];
                        // If not, create one
                        if (!value) {
                            value = {};
                            // We can accept data for non-element nodes in modern browsers,
                            // but we should not, see trac-8335.
                            // Always return an empty object.
                            if (acceptData(owner)) {
                                // If it is a node unlikely to be stringify-ed or looped over
                                // use plain assignment
                                if (owner.nodeType) owner[this.expando] = value;
                                else Object.defineProperty(owner, this.expando, {
                                    value: value,
                                    configurable: true
                                });
                            }
                        }
                        return value;
                    },
                    set: function set(owner, data, value) {
                        var prop, cache = this.cache(owner);
                        // Handle: [ owner, key, value ] args
                        // Always use camelCase key (gh-2257)
                        if (typeof data === "string") cache[camelCase(data)] = value;
                        else // Copy the properties one-by-one to the cache object
                        for(prop in data)cache[camelCase(prop)] = data[prop];
                        return cache;
                    },
                    get: function get(owner, key) {
                        return key === undefined ? this.cache(owner) : // Always use camelCase key (gh-2257)
                        owner[this.expando] && owner[this.expando][camelCase(key)];
                    },
                    access: function access(owner, key, value) {
                        // In cases where either:
                        //
                        //   1. No key was specified
                        //   2. A string key was specified, but no value provided
                        //
                        // Take the "read" path and allow the get method to determine
                        // which value to return, respectively either:
                        //
                        //   1. The entire cache object
                        //   2. The data stored at the key
                        //
                        if (key === undefined || key && typeof key === "string" && value === undefined) return this.get(owner, key);
                        // When the key is not a string, or both a key and value
                        // are specified, set or extend (existing objects) with either:
                        //
                        //   1. An object of properties
                        //   2. A key and value
                        //
                        this.set(owner, key, value);
                        // Since the "set" path can have two possible entry points
                        // return the expected data based on which path was taken[*]
                        return value !== undefined ? value : key;
                    },
                    remove: function remove(owner, key) {
                        var i, cache = owner[this.expando];
                        if (cache === undefined) return;
                        if (key !== undefined) {
                            // Support array or space separated string of keys
                            if (Array.isArray(key)) // If key is an array of keys...
                            // We always set camelCase keys, so remove that.
                            key = key.map(camelCase);
                            else {
                                key = camelCase(key);
                                // If a key with the spaces exists, use it.
                                // Otherwise, create an array by matching non-whitespace
                                key = key in cache ? [
                                    key
                                ] : key.match(rnothtmlwhite) || [];
                            }
                            i = key.length;
                            while(i--)delete cache[key[i]];
                        }
                        // Remove the expando if there's no more data
                        if (key === undefined || jQuery1.isEmptyObject(cache)) {
                            // Support: Chrome <=35 - 45
                            // Webkit & Blink performance suffers when deleting properties
                            // from DOM nodes, so set to undefined instead
                            // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
                            if (owner.nodeType) owner[this.expando] = undefined;
                            else delete owner[this.expando];
                        }
                    },
                    hasData: function hasData(owner) {
                        var cache = owner[this.expando];
                        return cache !== undefined && !jQuery1.isEmptyObject(cache);
                    }
                };
                var dataPriv = new Data();
                var dataUser = new Data();
                //	Implementation Summary
                //
                //	1. Enforce API surface and semantic compatibility with 1.9.x branch
                //	2. Improve the module's maintainability by reducing the storage
                //		paths to a single mechanism.
                //	3. Use the same single mechanism to support "private" and "user" data.
                //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
                //	5. Avoid exposing implementation details on user objects (eg. expando properties)
                //	6. Provide a clear path for implementation upgrade to WeakMap in 2014
                var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
                function getData(data) {
                    if (data === "true") return true;
                    if (data === "false") return false;
                    if (data === "null") return null;
                    // Only convert to a number if it doesn't change the string
                    if (data === +data + "") return +data;
                    if (rbrace.test(data)) return JSON.parse(data);
                    return data;
                }
                function dataAttr(elem, key, data) {
                    var name;
                    // If nothing was found internally, try to fetch any
                    // data from the HTML5 data-* attribute
                    if (data === undefined && elem.nodeType === 1) {
                        name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
                        data = elem.getAttribute(name);
                        if (typeof data === "string") {
                            try {
                                data = getData(data);
                            } catch (e) {}
                            // Make sure we set the data so it isn't changed later
                            dataUser.set(elem, key, data);
                        } else data = undefined;
                    }
                    return data;
                }
                jQuery1.extend({
                    hasData: function hasData(elem) {
                        return dataUser.hasData(elem) || dataPriv.hasData(elem);
                    },
                    data: function data(elem, name, data) {
                        return dataUser.access(elem, name, data);
                    },
                    removeData: function removeData(elem, name) {
                        dataUser.remove(elem, name);
                    },
                    // TODO: Now that all calls to _data and _removeData have been replaced
                    // with direct calls to dataPriv methods, these can be deprecated.
                    _data: function _data(elem, name, data) {
                        return dataPriv.access(elem, name, data);
                    },
                    _removeData: function _removeData(elem, name) {
                        dataPriv.remove(elem, name);
                    }
                });
                jQuery1.fn.extend({
                    data: function data(key, value) {
                        var i, name, data, elem = this[0], attrs = elem && elem.attributes;
                        // Gets all values
                        if (key === undefined) {
                            if (this.length) {
                                data = dataUser.get(elem);
                                if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
                                    i = attrs.length;
                                    while(i--)// Support: IE 11 only
                                    // The attrs elements can be null (trac-14894)
                                    if (attrs[i]) {
                                        name = attrs[i].name;
                                        if (name.indexOf("data-") === 0) {
                                            name = camelCase(name.slice(5));
                                            dataAttr(elem, name, data[name]);
                                        }
                                    }
                                    dataPriv.set(elem, "hasDataAttrs", true);
                                }
                            }
                            return data;
                        }
                        // Sets multiple values
                        if (typeof key === "object") return this.each(function() {
                            dataUser.set(this, key);
                        });
                        return access(this, function(value) {
                            var data;
                            // The calling jQuery object (element matches) is not empty
                            // (and therefore has an element appears at this[ 0 ]) and the
                            // `value` parameter was not undefined. An empty jQuery object
                            // will result in `undefined` for elem = this[ 0 ] which will
                            // throw an exception if an attempt to read a data cache is made.
                            if (elem && value === undefined) {
                                // Attempt to get data from the cache
                                // The key will always be camelCased in Data
                                data = dataUser.get(elem, key);
                                if (data !== undefined) return data;
                                // Attempt to "discover" the data in
                                // HTML5 custom data-* attrs
                                data = dataAttr(elem, key);
                                if (data !== undefined) return data;
                                // We tried really hard, but the data doesn't exist.
                                return;
                            }
                            // Set the data...
                            this.each(function() {
                                // We always store the camelCased key
                                dataUser.set(this, key, value);
                            });
                        }, null, value, arguments.length > 1, null, true);
                    },
                    removeData: function removeData(key) {
                        return this.each(function() {
                            dataUser.remove(this, key);
                        });
                    }
                });
                jQuery1.extend({
                    queue: function queue(elem, type, data) {
                        var queue;
                        if (elem) {
                            type = (type || "fx") + "queue";
                            queue = dataPriv.get(elem, type);
                            // Speed up dequeue by getting out quickly if this is just a lookup
                            if (data) {
                                if (!queue || Array.isArray(data)) queue = dataPriv.access(elem, type, jQuery1.makeArray(data));
                                else queue.push(data);
                            }
                            return queue || [];
                        }
                    },
                    dequeue: function dequeue(elem, type) {
                        type = type || "fx";
                        var queue = jQuery1.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery1._queueHooks(elem, type), next = function next() {
                            jQuery1.dequeue(elem, type);
                        };
                        // If the fx queue is dequeued, always remove the progress sentinel
                        if (fn === "inprogress") {
                            fn = queue.shift();
                            startLength--;
                        }
                        if (fn) {
                            // Add a progress sentinel to prevent the fx queue from being
                            // automatically dequeued
                            if (type === "fx") queue.unshift("inprogress");
                            // Clear up the last queue stop function
                            delete hooks.stop;
                            fn.call(elem, next, hooks);
                        }
                        if (!startLength && hooks) hooks.empty.fire();
                    },
                    // Not public - generate a queueHooks object, or return the current one
                    _queueHooks: function _queueHooks(elem, type) {
                        var key = type + "queueHooks";
                        return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
                            empty: jQuery1.Callbacks("once memory").add(function() {
                                dataPriv.remove(elem, [
                                    type + "queue",
                                    key
                                ]);
                            })
                        });
                    }
                });
                jQuery1.fn.extend({
                    queue: function queue(type, data) {
                        var setter = 2;
                        if (typeof type !== "string") {
                            data = type;
                            type = "fx";
                            setter--;
                        }
                        if (arguments.length < setter) return jQuery1.queue(this[0], type);
                        return data === undefined ? this : this.each(function() {
                            var queue = jQuery1.queue(this, type, data);
                            // Ensure a hooks for this queue
                            jQuery1._queueHooks(this, type);
                            if (type === "fx" && queue[0] !== "inprogress") jQuery1.dequeue(this, type);
                        });
                    },
                    dequeue: function dequeue(type) {
                        return this.each(function() {
                            jQuery1.dequeue(this, type);
                        });
                    },
                    clearQueue: function clearQueue(type) {
                        return this.queue(type || "fx", []);
                    },
                    // Get a promise resolved when queues of a certain type
                    // are emptied (fx is the type by default)
                    promise: function promise(type, obj) {
                        var tmp, count = 1, defer = jQuery1.Deferred(), elements = this, i = this.length, resolve = function resolve() {
                            if (!--count) defer.resolveWith(elements, [
                                elements
                            ]);
                        };
                        if (typeof type !== "string") {
                            obj = type;
                            type = undefined;
                        }
                        type = type || "fx";
                        while(i--){
                            tmp = dataPriv.get(elements[i], type + "queueHooks");
                            if (tmp && tmp.empty) {
                                count++;
                                tmp.empty.add(resolve);
                            }
                        }
                        resolve();
                        return defer.promise(obj);
                    }
                });
                var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
                var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
                var cssExpand = [
                    "Top",
                    "Right",
                    "Bottom",
                    "Left"
                ];
                var documentElement = document1.documentElement;
                var isAttached = function isAttached(elem) {
                    return jQuery1.contains(elem.ownerDocument, elem);
                }, composed = {
                    composed: true
                };
                // Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
                // Check attachment across shadow DOM boundaries when possible (gh-3504)
                // Support: iOS 10.0-10.2 only
                // Early iOS 10 versions support `attachShadow` but not `getRootNode`,
                // leading to errors. We need to check for `getRootNode`.
                if (documentElement.getRootNode) isAttached = function isAttached(elem) {
                    return jQuery1.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
                };
                var isHiddenWithinTree = function isHiddenWithinTree(elem, el) {
                    // isHiddenWithinTree might be called from jQuery#filter function;
                    // in that case, element will be second argument
                    elem = el || elem;
                    // Inline style trumps all
                    return elem.style.display === "none" || elem.style.display === "" && // Otherwise, check computed style
                    // Support: Firefox <=43 - 45
                    // Disconnected elements can have computed display: none, so first confirm that elem is
                    // in the document.
                    isAttached(elem) && jQuery1.css(elem, "display") === "none";
                };
                function adjustCSS(elem, prop, valueParts, tween) {
                    var adjusted, scale, maxIterations = 20, currentValue = tween ? function currentValue() {
                        return tween.cur();
                    } : function() {
                        return jQuery1.css(elem, prop, "");
                    }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery1.cssNumber[prop] ? "" : "px"), // Starting value computation is required for potential unit mismatches
                    initialInUnit = elem.nodeType && (jQuery1.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery1.css(elem, prop));
                    if (initialInUnit && initialInUnit[3] !== unit) {
                        // Support: Firefox <=54
                        // Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
                        initial = initial / 2;
                        // Trust units reported by jQuery.css
                        unit = unit || initialInUnit[3];
                        // Iteratively approximate from a nonzero starting point
                        initialInUnit = +initial || 1;
                        while(maxIterations--){
                            // Evaluate and update our best guess (doubling guesses that zero out).
                            // Finish if the scale equals or crosses 1 (making the old*new product non-positive).
                            jQuery1.style(elem, prop, initialInUnit + unit);
                            if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) maxIterations = 0;
                            initialInUnit = initialInUnit / scale;
                        }
                        initialInUnit = initialInUnit * 2;
                        jQuery1.style(elem, prop, initialInUnit + unit);
                        // Make sure we update the tween properties later on
                        valueParts = valueParts || [];
                    }
                    if (valueParts) {
                        initialInUnit = +initialInUnit || +initial || 0;
                        // Apply relative offset (+=/-=) if specified
                        adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
                        if (tween) {
                            tween.unit = unit;
                            tween.start = initialInUnit;
                            tween.end = adjusted;
                        }
                    }
                    return adjusted;
                }
                var defaultDisplayMap = {};
                function getDefaultDisplay(elem) {
                    var temp, doc = elem.ownerDocument, _$nodeName = elem.nodeName, display = defaultDisplayMap[_$nodeName];
                    if (display) return display;
                    temp = doc.body.appendChild(doc.createElement(_$nodeName));
                    display = jQuery1.css(temp, "display");
                    temp.parentNode.removeChild(temp);
                    if (display === "none") display = "block";
                    defaultDisplayMap[_$nodeName] = display;
                    return display;
                }
                function showHide(elements, show) {
                    var display, elem, values = [], index = 0, length = elements.length;
                    // Determine new display value for elements that need to change
                    for(; index < length; index++){
                        elem = elements[index];
                        if (!elem.style) continue;
                        display = elem.style.display;
                        if (show) {
                            // Since we force visibility upon cascade-hidden elements, an immediate (and slow)
                            // check is required in this first loop unless we have a nonempty display value (either
                            // inline or about-to-be-restored)
                            if (display === "none") {
                                values[index] = dataPriv.get(elem, "display") || null;
                                if (!values[index]) elem.style.display = "";
                            }
                            if (elem.style.display === "" && isHiddenWithinTree(elem)) values[index] = getDefaultDisplay(elem);
                        } else if (display !== "none") {
                            values[index] = "none";
                            // Remember what we're overwriting
                            dataPriv.set(elem, "display", display);
                        }
                    }
                    // Set the display of the elements in a second loop to avoid constant reflow
                    for(index = 0; index < length; index++)if (values[index] != null) elements[index].style.display = values[index];
                    return elements;
                }
                jQuery1.fn.extend({
                    show: function show() {
                        return showHide(this, true);
                    },
                    hide: function hide() {
                        return showHide(this);
                    },
                    toggle: function toggle(state) {
                        if (typeof state === "boolean") return state ? this.show() : this.hide();
                        return this.each(function() {
                            if (isHiddenWithinTree(this)) jQuery1(this).show();
                            else jQuery1(this).hide();
                        });
                    }
                });
                var rcheckableType = /^(?:checkbox|radio)$/i;
                var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
                var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;
                (function() {
                    var fragment = document1.createDocumentFragment(), div = fragment.appendChild(document1.createElement("div")), input = document1.createElement("input");
                    // Support: Android 4.0 - 4.3 only
                    // Check state lost if the name is set (trac-11217)
                    // Support: Windows Web Apps (WWA)
                    // `name` and `type` must use .setAttribute for WWA (trac-14901)
                    input.setAttribute("type", "radio");
                    input.setAttribute("checked", "checked");
                    input.setAttribute("name", "t");
                    div.appendChild(input);
                    // Support: Android <=4.1 only
                    // Older WebKit doesn't clone checked state correctly in fragments
                    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
                    // Support: IE <=11 only
                    // Make sure textarea (and checkbox) defaultValue is properly cloned
                    div.innerHTML = "<textarea>x</textarea>";
                    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
                    // Support: IE <=9 only
                    // IE <=9 replaces <option> tags with their contents when inserted outside of
                    // the select element.
                    div.innerHTML = "<option></option>";
                    support.option = !!div.lastChild;
                })();
                // We have to close these tags to support XHTML (trac-13200)
                var wrapMap = {
                    // XHTML parsers do not magically insert elements in the
                    // same way that tag soup parsers do. So we cannot shorten
                    // this by omitting <tbody> or other required elements.
                    thead: [
                        1,
                        "<table>",
                        "</table>"
                    ],
                    col: [
                        2,
                        "<table><colgroup>",
                        "</colgroup></table>"
                    ],
                    tr: [
                        2,
                        "<table><tbody>",
                        "</tbody></table>"
                    ],
                    td: [
                        3,
                        "<table><tbody><tr>",
                        "</tr></tbody></table>"
                    ],
                    _default: [
                        0,
                        "",
                        ""
                    ]
                };
                wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
                wrapMap.th = wrapMap.td;
                // Support: IE <=9 only
                if (!support.option) wrapMap.optgroup = wrapMap.option = [
                    1,
                    "<select multiple='multiple'>",
                    "</select>"
                ];
                function getAll(context, tag) {
                    // Support: IE <=9 - 11 only
                    // Use typeof to avoid zero-argument method invocation on host objects (trac-15151)
                    var ret;
                    if (typeof context.getElementsByTagName !== "undefined") ret = context.getElementsByTagName(tag || "*");
                    else if (typeof context.querySelectorAll !== "undefined") ret = context.querySelectorAll(tag || "*");
                    else ret = [];
                    if (tag === undefined || tag && nodeName(context, tag)) return jQuery1.merge([
                        context
                    ], ret);
                    return ret;
                }
                // Mark scripts as having already been evaluated
                function setGlobalEval(elems, refElements) {
                    var i = 0, l = elems.length;
                    for(; i < l; i++)dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
                }
                var rhtml = /<|&#?\w+;/;
                function buildFragment(elems, context, scripts, selection, ignored) {
                    var elem, tmp, tag, wrap, attached, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length;
                    for(; i < l; i++){
                        elem = elems[i];
                        if (elem || elem === 0) {
                            // Add nodes directly
                            if (toType(elem) === "object") // Support: Android <=4.0 only, PhantomJS 1 only
                            // push.apply(_, arraylike) throws on ancient WebKit
                            jQuery1.merge(nodes, elem.nodeType ? [
                                elem
                            ] : elem);
                            else if (!rhtml.test(elem)) nodes.push(context.createTextNode(elem));
                            else {
                                tmp = tmp || fragment.appendChild(context.createElement("div"));
                                // Deserialize a standard representation
                                tag = (rtagName.exec(elem) || [
                                    "",
                                    ""
                                ])[1].toLowerCase();
                                wrap = wrapMap[tag] || wrapMap._default;
                                tmp.innerHTML = wrap[1] + jQuery1.htmlPrefilter(elem) + wrap[2];
                                // Descend through wrappers to the right content
                                j = wrap[0];
                                while(j--)tmp = tmp.lastChild;
                                // Support: Android <=4.0 only, PhantomJS 1 only
                                // push.apply(_, arraylike) throws on ancient WebKit
                                jQuery1.merge(nodes, tmp.childNodes);
                                // Remember the top-level container
                                tmp = fragment.firstChild;
                                // Ensure the created nodes are orphaned (trac-12392)
                                tmp.textContent = "";
                            }
                        }
                    }
                    // Remove wrapper from fragment
                    fragment.textContent = "";
                    i = 0;
                    while(elem = nodes[i++]){
                        // Skip elements already in the context collection (trac-4087)
                        if (selection && jQuery1.inArray(elem, selection) > -1) {
                            if (ignored) ignored.push(elem);
                            continue;
                        }
                        attached = isAttached(elem);
                        // Append to fragment
                        tmp = getAll(fragment.appendChild(elem), "script");
                        // Preserve script evaluation history
                        if (attached) setGlobalEval(tmp);
                        // Capture executables
                        if (scripts) {
                            j = 0;
                            while(elem = tmp[j++])if (rscriptType.test(elem.type || "")) scripts.push(elem);
                        }
                    }
                    return fragment;
                }
                var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
                function returnTrue() {
                    return true;
                }
                function returnFalse() {
                    return false;
                }
                function on(elem, types, selector, data, fn, one) {
                    var origFn, type;
                    // Types can be a map of types/handlers
                    if (typeof types === "object") {
                        // ( types-Object, selector, data )
                        if (typeof selector !== "string") {
                            // ( types-Object, data )
                            data = data || selector;
                            selector = undefined;
                        }
                        for(type in types)on(elem, type, selector, data, types[type], one);
                        return elem;
                    }
                    if (data == null && fn == null) {
                        // ( types, fn )
                        fn = selector;
                        data = selector = undefined;
                    } else if (fn == null) {
                        if (typeof selector === "string") {
                            // ( types, selector, fn )
                            fn = data;
                            data = undefined;
                        } else {
                            // ( types, data, fn )
                            fn = data;
                            data = selector;
                            selector = undefined;
                        }
                    }
                    if (fn === false) fn = returnFalse;
                    else if (!fn) return elem;
                    if (one === 1) {
                        origFn = fn;
                        fn = function fn(event) {
                            // Can use an empty set, since event contains the info
                            jQuery1().off(event);
                            return origFn.apply(this, arguments);
                        };
                        // Use same guid so caller can remove using origFn
                        fn.guid = origFn.guid || (origFn.guid = jQuery1.guid++);
                    }
                    return elem.each(function() {
                        jQuery1.event.add(this, types, fn, data, selector);
                    });
                }
                /*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */ jQuery1.event = {
                    global: {},
                    add: function add(elem, types, handler, data, selector) {
                        var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
                        // Only attach events to objects that accept data
                        if (!acceptData(elem)) return;
                        // Caller can pass in an object of custom data in lieu of the handler
                        if (handler.handler) {
                            handleObjIn = handler;
                            handler = handleObjIn.handler;
                            selector = handleObjIn.selector;
                        }
                        // Ensure that invalid selectors throw exceptions at attach time
                        // Evaluate against documentElement in case elem is a non-element node (e.g., document)
                        if (selector) jQuery1.find.matchesSelector(documentElement, selector);
                        // Make sure that the handler has a unique ID, used to find/remove it later
                        if (!handler.guid) handler.guid = jQuery1.guid++;
                        // Init the element's event structure and main handler, if this is the first
                        if (!(events = elemData.events)) events = elemData.events = Object.create(null);
                        if (!(eventHandle = elemData.handle)) eventHandle = elemData.handle = function eventHandle(e) {
                            // Discard the second event of a jQuery.event.trigger() and
                            // when an event is called after a page has unloaded
                            return typeof jQuery1 !== "undefined" && jQuery1.event.triggered !== e.type ? jQuery1.event.dispatch.apply(elem, arguments) : undefined;
                        };
                        // Handle multiple events separated by a space
                        types = (types || "").match(rnothtmlwhite) || [
                            ""
                        ];
                        t = types.length;
                        while(t--){
                            tmp = rtypenamespace.exec(types[t]) || [];
                            type = origType = tmp[1];
                            namespaces = (tmp[2] || "").split(".").sort();
                            // There *must* be a type, no attaching namespace-only handlers
                            if (!type) continue;
                            // If event changes its type, use the special event handlers for the changed type
                            special = jQuery1.event.special[type] || {};
                            // If selector defined, determine special event api type, otherwise given type
                            type = (selector ? special.delegateType : special.bindType) || type;
                            // Update special based on newly reset type
                            special = jQuery1.event.special[type] || {};
                            // handleObj is passed to all event handlers
                            handleObj = jQuery1.extend({
                                type: type,
                                origType: origType,
                                data: data,
                                handler: handler,
                                guid: handler.guid,
                                selector: selector,
                                needsContext: selector && jQuery1.expr.match.needsContext.test(selector),
                                namespace: namespaces.join(".")
                            }, handleObjIn);
                            // Init the event handler queue if we're the first
                            if (!(handlers = events[type])) {
                                handlers = events[type] = [];
                                handlers.delegateCount = 0;
                                // Only use addEventListener if the special events handler returns false
                                if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                                    if (elem.addEventListener) elem.addEventListener(type, eventHandle);
                                }
                            }
                            if (special.add) {
                                special.add.call(elem, handleObj);
                                if (!handleObj.handler.guid) handleObj.handler.guid = handler.guid;
                            }
                            // Add to the element's handler list, delegates in front
                            if (selector) handlers.splice(handlers.delegateCount++, 0, handleObj);
                            else handlers.push(handleObj);
                            // Keep track of which events have ever been used, for event optimization
                            jQuery1.event.global[type] = true;
                        }
                    },
                    // Detach an event or set of events from an element
                    remove: function remove(elem, types, handler, selector, mappedTypes) {
                        var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
                        if (!elemData || !(events = elemData.events)) return;
                        // Once for each type.namespace in types; type may be omitted
                        types = (types || "").match(rnothtmlwhite) || [
                            ""
                        ];
                        t = types.length;
                        while(t--){
                            tmp = rtypenamespace.exec(types[t]) || [];
                            type = origType = tmp[1];
                            namespaces = (tmp[2] || "").split(".").sort();
                            // Unbind all events (on this namespace, if provided) for the element
                            if (!type) {
                                for(type in events)jQuery1.event.remove(elem, type + types[t], handler, selector, true);
                                continue;
                            }
                            special = jQuery1.event.special[type] || {};
                            type = (selector ? special.delegateType : special.bindType) || type;
                            handlers = events[type] || [];
                            tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
                            // Remove matching events
                            origCount = j = handlers.length;
                            while(j--){
                                handleObj = handlers[j];
                                if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                                    handlers.splice(j, 1);
                                    if (handleObj.selector) handlers.delegateCount--;
                                    if (special.remove) special.remove.call(elem, handleObj);
                                }
                            }
                            // Remove generic event handler if we removed something and no more handlers exist
                            // (avoids potential for endless recursion during removal of special event handlers)
                            if (origCount && !handlers.length) {
                                if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) jQuery1.removeEvent(elem, type, elemData.handle);
                                delete events[type];
                            }
                        }
                        // Remove data and the expando if it's no longer used
                        if (jQuery1.isEmptyObject(events)) dataPriv.remove(elem, "handle events");
                    },
                    dispatch: function dispatch(nativeEvent) {
                        var i, j, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length), // Make a writable jQuery.Event from the native event object
                        event = jQuery1.event.fix(nativeEvent), handlers = (dataPriv.get(this, "events") || Object.create(null))[event.type] || [], special = jQuery1.event.special[event.type] || {};
                        // Use the fix-ed jQuery.Event rather than the (read-only) native event
                        args[0] = event;
                        for(i = 1; i < arguments.length; i++)args[i] = arguments[i];
                        event.delegateTarget = this;
                        // Call the preDispatch hook for the mapped type, and let it bail if desired
                        if (special.preDispatch && special.preDispatch.call(this, event) === false) return;
                        // Determine handlers
                        handlerQueue = jQuery1.event.handlers.call(this, event, handlers);
                        // Run delegates first; they may want to stop propagation beneath us
                        i = 0;
                        while((matched = handlerQueue[i++]) && !event.isPropagationStopped()){
                            event.currentTarget = matched.elem;
                            j = 0;
                            while((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped())// If the event is namespaced, then each handler is only invoked if it is
                            // specially universal or its namespaces are a superset of the event's.
                            if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {
                                event.handleObj = handleObj;
                                event.data = handleObj.data;
                                ret = ((jQuery1.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                                if (ret !== undefined) {
                                    if ((event.result = ret) === false) {
                                        event.preventDefault();
                                        event.stopPropagation();
                                    }
                                }
                            }
                        }
                        // Call the postDispatch hook for the mapped type
                        if (special.postDispatch) special.postDispatch.call(this, event);
                        return event.result;
                    },
                    handlers: function handlers(event, handlers) {
                        var i, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
                        // Find delegate handlers
                        if (delegateCount && // Support: IE <=9
                        // Black-hole SVG <use> instance trees (trac-13180)
                        cur.nodeType && // Support: Firefox <=42
                        // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
                        // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
                        // Support: IE 11 only
                        // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
                        !(event.type === "click" && event.button >= 1)) {
                            for(; cur !== this; cur = cur.parentNode || this)// Don't check non-elements (trac-13208)
                            // Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)
                            if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
                                matchedHandlers = [];
                                matchedSelectors = {};
                                for(i = 0; i < delegateCount; i++){
                                    handleObj = handlers[i];
                                    // Don't conflict with Object.prototype properties (trac-13203)
                                    sel = handleObj.selector + " ";
                                    if (matchedSelectors[sel] === undefined) matchedSelectors[sel] = handleObj.needsContext ? jQuery1(sel, this).index(cur) > -1 : jQuery1.find(sel, this, null, [
                                        cur
                                    ]).length;
                                    if (matchedSelectors[sel]) matchedHandlers.push(handleObj);
                                }
                                if (matchedHandlers.length) handlerQueue.push({
                                    elem: cur,
                                    handlers: matchedHandlers
                                });
                            }
                        }
                        // Add the remaining (directly-bound) handlers
                        cur = this;
                        if (delegateCount < handlers.length) handlerQueue.push({
                            elem: cur,
                            handlers: handlers.slice(delegateCount)
                        });
                        return handlerQueue;
                    },
                    addProp: function addProp(name, hook) {
                        Object.defineProperty(jQuery1.Event.prototype, name, {
                            enumerable: true,
                            configurable: true,
                            get: isFunction(hook) ? function() {
                                if (this.originalEvent) return hook(this.originalEvent);
                            } : function() {
                                if (this.originalEvent) return this.originalEvent[name];
                            },
                            set: function set(value) {
                                Object.defineProperty(this, name, {
                                    enumerable: true,
                                    configurable: true,
                                    writable: true,
                                    value: value
                                });
                            }
                        });
                    },
                    fix: function fix(originalEvent) {
                        return originalEvent[jQuery1.expando] ? originalEvent : new jQuery1.Event(originalEvent);
                    },
                    special: {
                        load: {
                            // Prevent triggered image.load events from bubbling to window.load
                            noBubble: true
                        },
                        click: {
                            // Utilize native event to ensure correct state for checkable inputs
                            setup: function setup(data) {
                                // For mutual compressibility with _default, replace `this` access with a local var.
                                // `|| data` is dead code meant only to preserve the variable through minification.
                                var el = this || data;
                                // Claim the first handler
                                if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) // dataPriv.set( el, "click", ... )
                                leverageNative(el, "click", true);
                                // Return false to allow normal processing in the caller
                                return false;
                            },
                            trigger: function trigger(data) {
                                // For mutual compressibility with _default, replace `this` access with a local var.
                                // `|| data` is dead code meant only to preserve the variable through minification.
                                var el = this || data;
                                // Force setup before triggering a click
                                if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) leverageNative(el, "click");
                                // Return non-false to allow normal event-path propagation
                                return true;
                            },
                            // For cross-browser consistency, suppress native .click() on links
                            // Also prevent it if we're currently inside a leveraged native-event stack
                            _default: function _default(event) {
                                var target = event.target;
                                return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
                            }
                        },
                        beforeunload: {
                            postDispatch: function postDispatch(event) {
                                // Support: Firefox 20+
                                // Firefox doesn't alert if the returnValue field is not set.
                                if (event.result !== undefined && event.originalEvent) event.originalEvent.returnValue = event.result;
                            }
                        }
                    }
                };
                // Ensure the presence of an event listener that handles manually-triggered
                // synthetic events by interrupting progress until reinvoked in response to
                // *native* events that it fires directly, ensuring that state changes have
                // already occurred before other listeners are invoked.
                function leverageNative(el, type, isSetup) {
                    // Missing `isSetup` indicates a trigger call, which must force setup through jQuery.event.add
                    if (!isSetup) {
                        if (dataPriv.get(el, type) === undefined) jQuery1.event.add(el, type, returnTrue);
                        return;
                    }
                    // Register the controller as a special universal handler for all event namespaces
                    dataPriv.set(el, type, false);
                    jQuery1.event.add(el, type, {
                        namespace: false,
                        handler: function handler(event) {
                            var result, saved = dataPriv.get(this, type);
                            if (event.isTrigger & 1 && this[type]) {
                                // Interrupt processing of the outer synthetic .trigger()ed event
                                if (!saved) {
                                    // Store arguments for use when handling the inner native event
                                    // There will always be at least one argument (an event object), so this array
                                    // will not be confused with a leftover capture object.
                                    saved = slice.call(arguments);
                                    dataPriv.set(this, type, saved);
                                    // Trigger the native event and capture its result
                                    this[type]();
                                    result = dataPriv.get(this, type);
                                    dataPriv.set(this, type, false);
                                    if (saved !== result) {
                                        // Cancel the outer synthetic event
                                        event.stopImmediatePropagation();
                                        event.preventDefault();
                                        return result;
                                    }
                                // If this is an inner synthetic event for an event with a bubbling surrogate
                                // (focus or blur), assume that the surrogate already propagated from triggering
                                // the native event and prevent that from happening again here.
                                // This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
                                // bubbling surrogate propagates *after* the non-bubbling base), but that seems
                                // less bad than duplication.
                                } else if ((jQuery1.event.special[type] || {}).delegateType) event.stopPropagation();
                            // If this is a native event triggered above, everything is now in order
                            // Fire an inner synthetic event with the original arguments
                            } else if (saved) {
                                // ...and capture the result
                                dataPriv.set(this, type, jQuery1.event.trigger(saved[0], saved.slice(1), this));
                                // Abort handling of the native event by all jQuery handlers while allowing
                                // native handlers on the same element to run. On target, this is achieved
                                // by stopping immediate propagation just on the jQuery event. However,
                                // the native event is re-wrapped by a jQuery one on each level of the
                                // propagation so the only way to stop it for jQuery is to stop it for
                                // everyone via native `stopPropagation()`. This is not a problem for
                                // focus/blur which don't bubble, but it does also stop click on checkboxes
                                // and radios. We accept this limitation.
                                event.stopPropagation();
                                event.isImmediatePropagationStopped = returnTrue;
                            }
                        }
                    });
                }
                jQuery1.removeEvent = function(elem, type, handle) {
                    // This "if" is needed for plain objects
                    if (elem.removeEventListener) elem.removeEventListener(type, handle);
                };
                jQuery1.Event = function(src, props) {
                    // Allow instantiation without the 'new' keyword
                    if (!(this instanceof jQuery1.Event)) return new jQuery1.Event(src, props);
                    // Event object
                    if (src && src.type) {
                        this.originalEvent = src;
                        this.type = src.type;
                        // Events bubbling up the document may have been marked as prevented
                        // by a handler lower down the tree; reflect the correct value.
                        this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && // Support: Android <=2.3 only
                        src.returnValue === false ? returnTrue : returnFalse;
                        // Create target properties
                        // Support: Safari <=6 - 7 only
                        // Target should not be a text node (trac-504, trac-13143)
                        this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
                        this.currentTarget = src.currentTarget;
                        this.relatedTarget = src.relatedTarget;
                    // Event type
                    } else this.type = src;
                    // Put explicitly provided properties onto the event object
                    if (props) jQuery1.extend(this, props);
                    // Create a timestamp if incoming event doesn't have one
                    this.timeStamp = src && src.timeStamp || Date.now();
                    // Mark it as fixed
                    this[jQuery1.expando] = true;
                };
                // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
                // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
                jQuery1.Event.prototype = {
                    constructor: jQuery1.Event,
                    isDefaultPrevented: returnFalse,
                    isPropagationStopped: returnFalse,
                    isImmediatePropagationStopped: returnFalse,
                    isSimulated: false,
                    preventDefault: function preventDefault() {
                        var e = this.originalEvent;
                        this.isDefaultPrevented = returnTrue;
                        if (e && !this.isSimulated) e.preventDefault();
                    },
                    stopPropagation: function stopPropagation() {
                        var e = this.originalEvent;
                        this.isPropagationStopped = returnTrue;
                        if (e && !this.isSimulated) e.stopPropagation();
                    },
                    stopImmediatePropagation: function stopImmediatePropagation() {
                        var e = this.originalEvent;
                        this.isImmediatePropagationStopped = returnTrue;
                        if (e && !this.isSimulated) e.stopImmediatePropagation();
                        this.stopPropagation();
                    }
                };
                // Includes all common event props including KeyEvent and MouseEvent specific props
                jQuery1.each({
                    altKey: true,
                    bubbles: true,
                    cancelable: true,
                    changedTouches: true,
                    ctrlKey: true,
                    detail: true,
                    eventPhase: true,
                    metaKey: true,
                    pageX: true,
                    pageY: true,
                    shiftKey: true,
                    view: true,
                    "char": true,
                    code: true,
                    charCode: true,
                    key: true,
                    keyCode: true,
                    button: true,
                    buttons: true,
                    clientX: true,
                    clientY: true,
                    offsetX: true,
                    offsetY: true,
                    pointerId: true,
                    pointerType: true,
                    screenX: true,
                    screenY: true,
                    targetTouches: true,
                    toElement: true,
                    touches: true,
                    which: true
                }, jQuery1.event.addProp);
                jQuery1.each({
                    focus: "focusin",
                    blur: "focusout"
                }, function(type, delegateType) {
                    function focusMappedHandler(nativeEvent) {
                        if (document1.documentMode) {
                            // Support: IE 11+
                            // Attach a single focusin/focusout handler on the document while someone wants
                            // focus/blur. This is because the former are synchronous in IE while the latter
                            // are async. In other browsers, all those handlers are invoked synchronously.
                            // `handle` from private data would already wrap the event, but we need
                            // to change the `type` here.
                            var handle = dataPriv.get(this, "handle"), event = jQuery1.event.fix(nativeEvent);
                            event.type = nativeEvent.type === "focusin" ? "focus" : "blur";
                            event.isSimulated = true;
                            // First, handle focusin/focusout
                            handle(nativeEvent);
                            // ...then, handle focus/blur
                            //
                            // focus/blur don't bubble while focusin/focusout do; simulate the former by only
                            // invoking the handler at the lower level.
                            if (event.target === event.currentTarget) // The setup part calls `leverageNative`, which, in turn, calls
                            // `jQuery.event.add`, so event handle will already have been set
                            // by this point.
                            handle(event);
                        } else // For non-IE browsers, attach a single capturing handler on the document
                        // while someone wants focusin/focusout.
                        jQuery1.event.simulate(delegateType, nativeEvent.target, jQuery1.event.fix(nativeEvent));
                    }
                    jQuery1.event.special[type] = {
                        // Utilize native event if possible so blur/focus sequence is correct
                        setup: function setup() {
                            var attaches;
                            // Claim the first handler
                            // dataPriv.set( this, "focus", ... )
                            // dataPriv.set( this, "blur", ... )
                            leverageNative(this, type, true);
                            if (document1.documentMode) {
                                // Support: IE 9 - 11+
                                // We use the same native handler for focusin & focus (and focusout & blur)
                                // so we need to coordinate setup & teardown parts between those events.
                                // Use `delegateType` as the key as `type` is already used by `leverageNative`.
                                attaches = dataPriv.get(this, delegateType);
                                if (!attaches) this.addEventListener(delegateType, focusMappedHandler);
                                dataPriv.set(this, delegateType, (attaches || 0) + 1);
                            } else // Return false to allow normal processing in the caller
                            return false;
                        },
                        trigger: function trigger() {
                            // Force setup before trigger
                            leverageNative(this, type);
                            // Return non-false to allow normal event-path propagation
                            return true;
                        },
                        teardown: function teardown() {
                            var attaches;
                            if (document1.documentMode) {
                                attaches = dataPriv.get(this, delegateType) - 1;
                                if (!attaches) {
                                    this.removeEventListener(delegateType, focusMappedHandler);
                                    dataPriv.remove(this, delegateType);
                                } else dataPriv.set(this, delegateType, attaches);
                            } else // Return false to indicate standard teardown should be applied
                            return false;
                        },
                        // Suppress native focus or blur if we're currently inside
                        // a leveraged native-event stack
                        _default: function _default(event) {
                            return dataPriv.get(event.target, type);
                        },
                        delegateType: delegateType
                    };
                    // Support: Firefox <=44
                    // Firefox doesn't have focus(in | out) events
                    // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
                    //
                    // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
                    // focus(in | out) events fire after focus & blur events,
                    // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
                    // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
                    //
                    // Support: IE 9 - 11+
                    // To preserve relative focusin/focus & focusout/blur event order guaranteed on the 3.x branch,
                    // attach a single handler for both events in IE.
                    jQuery1.event.special[delegateType] = {
                        setup: function setup() {
                            // Handle: regular nodes (via `this.ownerDocument`), window
                            // (via `this.document`) & document (via `this`).
                            var doc = this.ownerDocument || this.document || this, dataHolder = document1.documentMode ? this : doc, attaches = dataPriv.get(dataHolder, delegateType);
                            // Support: IE 9 - 11+
                            // We use the same native handler for focusin & focus (and focusout & blur)
                            // so we need to coordinate setup & teardown parts between those events.
                            // Use `delegateType` as the key as `type` is already used by `leverageNative`.
                            if (!attaches) {
                                if (document1.documentMode) this.addEventListener(delegateType, focusMappedHandler);
                                else doc.addEventListener(type, focusMappedHandler, true);
                            }
                            dataPriv.set(dataHolder, delegateType, (attaches || 0) + 1);
                        },
                        teardown: function teardown() {
                            var doc = this.ownerDocument || this.document || this, dataHolder = document1.documentMode ? this : doc, attaches = dataPriv.get(dataHolder, delegateType) - 1;
                            if (!attaches) {
                                if (document1.documentMode) this.removeEventListener(delegateType, focusMappedHandler);
                                else doc.removeEventListener(type, focusMappedHandler, true);
                                dataPriv.remove(dataHolder, delegateType);
                            } else dataPriv.set(dataHolder, delegateType, attaches);
                        }
                    };
                });
                // Create mouseenter/leave events using mouseover/out and event-time checks
                // so that event delegation works in jQuery.
                // Do the same for pointerenter/pointerleave and pointerover/pointerout
                //
                // Support: Safari 7 only
                // Safari sends mouseenter too often; see:
                // https://bugs.chromium.org/p/chromium/issues/detail?id=470258
                // for the description of the bug (it existed in older Chrome versions as well).
                jQuery1.each({
                    mouseenter: "mouseover",
                    mouseleave: "mouseout",
                    pointerenter: "pointerover",
                    pointerleave: "pointerout"
                }, function(orig, fix) {
                    jQuery1.event.special[orig] = {
                        delegateType: fix,
                        bindType: fix,
                        handle: function handle(event) {
                            var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
                            // For mouseenter/leave call the handler if related is outside the target.
                            // NB: No relatedTarget if the mouse left/entered the browser window
                            if (!related || related !== target && !jQuery1.contains(target, related)) {
                                event.type = handleObj.origType;
                                ret = handleObj.handler.apply(this, arguments);
                                event.type = fix;
                            }
                            return ret;
                        }
                    };
                });
                jQuery1.fn.extend({
                    on: function on1(types, selector, data, fn) {
                        return on(this, types, selector, data, fn);
                    },
                    one: function one(types, selector, data, fn) {
                        return on(this, types, selector, data, fn, 1);
                    },
                    off: function off(types, selector, fn) {
                        var handleObj, type;
                        if (types && types.preventDefault && types.handleObj) {
                            // ( event )  dispatched jQuery.Event
                            handleObj = types.handleObj;
                            jQuery1(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
                            return this;
                        }
                        if (typeof types === "object") {
                            // ( types-object [, selector] )
                            for(type in types)this.off(type, selector, types[type]);
                            return this;
                        }
                        if (selector === false || typeof selector === "function") {
                            // ( types [, fn] )
                            fn = selector;
                            selector = undefined;
                        }
                        if (fn === false) fn = returnFalse;
                        return this.each(function() {
                            jQuery1.event.remove(this, types, fn, selector);
                        });
                    }
                });
                var // Support: IE <=10 - 11, Edge 12 - 13 only
                // In IE/Edge using regex groups here causes severe slowdowns.
                // See https://connect.microsoft.com/IE/feedback/details/1736512/
                rnoInnerhtml = /<script|<style|<link/i, // checked="checked" or checked
                rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;
                // Prefer a tbody over its parent table for containing new rows
                function manipulationTarget(elem, content) {
                    if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) return jQuery1(elem).children("tbody")[0] || elem;
                    return elem;
                }
                // Replace/restore the type attribute of script elements for safe DOM manipulation
                function disableScript(elem) {
                    elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
                    return elem;
                }
                function restoreScript(elem) {
                    if ((elem.type || "").slice(0, 5) === "true/") elem.type = elem.type.slice(5);
                    else elem.removeAttribute("type");
                    return elem;
                }
                function cloneCopyEvent(src, dest) {
                    var i, l, type, pdataOld, udataOld, udataCur, events;
                    if (dest.nodeType !== 1) return;
                    // 1. Copy private data: events, handlers, etc.
                    if (dataPriv.hasData(src)) {
                        pdataOld = dataPriv.get(src);
                        events = pdataOld.events;
                        if (events) {
                            dataPriv.remove(dest, "handle events");
                            for(type in events)for(i = 0, l = events[type].length; i < l; i++)jQuery1.event.add(dest, type, events[type][i]);
                        }
                    }
                    // 2. Copy user data
                    if (dataUser.hasData(src)) {
                        udataOld = dataUser.access(src);
                        udataCur = jQuery1.extend({}, udataOld);
                        dataUser.set(dest, udataCur);
                    }
                }
                // Fix IE bugs, see support tests
                function fixInput(src, dest) {
                    var _$nodeName = dest.nodeName.toLowerCase();
                    // Fails to persist the checked state of a cloned checkbox or radio button.
                    if (_$nodeName === "input" && rcheckableType.test(src.type)) dest.checked = src.checked;
                    else if (_$nodeName === "input" || _$nodeName === "textarea") dest.defaultValue = src.defaultValue;
                }
                function domManip(collection, args, callback, ignored) {
                    // Flatten any nested arrays
                    args = flat(args);
                    var fragment, first, scripts, hasScripts, node, doc, i = 0, l = collection.length, iNoClone = l - 1, value = args[0], valueIsFunction = isFunction(value);
                    // We can't cloneNode fragments that contain checked, in WebKit
                    if (valueIsFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) return collection.each(function(index) {
                        var self1 = collection.eq(index);
                        if (valueIsFunction) args[0] = value.call(this, index, self1.html());
                        domManip(self1, args, callback, ignored);
                    });
                    if (l) {
                        fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
                        first = fragment.firstChild;
                        if (fragment.childNodes.length === 1) fragment = first;
                        // Require either new content or an interest in ignored elements to invoke the callback
                        if (first || ignored) {
                            scripts = jQuery1.map(getAll(fragment, "script"), disableScript);
                            hasScripts = scripts.length;
                            // Use the original fragment for the last item
                            // instead of the first because it can end up
                            // being emptied incorrectly in certain situations (trac-8070).
                            for(; i < l; i++){
                                node = fragment;
                                if (i !== iNoClone) {
                                    node = jQuery1.clone(node, true, true);
                                    // Keep references to cloned scripts for later restoration
                                    if (hasScripts) // Support: Android <=4.0 only, PhantomJS 1 only
                                    // push.apply(_, arraylike) throws on ancient WebKit
                                    jQuery1.merge(scripts, getAll(node, "script"));
                                }
                                callback.call(collection[i], node, i);
                            }
                            if (hasScripts) {
                                doc = scripts[scripts.length - 1].ownerDocument;
                                // Re-enable scripts
                                jQuery1.map(scripts, restoreScript);
                                // Evaluate executable scripts on first document insertion
                                for(i = 0; i < hasScripts; i++){
                                    node = scripts[i];
                                    if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery1.contains(doc, node)) {
                                        if (node.src && (node.type || "").toLowerCase() !== "module") // Optional AJAX dependency, but won't run scripts if not present
                                        {
                                            if (jQuery1._evalUrl && !node.noModule) jQuery1._evalUrl(node.src, {
                                                nonce: node.nonce || node.getAttribute("nonce")
                                            }, doc);
                                        } else // Unwrap a CDATA section containing script contents. This shouldn't be
                                        // needed as in XML documents they're already not visible when
                                        // inspecting element contents and in HTML documents they have no
                                        // meaning but we're preserving that logic for backwards compatibility.
                                        // This will be removed completely in 4.0. See gh-4904.
                                        DOMEval(node.textContent.replace(rcleanScript, ""), node, doc);
                                    }
                                }
                            }
                        }
                    }
                    return collection;
                }
                function remove(elem, selector, keepData) {
                    var node, nodes = selector ? jQuery1.filter(selector, elem) : elem, i = 0;
                    for(; (node = nodes[i]) != null; i++){
                        if (!keepData && node.nodeType === 1) jQuery1.cleanData(getAll(node));
                        if (node.parentNode) {
                            if (keepData && isAttached(node)) setGlobalEval(getAll(node, "script"));
                            node.parentNode.removeChild(node);
                        }
                    }
                    return elem;
                }
                jQuery1.extend({
                    htmlPrefilter: function htmlPrefilter(html) {
                        return html;
                    },
                    clone: function clone(elem, dataAndEvents, deepDataAndEvents) {
                        var i, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = isAttached(elem);
                        // Fix IE cloning issues
                        if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery1.isXMLDoc(elem)) {
                            // We eschew jQuery#find here for performance reasons:
                            // https://jsperf.com/getall-vs-sizzle/2
                            destElements = getAll(clone);
                            srcElements = getAll(elem);
                            for(i = 0, l = srcElements.length; i < l; i++)fixInput(srcElements[i], destElements[i]);
                        }
                        // Copy the events from the original to the clone
                        if (dataAndEvents) {
                            if (deepDataAndEvents) {
                                srcElements = srcElements || getAll(elem);
                                destElements = destElements || getAll(clone);
                                for(i = 0, l = srcElements.length; i < l; i++)cloneCopyEvent(srcElements[i], destElements[i]);
                            } else cloneCopyEvent(elem, clone);
                        }
                        // Preserve script evaluation history
                        destElements = getAll(clone, "script");
                        if (destElements.length > 0) setGlobalEval(destElements, !inPage && getAll(elem, "script"));
                        // Return the cloned set
                        return clone;
                    },
                    cleanData: function cleanData(elems) {
                        var data, elem, type, special = jQuery1.event.special, i = 0;
                        for(; (elem = elems[i]) !== undefined; i++)if (acceptData(elem)) {
                            if (data = elem[dataPriv.expando]) {
                                if (data.events) {
                                    for(type in data.events)if (special[type]) jQuery1.event.remove(elem, type);
                                    else jQuery1.removeEvent(elem, type, data.handle);
                                }
                                // Support: Chrome <=35 - 45+
                                // Assign undefined instead of using delete, see Data#remove
                                elem[dataPriv.expando] = undefined;
                            }
                            if (elem[dataUser.expando]) // Support: Chrome <=35 - 45+
                            // Assign undefined instead of using delete, see Data#remove
                            elem[dataUser.expando] = undefined;
                        }
                    }
                });
                jQuery1.fn.extend({
                    detach: function detach(selector) {
                        return remove(this, selector, true);
                    },
                    remove: function remove1(selector) {
                        return remove(this, selector);
                    },
                    text: function text(value) {
                        return access(this, function(value) {
                            return value === undefined ? jQuery1.text(this) : this.empty().each(function() {
                                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) this.textContent = value;
                            });
                        }, null, value, arguments.length);
                    },
                    append: function append() {
                        return domManip(this, arguments, function(elem) {
                            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                                var target = manipulationTarget(this, elem);
                                target.appendChild(elem);
                            }
                        });
                    },
                    prepend: function prepend() {
                        return domManip(this, arguments, function(elem) {
                            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                                var target = manipulationTarget(this, elem);
                                target.insertBefore(elem, target.firstChild);
                            }
                        });
                    },
                    before: function before() {
                        return domManip(this, arguments, function(elem) {
                            if (this.parentNode) this.parentNode.insertBefore(elem, this);
                        });
                    },
                    after: function after() {
                        return domManip(this, arguments, function(elem) {
                            if (this.parentNode) this.parentNode.insertBefore(elem, this.nextSibling);
                        });
                    },
                    empty: function empty() {
                        var elem, i = 0;
                        for(; (elem = this[i]) != null; i++)if (elem.nodeType === 1) {
                            // Prevent memory leaks
                            jQuery1.cleanData(getAll(elem, false));
                            // Remove any remaining nodes
                            elem.textContent = "";
                        }
                        return this;
                    },
                    clone: function clone(dataAndEvents, deepDataAndEvents) {
                        dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
                        deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
                        return this.map(function() {
                            return jQuery1.clone(this, dataAndEvents, deepDataAndEvents);
                        });
                    },
                    html: function html(value) {
                        return access(this, function(value) {
                            var elem = this[0] || {}, i = 0, l = this.length;
                            if (value === undefined && elem.nodeType === 1) return elem.innerHTML;
                            // See if we can take a shortcut and just use innerHTML
                            if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [
                                "",
                                ""
                            ])[1].toLowerCase()]) {
                                value = jQuery1.htmlPrefilter(value);
                                try {
                                    for(; i < l; i++){
                                        elem = this[i] || {};
                                        // Remove element nodes and prevent memory leaks
                                        if (elem.nodeType === 1) {
                                            jQuery1.cleanData(getAll(elem, false));
                                            elem.innerHTML = value;
                                        }
                                    }
                                    elem = 0;
                                // If using innerHTML throws an exception, use the fallback method
                                } catch (e) {}
                            }
                            if (elem) this.empty().append(value);
                        }, null, value, arguments.length);
                    },
                    replaceWith: function replaceWith() {
                        var ignored = [];
                        // Make the changes, replacing each non-ignored context element with the new content
                        return domManip(this, arguments, function(elem) {
                            var parent = this.parentNode;
                            if (jQuery1.inArray(this, ignored) < 0) {
                                jQuery1.cleanData(getAll(this));
                                if (parent) parent.replaceChild(elem, this);
                            }
                        // Force callback invocation
                        }, ignored);
                    }
                });
                jQuery1.each({
                    appendTo: "append",
                    prependTo: "prepend",
                    insertBefore: "before",
                    insertAfter: "after",
                    replaceAll: "replaceWith"
                }, function(name, original) {
                    jQuery1.fn[name] = function(selector) {
                        var elems, ret = [], insert = jQuery1(selector), last = insert.length - 1, i = 0;
                        for(; i <= last; i++){
                            elems = i === last ? this : this.clone(true);
                            jQuery1(insert[i])[original](elems);
                            // Support: Android <=4.0 only, PhantomJS 1 only
                            // .get() because push.apply(_, arraylike) throws on ancient WebKit
                            push.apply(ret, elems.get());
                        }
                        return this.pushStack(ret);
                    };
                });
                var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
                var rcustomProp = /^--/;
                var getStyles = function getStyles(elem) {
                    // Support: IE <=11 only, Firefox <=30 (trac-15098, trac-14150)
                    // IE throws on elements created in popups
                    // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
                    var view = elem.ownerDocument.defaultView;
                    if (!view || !view.opener) view = window1;
                    return view.getComputedStyle(elem);
                };
                var swap = function swap(elem, options, callback) {
                    var ret, name, old = {};
                    // Remember the old values, and insert the new ones
                    for(name in options){
                        old[name] = elem.style[name];
                        elem.style[name] = options[name];
                    }
                    ret = callback.call(elem);
                    // Revert the old values
                    for(name in options)elem.style[name] = old[name];
                    return ret;
                };
                var rboxStyle = new RegExp(cssExpand.join("|"), "i");
                (function() {
                    // Executing both pixelPosition & boxSizingReliable tests require only one layout
                    // so they're executed at the same time to save the second computation.
                    function computeStyleTests() {
                        // This is a singleton, we need to execute it only once
                        if (!div) return;
                        container.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0";
                        div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%";
                        documentElement.appendChild(container).appendChild(div);
                        var divStyle = window1.getComputedStyle(div);
                        pixelPositionVal = divStyle.top !== "1%";
                        // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
                        reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
                        // Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
                        // Some styles come back with percentage values, even though they shouldn't
                        div.style.right = "60%";
                        pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
                        // Support: IE 9 - 11 only
                        // Detect misreporting of content dimensions for box-sizing:border-box elements
                        boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
                        // Support: IE 9 only
                        // Detect overflow:scroll screwiness (gh-3699)
                        // Support: Chrome <=64
                        // Don't get tricked when zoom affects offsetWidth (gh-4029)
                        div.style.position = "absolute";
                        scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
                        documentElement.removeChild(container);
                        // Nullify the div so it wouldn't be stored in the memory and
                        // it will also be a sign that checks already performed
                        div = null;
                    }
                    function roundPixelMeasures(measure) {
                        return Math.round(parseFloat(measure));
                    }
                    var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableTrDimensionsVal, reliableMarginLeftVal, container = document1.createElement("div"), div = document1.createElement("div");
                    // Finish early in limited (non-browser) environments
                    if (!div.style) return;
                    // Support: IE <=9 - 11 only
                    // Style of cloned element affects source element cloned (trac-8908)
                    div.style.backgroundClip = "content-box";
                    div.cloneNode(true).style.backgroundClip = "";
                    support.clearCloneStyle = div.style.backgroundClip === "content-box";
                    jQuery1.extend(support, {
                        boxSizingReliable: function boxSizingReliable() {
                            computeStyleTests();
                            return boxSizingReliableVal;
                        },
                        pixelBoxStyles: function pixelBoxStyles() {
                            computeStyleTests();
                            return pixelBoxStylesVal;
                        },
                        pixelPosition: function pixelPosition() {
                            computeStyleTests();
                            return pixelPositionVal;
                        },
                        reliableMarginLeft: function reliableMarginLeft() {
                            computeStyleTests();
                            return reliableMarginLeftVal;
                        },
                        scrollboxSize: function scrollboxSize() {
                            computeStyleTests();
                            return scrollboxSizeVal;
                        },
                        // Support: IE 9 - 11+, Edge 15 - 18+
                        // IE/Edge misreport `getComputedStyle` of table rows with width/height
                        // set in CSS while `offset*` properties report correct values.
                        // Behavior in IE 9 is more subtle than in newer versions & it passes
                        // some versions of this test; make sure not to make it pass there!
                        //
                        // Support: Firefox 70+
                        // Only Firefox includes border widths
                        // in computed dimensions. (gh-4529)
                        reliableTrDimensions: function reliableTrDimensions() {
                            var table, tr, trChild, trStyle;
                            if (reliableTrDimensionsVal == null) {
                                table = document1.createElement("table");
                                tr = document1.createElement("tr");
                                trChild = document1.createElement("div");
                                table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
                                tr.style.cssText = "box-sizing:content-box;border:1px solid";
                                // Support: Chrome 86+
                                // Height set through cssText does not get applied.
                                // Computed height then comes back as 0.
                                tr.style.height = "1px";
                                trChild.style.height = "9px";
                                // Support: Android 8 Chrome 86+
                                // In our bodyBackground.html iframe,
                                // display for all div elements is set to "inline",
                                // which causes a problem only in Android 8 Chrome 86.
                                // Ensuring the div is `display: block`
                                // gets around this issue.
                                trChild.style.display = "block";
                                documentElement.appendChild(table).appendChild(tr).appendChild(trChild);
                                trStyle = window1.getComputedStyle(tr);
                                reliableTrDimensionsVal = parseInt(trStyle.height, 10) + parseInt(trStyle.borderTopWidth, 10) + parseInt(trStyle.borderBottomWidth, 10) === tr.offsetHeight;
                                documentElement.removeChild(table);
                            }
                            return reliableTrDimensionsVal;
                        }
                    });
                })();
                function curCSS(elem, name, computed) {
                    var width, minWidth, maxWidth, ret, isCustomProp = rcustomProp.test(name), // Support: Firefox 51+
                    // Retrieving style before computed somehow
                    // fixes an issue with getting wrong values
                    // on detached elements
                    style = elem.style;
                    computed = computed || getStyles(elem);
                    // getPropertyValue is needed for:
                    //   .css('filter') (IE 9 only, trac-12537)
                    //   .css('--customProperty) (gh-3144)
                    if (computed) {
                        // Support: IE <=9 - 11+
                        // IE only supports `"float"` in `getPropertyValue`; in computed styles
                        // it's only available as `"cssFloat"`. We no longer modify properties
                        // sent to `.css()` apart from camelCasing, so we need to check both.
                        // Normally, this would create difference in behavior: if
                        // `getPropertyValue` returns an empty string, the value returned
                        // by `.css()` would be `undefined`. This is usually the case for
                        // disconnected elements. However, in IE even disconnected elements
                        // with no styles return `"none"` for `getPropertyValue( "float" )`
                        ret = computed.getPropertyValue(name) || computed[name];
                        if (isCustomProp && ret) // Support: Firefox 105+, Chrome <=105+
                        // Spec requires trimming whitespace for custom properties (gh-4926).
                        // Firefox only trims leading whitespace. Chrome just collapses
                        // both leading & trailing whitespace to a single space.
                        //
                        // Fall back to `undefined` if empty string returned.
                        // This collapses a missing definition with property defined
                        // and set to an empty string but there's no standard API
                        // allowing us to differentiate them without a performance penalty
                        // and returning `undefined` aligns with older jQuery.
                        //
                        // rtrimCSS treats U+000D CARRIAGE RETURN and U+000C FORM FEED
                        // as whitespace while CSS does not, but this is not a problem
                        // because CSS preprocessing replaces them with U+000A LINE FEED
                        // (which *is* CSS whitespace)
                        // https://www.w3.org/TR/css-syntax-3/#input-preprocessing
                        ret = ret.replace(rtrimCSS, "$1") || undefined;
                        if (ret === "" && !isAttached(elem)) ret = jQuery1.style(elem, name);
                        // A tribute to the "awesome hack by Dean Edwards"
                        // Android Browser returns percentage for some values,
                        // but width seems to be reliably pixels.
                        // This is against the CSSOM draft spec:
                        // https://drafts.csswg.org/cssom/#resolved-values
                        if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
                            // Remember the original values
                            width = style.width;
                            minWidth = style.minWidth;
                            maxWidth = style.maxWidth;
                            // Put in the new values to get a computed value out
                            style.minWidth = style.maxWidth = style.width = ret;
                            ret = computed.width;
                            // Revert the changed values
                            style.width = width;
                            style.minWidth = minWidth;
                            style.maxWidth = maxWidth;
                        }
                    }
                    return ret !== undefined ? // Support: IE <=9 - 11 only
                    // IE returns zIndex value as an integer.
                    ret + "" : ret;
                }
                function addGetHookIf(conditionFn, hookFn) {
                    // Define the hook, we'll check on the first run if it's really needed.
                    return {
                        get: function get() {
                            if (conditionFn()) {
                                // Hook not needed (or it's not possible to use it due
                                // to missing dependency), remove it.
                                delete this.get;
                                return;
                            }
                            // Hook needed; redefine it so that the support test is not executed again.
                            return (this.get = hookFn).apply(this, arguments);
                        }
                    };
                }
                var cssPrefixes = [
                    "Webkit",
                    "Moz",
                    "ms"
                ], emptyStyle = document1.createElement("div").style, vendorProps = {};
                // Return a vendor-prefixed property or undefined
                function vendorPropName(name) {
                    // Check for vendor prefixed names
                    var capName = name[0].toUpperCase() + name.slice(1), i = cssPrefixes.length;
                    while(i--){
                        name = cssPrefixes[i] + capName;
                        if (name in emptyStyle) return name;
                    }
                }
                // Return a potentially-mapped jQuery.cssProps or vendor prefixed property
                function finalPropName(name) {
                    var final = jQuery1.cssProps[name] || vendorProps[name];
                    if (final) return final;
                    if (name in emptyStyle) return name;
                    return vendorProps[name] = vendorPropName(name) || name;
                }
                var // Swappable if display is none or starts with table
                // except "table", "table-cell", or "table-caption"
                // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
                rdisplayswap = /^(none|table(?!-c[ea]).+)/, cssShow = {
                    position: "absolute",
                    visibility: "hidden",
                    display: "block"
                }, cssNormalTransform = {
                    letterSpacing: "0",
                    fontWeight: "400"
                };
                function setPositiveNumber(_elem, value, subtract) {
                    // Any relative (+/-) values have already been
                    // normalized at this point
                    var matches = rcssNum.exec(value);
                    return matches ? // Guard against undefined "subtract", e.g., when used as in cssHooks
                    Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
                }
                function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
                    var i = dimension === "width" ? 1 : 0, extra = 0, delta = 0, marginDelta = 0;
                    // Adjustment may not be necessary
                    if (box === (isBorderBox ? "border" : "content")) return 0;
                    for(; i < 4; i += 2){
                        // Both box models exclude margin
                        // Count margin delta separately to only add it after scroll gutter adjustment.
                        // This is needed to make negative margins work with `outerHeight( true )` (gh-3982).
                        if (box === "margin") marginDelta += jQuery1.css(elem, box + cssExpand[i], true, styles);
                        // If we get here with a content-box, we're seeking "padding" or "border" or "margin"
                        if (!isBorderBox) {
                            // Add padding
                            delta += jQuery1.css(elem, "padding" + cssExpand[i], true, styles);
                            // For "border" or "margin", add border
                            if (box !== "padding") delta += jQuery1.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                            else extra += jQuery1.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                        // If we get here with a border-box (content + padding + border), we're seeking "content" or
                        // "padding" or "margin"
                        } else {
                            // For "content", subtract padding
                            if (box === "content") delta -= jQuery1.css(elem, "padding" + cssExpand[i], true, styles);
                            // For "content" or "padding", subtract border
                            if (box !== "margin") delta -= jQuery1.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                        }
                    }
                    // Account for positive content-box scroll gutter when requested by providing computedVal
                    if (!isBorderBox && computedVal >= 0) // offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
                    // Assuming integer scroll gutter, subtract the rest and round down
                    delta += Math.max(0, Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5)) || 0;
                    return delta + marginDelta;
                }
                function getWidthOrHeight(elem, dimension, extra) {
                    // Start with computed style
                    var styles = getStyles(elem), // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
                    // Fake content-box until we know it's needed to know the true value.
                    boxSizingNeeded = !support.boxSizingReliable() || extra, isBorderBox = boxSizingNeeded && jQuery1.css(elem, "boxSizing", false, styles) === "border-box", valueIsBorderBox = isBorderBox, val = curCSS(elem, dimension, styles), offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1);
                    // Support: Firefox <=54
                    // Return a confounding non-pixel value or feign ignorance, as appropriate.
                    if (rnumnonpx.test(val)) {
                        if (!extra) return val;
                        val = "auto";
                    }
                    // Support: IE 9 - 11 only
                    // Use offsetWidth/offsetHeight for when box sizing is unreliable.
                    // In those cases, the computed value can be trusted to be border-box.
                    if ((!support.boxSizingReliable() && isBorderBox || // Support: IE 10 - 11+, Edge 15 - 18+
                    // IE/Edge misreport `getComputedStyle` of table rows with width/height
                    // set in CSS while `offset*` properties report correct values.
                    // Interestingly, in some cases IE 9 doesn't suffer from this issue.
                    !support.reliableTrDimensions() && nodeName(elem, "tr") || // Fall back to offsetWidth/offsetHeight when value is "auto"
                    // This happens for inline elements with no explicit setting (gh-3571)
                    val === "auto" || // Support: Android <=4.1 - 4.3 only
                    // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
                    !parseFloat(val) && jQuery1.css(elem, "display", false, styles) === "inline") && // Make sure the element is visible & connected
                    elem.getClientRects().length) {
                        isBorderBox = jQuery1.css(elem, "boxSizing", false, styles) === "border-box";
                        // Where available, offsetWidth/offsetHeight approximate border box dimensions.
                        // Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
                        // retrieved value as a content box dimension.
                        valueIsBorderBox = offsetProp in elem;
                        if (valueIsBorderBox) val = elem[offsetProp];
                    }
                    // Normalize "" and auto
                    val = parseFloat(val) || 0;
                    // Adjust for the element's box model
                    return val + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles, // Provide the current computed size to request scroll gutter calculation (gh-3589)
                    val) + "px";
                }
                jQuery1.extend({
                    // Add in style property hooks for overriding the default
                    // behavior of getting and setting a style property
                    cssHooks: {
                        opacity: {
                            get: function get(elem, computed) {
                                if (computed) {
                                    // We should always get a number back from opacity
                                    var ret = curCSS(elem, "opacity");
                                    return ret === "" ? "1" : ret;
                                }
                            }
                        }
                    },
                    // Don't automatically add "px" to these possibly-unitless properties
                    cssNumber: {
                        animationIterationCount: true,
                        aspectRatio: true,
                        borderImageSlice: true,
                        columnCount: true,
                        flexGrow: true,
                        flexShrink: true,
                        fontWeight: true,
                        gridArea: true,
                        gridColumn: true,
                        gridColumnEnd: true,
                        gridColumnStart: true,
                        gridRow: true,
                        gridRowEnd: true,
                        gridRowStart: true,
                        lineHeight: true,
                        opacity: true,
                        order: true,
                        orphans: true,
                        scale: true,
                        widows: true,
                        zIndex: true,
                        zoom: true,
                        // SVG-related
                        fillOpacity: true,
                        floodOpacity: true,
                        stopOpacity: true,
                        strokeMiterlimit: true,
                        strokeOpacity: true
                    },
                    // Add in properties whose names you wish to fix before
                    // setting or getting the value
                    cssProps: {},
                    // Get and set the style property on a DOM Node
                    style: function style(elem, name, value, extra) {
                        // Don't set styles on text and comment nodes
                        if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) return;
                        // Make sure that we're working with the right name
                        var ret, type, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name), style = elem.style;
                        // Make sure that we're working with the right name. We don't
                        // want to query the value if it is a CSS custom property
                        // since they are user-defined.
                        if (!isCustomProp) name = finalPropName(origName);
                        // Gets hook for the prefixed version, then unprefixed version
                        hooks = jQuery1.cssHooks[name] || jQuery1.cssHooks[origName];
                        // Check if we're setting a value
                        if (value !== undefined) {
                            type = typeof value === "undefined" ? "undefined" : (0, _typeOf._)(value);
                            // Convert "+=" or "-=" to relative numbers (trac-7345)
                            if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
                                value = adjustCSS(elem, name, ret);
                                // Fixes bug trac-9237
                                type = "number";
                            }
                            // Make sure that null and NaN values aren't set (trac-7116)
                            if (value == null || value !== value) return;
                            // If a number was passed in, add the unit (except for certain CSS properties)
                            // The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
                            // "px" to a few hardcoded values.
                            if (type === "number" && !isCustomProp) value += ret && ret[3] || (jQuery1.cssNumber[origName] ? "" : "px");
                            // background-* props affect original clone's values
                            if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) style[name] = "inherit";
                            // If a hook was provided, use that value, otherwise just set the specified value
                            if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
                                if (isCustomProp) style.setProperty(name, value);
                                else style[name] = value;
                            }
                        } else {
                            // If a hook was provided get the non-computed value from there
                            if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) return ret;
                            // Otherwise just get the value from the style object
                            return style[name];
                        }
                    },
                    css: function css(elem, name, extra, styles) {
                        var val, num, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name);
                        // Make sure that we're working with the right name. We don't
                        // want to modify the value if it is a CSS custom property
                        // since they are user-defined.
                        if (!isCustomProp) name = finalPropName(origName);
                        // Try prefixed name followed by the unprefixed name
                        hooks = jQuery1.cssHooks[name] || jQuery1.cssHooks[origName];
                        // If a hook was provided get the computed value from there
                        if (hooks && "get" in hooks) val = hooks.get(elem, true, extra);
                        // Otherwise, if a way to get the computed value exists, use that
                        if (val === undefined) val = curCSS(elem, name, styles);
                        // Convert "normal" to computed value
                        if (val === "normal" && name in cssNormalTransform) val = cssNormalTransform[name];
                        // Make numeric if forced or a qualifier was provided and val looks numeric
                        if (extra === "" || extra) {
                            num = parseFloat(val);
                            return extra === true || isFinite(num) ? num || 0 : val;
                        }
                        return val;
                    }
                });
                jQuery1.each([
                    "height",
                    "width"
                ], function(_i, dimension) {
                    jQuery1.cssHooks[dimension] = {
                        get: function get(elem, computed, extra) {
                            if (computed) // Certain elements can have dimension info if we invisibly show them
                            // but it must have a current display style that would benefit
                            return rdisplayswap.test(jQuery1.css(elem, "display")) && // Support: Safari 8+
                            // Table columns in Safari have non-zero offsetWidth & zero
                            // getBoundingClientRect().width unless display is changed.
                            // Support: IE <=11 only
                            // Running getBoundingClientRect on a disconnected node
                            // in IE throws an error.
                            (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function() {
                                return getWidthOrHeight(elem, dimension, extra);
                            }) : getWidthOrHeight(elem, dimension, extra);
                        },
                        set: function set(elem, value, extra) {
                            var matches, styles = getStyles(elem), // Only read styles.position if the test has a chance to fail
                            // to avoid forcing a reflow.
                            scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === "absolute", // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
                            boxSizingNeeded = scrollboxSizeBuggy || extra, isBorderBox = boxSizingNeeded && jQuery1.css(elem, "boxSizing", false, styles) === "border-box", subtract = extra ? boxModelAdjustment(elem, dimension, extra, isBorderBox, styles) : 0;
                            // Account for unreliable border-box dimensions by comparing offset* to computed and
                            // faking a content-box to get border and padding (gh-3699)
                            if (isBorderBox && scrollboxSizeBuggy) subtract -= Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5);
                            // Convert to pixels if value adjustment is needed
                            if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
                                elem.style[dimension] = value;
                                value = jQuery1.css(elem, dimension);
                            }
                            return setPositiveNumber(elem, value, subtract);
                        }
                    };
                });
                jQuery1.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function(elem, computed) {
                    if (computed) return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {
                        marginLeft: 0
                    }, function() {
                        return elem.getBoundingClientRect().left;
                    })) + "px";
                });
                // These hooks are used by animate to expand properties
                jQuery1.each({
                    margin: "",
                    padding: "",
                    border: "Width"
                }, function(prefix, suffix) {
                    jQuery1.cssHooks[prefix + suffix] = {
                        expand: function expand(value) {
                            var i = 0, expanded = {}, // Assumes a single number if not a string
                            parts = typeof value === "string" ? value.split(" ") : [
                                value
                            ];
                            for(; i < 4; i++)expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                            return expanded;
                        }
                    };
                    if (prefix !== "margin") jQuery1.cssHooks[prefix + suffix].set = setPositiveNumber;
                });
                jQuery1.fn.extend({
                    css: function css(name, value) {
                        return access(this, function(elem, name, value) {
                            var styles, len, map = {}, i = 0;
                            if (Array.isArray(name)) {
                                styles = getStyles(elem);
                                len = name.length;
                                for(; i < len; i++)map[name[i]] = jQuery1.css(elem, name[i], false, styles);
                                return map;
                            }
                            return value !== undefined ? jQuery1.style(elem, name, value) : jQuery1.css(elem, name);
                        }, name, value, arguments.length > 1);
                    }
                });
                function Tween(elem, options, prop, end, easing) {
                    return new Tween.prototype.init(elem, options, prop, end, easing);
                }
                jQuery1.Tween = Tween;
                Tween.prototype = {
                    constructor: Tween,
                    init: function init(elem, options, prop, end, easing, unit) {
                        this.elem = elem;
                        this.prop = prop;
                        this.easing = easing || jQuery1.easing._default;
                        this.options = options;
                        this.start = this.now = this.cur();
                        this.end = end;
                        this.unit = unit || (jQuery1.cssNumber[prop] ? "" : "px");
                    },
                    cur: function cur() {
                        var hooks = Tween.propHooks[this.prop];
                        return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
                    },
                    run: function run(percent) {
                        var eased, hooks = Tween.propHooks[this.prop];
                        if (this.options.duration) this.pos = eased = jQuery1.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
                        else this.pos = eased = percent;
                        this.now = (this.end - this.start) * eased + this.start;
                        if (this.options.step) this.options.step.call(this.elem, this.now, this);
                        if (hooks && hooks.set) hooks.set(this);
                        else Tween.propHooks._default.set(this);
                        return this;
                    }
                };
                Tween.prototype.init.prototype = Tween.prototype;
                Tween.propHooks = {
                    _default: {
                        get: function get(tween) {
                            var result;
                            // Use a property on the element directly when it is not a DOM element,
                            // or when there is no matching style property that exists.
                            if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) return tween.elem[tween.prop];
                            // Passing an empty string as a 3rd parameter to .css will automatically
                            // attempt a parseFloat and fallback to a string if the parse fails.
                            // Simple values such as "10px" are parsed to Float;
                            // complex values such as "rotate(1rad)" are returned as-is.
                            result = jQuery1.css(tween.elem, tween.prop, "");
                            // Empty strings, null, undefined and "auto" are converted to 0.
                            return !result || result === "auto" ? 0 : result;
                        },
                        set: function set(tween) {
                            // Use step hook for back compat.
                            // Use cssHook if its there.
                            // Use .style if available and use plain properties where available.
                            if (jQuery1.fx.step[tween.prop]) jQuery1.fx.step[tween.prop](tween);
                            else if (tween.elem.nodeType === 1 && (jQuery1.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) jQuery1.style(tween.elem, tween.prop, tween.now + tween.unit);
                            else tween.elem[tween.prop] = tween.now;
                        }
                    }
                };
                // Support: IE <=9 only
                // Panic based approach to setting things on disconnected nodes
                Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
                    set: function set(tween) {
                        if (tween.elem.nodeType && tween.elem.parentNode) tween.elem[tween.prop] = tween.now;
                    }
                };
                jQuery1.easing = {
                    linear: function linear(p) {
                        return p;
                    },
                    swing: function swing(p) {
                        return 0.5 - Math.cos(p * Math.PI) / 2;
                    },
                    _default: "swing"
                };
                jQuery1.fx = Tween.prototype.init;
                // Back compat <1.8 extension point
                jQuery1.fx.step = {};
                var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
                function schedule() {
                    if (inProgress) {
                        if (document1.hidden === false && window1.requestAnimationFrame) window1.requestAnimationFrame(schedule);
                        else window1.setTimeout(schedule, jQuery1.fx.interval);
                        jQuery1.fx.tick();
                    }
                }
                // Animations created synchronously will run synchronously
                function createFxNow() {
                    window1.setTimeout(function() {
                        fxNow = undefined;
                    });
                    return fxNow = Date.now();
                }
                // Generate parameters to create a standard animation
                function genFx(type, includeWidth) {
                    var which, i = 0, attrs = {
                        height: type
                    };
                    // If we include width, step value is 1 to do all cssExpand values,
                    // otherwise step value is 2 to skip over Left and Right
                    includeWidth = includeWidth ? 1 : 0;
                    for(; i < 4; i += 2 - includeWidth){
                        which = cssExpand[i];
                        attrs["margin" + which] = attrs["padding" + which] = type;
                    }
                    if (includeWidth) attrs.opacity = attrs.width = type;
                    return attrs;
                }
                function createTween(value, prop, animation) {
                    var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index = 0, length = collection.length;
                    for(; index < length; index++){
                        if (tween = collection[index].call(animation, prop, value)) // We're done with this property
                        return tween;
                    }
                }
                function defaultPrefilter(elem, props, opts) {
                    var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = "width" in props || "height" in props, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, "fxshow");
                    // Queue-skipping animations hijack the fx hooks
                    if (!opts.queue) {
                        hooks = jQuery1._queueHooks(elem, "fx");
                        if (hooks.unqueued == null) {
                            hooks.unqueued = 0;
                            oldfire = hooks.empty.fire;
                            hooks.empty.fire = function() {
                                if (!hooks.unqueued) oldfire();
                            };
                        }
                        hooks.unqueued++;
                        anim.always(function() {
                            // Ensure the complete handler is called before this completes
                            anim.always(function() {
                                hooks.unqueued--;
                                if (!jQuery1.queue(elem, "fx").length) hooks.empty.fire();
                            });
                        });
                    }
                    // Detect show/hide animations
                    for(prop in props){
                        value = props[prop];
                        if (rfxtypes.test(value)) {
                            delete props[prop];
                            toggle = toggle || value === "toggle";
                            if (value === (hidden ? "hide" : "show")) {
                                // Pretend to be hidden if this is a "show" and
                                // there is still data from a stopped show/hide
                                if (value === "show" && dataShow && dataShow[prop] !== undefined) hidden = true;
                                else continue;
                            }
                            orig[prop] = dataShow && dataShow[prop] || jQuery1.style(elem, prop);
                        }
                    }
                    // Bail out if this is a no-op like .hide().hide()
                    propTween = !jQuery1.isEmptyObject(props);
                    if (!propTween && jQuery1.isEmptyObject(orig)) return;
                    // Restrict "overflow" and "display" styles during box animations
                    if (isBox && elem.nodeType === 1) {
                        // Support: IE <=9 - 11, Edge 12 - 15
                        // Record all 3 overflow attributes because IE does not infer the shorthand
                        // from identically-valued overflowX and overflowY and Edge just mirrors
                        // the overflowX value there.
                        opts.overflow = [
                            style.overflow,
                            style.overflowX,
                            style.overflowY
                        ];
                        // Identify a display type, preferring old show/hide data over the CSS cascade
                        restoreDisplay = dataShow && dataShow.display;
                        if (restoreDisplay == null) restoreDisplay = dataPriv.get(elem, "display");
                        display = jQuery1.css(elem, "display");
                        if (display === "none") {
                            if (restoreDisplay) display = restoreDisplay;
                            else {
                                // Get nonempty value(s) by temporarily forcing visibility
                                showHide([
                                    elem
                                ], true);
                                restoreDisplay = elem.style.display || restoreDisplay;
                                display = jQuery1.css(elem, "display");
                                showHide([
                                    elem
                                ]);
                            }
                        }
                        // Animate inline elements as inline-block
                        if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
                            if (jQuery1.css(elem, "float") === "none") {
                                // Restore the original display value at the end of pure show/hide animations
                                if (!propTween) {
                                    anim.done(function() {
                                        style.display = restoreDisplay;
                                    });
                                    if (restoreDisplay == null) {
                                        display = style.display;
                                        restoreDisplay = display === "none" ? "" : display;
                                    }
                                }
                                style.display = "inline-block";
                            }
                        }
                    }
                    if (opts.overflow) {
                        style.overflow = "hidden";
                        anim.always(function() {
                            style.overflow = opts.overflow[0];
                            style.overflowX = opts.overflow[1];
                            style.overflowY = opts.overflow[2];
                        });
                    }
                    // Implement show/hide animations
                    propTween = false;
                    for(prop in orig){
                        // General show/hide setup for this element animation
                        if (!propTween) {
                            if (dataShow) {
                                if ("hidden" in dataShow) hidden = dataShow.hidden;
                            } else dataShow = dataPriv.access(elem, "fxshow", {
                                display: restoreDisplay
                            });
                            // Store hidden/visible for toggle so `.stop().toggle()` "reverses"
                            if (toggle) dataShow.hidden = !hidden;
                            // Show elements before animating them
                            if (hidden) showHide([
                                elem
                            ], true);
                            /* eslint-disable no-loop-func */ anim.done(function() {
                                /* eslint-enable no-loop-func */ // The final step of a "hide" animation is actually hiding the element
                                if (!hidden) showHide([
                                    elem
                                ]);
                                dataPriv.remove(elem, "fxshow");
                                for(prop in orig)jQuery1.style(elem, prop, orig[prop]);
                            });
                        }
                        // Per-property setup
                        propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
                        if (!(prop in dataShow)) {
                            dataShow[prop] = propTween.start;
                            if (hidden) {
                                propTween.end = propTween.start;
                                propTween.start = 0;
                            }
                        }
                    }
                }
                function propFilter(props, specialEasing) {
                    var index, name, easing, value, hooks;
                    // camelCase, specialEasing and expand cssHook pass
                    for(index in props){
                        name = camelCase(index);
                        easing = specialEasing[name];
                        value = props[index];
                        if (Array.isArray(value)) {
                            easing = value[1];
                            value = props[index] = value[0];
                        }
                        if (index !== name) {
                            props[name] = value;
                            delete props[index];
                        }
                        hooks = jQuery1.cssHooks[name];
                        if (hooks && "expand" in hooks) {
                            value = hooks.expand(value);
                            delete props[name];
                            // Not quite $.extend, this won't overwrite existing keys.
                            // Reusing 'index' because we have the correct "name"
                            for(index in value)if (!(index in props)) {
                                props[index] = value[index];
                                specialEasing[index] = easing;
                            }
                        } else specialEasing[name] = easing;
                    }
                }
                function Animation(elem, properties, options) {
                    var result, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery1.Deferred().always(function() {
                        // Don't match elem in the :animated selector
                        delete tick.elem;
                    }), tick = function tick() {
                        if (stopped) return false;
                        var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), // Support: Android 2.3 only
                        // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (trac-12497)
                        temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length;
                        for(; index < length; index++)animation.tweens[index].run(percent);
                        deferred.notifyWith(elem, [
                            animation,
                            percent,
                            remaining
                        ]);
                        // If there's more to do, yield
                        if (percent < 1 && length) return remaining;
                        // If this was an empty animation, synthesize a final progress notification
                        if (!length) deferred.notifyWith(elem, [
                            animation,
                            1,
                            0
                        ]);
                        // Resolve the animation and report its conclusion
                        deferred.resolveWith(elem, [
                            animation
                        ]);
                        return false;
                    }, animation = deferred.promise({
                        elem: elem,
                        props: jQuery1.extend({}, properties),
                        opts: jQuery1.extend(true, {
                            specialEasing: {},
                            easing: jQuery1.easing._default
                        }, options),
                        originalProperties: properties,
                        originalOptions: options,
                        startTime: fxNow || createFxNow(),
                        duration: options.duration,
                        tweens: [],
                        createTween: function createTween(prop, end) {
                            var tween = jQuery1.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                            animation.tweens.push(tween);
                            return tween;
                        },
                        stop: function stop(gotoEnd) {
                            var index = 0, // If we are going to the end, we want to run all the tweens
                            // otherwise we skip this part
                            length = gotoEnd ? animation.tweens.length : 0;
                            if (stopped) return this;
                            stopped = true;
                            for(; index < length; index++)animation.tweens[index].run(1);
                            // Resolve when we played the last frame; otherwise, reject
                            if (gotoEnd) {
                                deferred.notifyWith(elem, [
                                    animation,
                                    1,
                                    0
                                ]);
                                deferred.resolveWith(elem, [
                                    animation,
                                    gotoEnd
                                ]);
                            } else deferred.rejectWith(elem, [
                                animation,
                                gotoEnd
                            ]);
                            return this;
                        }
                    }), props = animation.props;
                    propFilter(props, animation.opts.specialEasing);
                    for(; index < length; index++){
                        result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
                        if (result) {
                            if (isFunction(result.stop)) jQuery1._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
                            return result;
                        }
                    }
                    jQuery1.map(props, createTween, animation);
                    if (isFunction(animation.opts.start)) animation.opts.start.call(elem, animation);
                    // Attach callbacks from options
                    animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
                    jQuery1.fx.timer(jQuery1.extend(tick, {
                        elem: elem,
                        anim: animation,
                        queue: animation.opts.queue
                    }));
                    return animation;
                }
                jQuery1.Animation = jQuery1.extend(Animation, {
                    tweeners: {
                        "*": [
                            function(prop, value) {
                                var tween = this.createTween(prop, value);
                                adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
                                return tween;
                            }
                        ]
                    },
                    tweener: function tweener(props, callback) {
                        if (isFunction(props)) {
                            callback = props;
                            props = [
                                "*"
                            ];
                        } else props = props.match(rnothtmlwhite);
                        var prop, index = 0, length = props.length;
                        for(; index < length; index++){
                            prop = props[index];
                            Animation.tweeners[prop] = Animation.tweeners[prop] || [];
                            Animation.tweeners[prop].unshift(callback);
                        }
                    },
                    prefilters: [
                        defaultPrefilter
                    ],
                    prefilter: function prefilter(callback, prepend) {
                        if (prepend) Animation.prefilters.unshift(callback);
                        else Animation.prefilters.push(callback);
                    }
                });
                jQuery1.speed = function(speed, easing, fn) {
                    var opt = speed && typeof speed === "object" ? jQuery1.extend({}, speed) : {
                        complete: fn || !fn && easing || isFunction(speed) && speed,
                        duration: speed,
                        easing: fn && easing || easing && !isFunction(easing) && easing
                    };
                    // Go to the end state if fx are off
                    if (jQuery1.fx.off) opt.duration = 0;
                    else if (typeof opt.duration !== "number") {
                        if (opt.duration in jQuery1.fx.speeds) opt.duration = jQuery1.fx.speeds[opt.duration];
                        else opt.duration = jQuery1.fx.speeds._default;
                    }
                    // Normalize opt.queue - true/undefined/null -> "fx"
                    if (opt.queue == null || opt.queue === true) opt.queue = "fx";
                    // Queueing
                    opt.old = opt.complete;
                    opt.complete = function() {
                        if (isFunction(opt.old)) opt.old.call(this);
                        if (opt.queue) jQuery1.dequeue(this, opt.queue);
                    };
                    return opt;
                };
                jQuery1.fn.extend({
                    fadeTo: function fadeTo(speed, to, easing, callback) {
                        // Show any hidden elements after setting opacity to 0
                        return this.filter(isHiddenWithinTree).css("opacity", 0).show()// Animate to the value specified
                        .end().animate({
                            opacity: to
                        }, speed, easing, callback);
                    },
                    animate: function animate(prop, speed, easing, callback) {
                        var empty = jQuery1.isEmptyObject(prop), optall = jQuery1.speed(speed, easing, callback), doAnimation = function doAnimation() {
                            // Operate on a copy of prop so per-property easing won't be lost
                            var anim = Animation(this, jQuery1.extend({}, prop), optall);
                            // Empty animations, or finishing resolves immediately
                            if (empty || dataPriv.get(this, "finish")) anim.stop(true);
                        };
                        doAnimation.finish = doAnimation;
                        return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
                    },
                    stop: function stop(type, clearQueue, gotoEnd) {
                        var stopQueue = function stopQueue(hooks) {
                            var stop = hooks.stop;
                            delete hooks.stop;
                            stop(gotoEnd);
                        };
                        if (typeof type !== "string") {
                            gotoEnd = clearQueue;
                            clearQueue = type;
                            type = undefined;
                        }
                        if (clearQueue) this.queue(type || "fx", []);
                        return this.each(function() {
                            var dequeue = true, index = type != null && type + "queueHooks", timers = jQuery1.timers, data = dataPriv.get(this);
                            if (index) {
                                if (data[index] && data[index].stop) stopQueue(data[index]);
                            } else {
                                for(index in data)if (data[index] && data[index].stop && rrun.test(index)) stopQueue(data[index]);
                            }
                            for(index = timers.length; index--;)if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                                timers[index].anim.stop(gotoEnd);
                                dequeue = false;
                                timers.splice(index, 1);
                            }
                            // Start the next in the queue if the last step wasn't forced.
                            // Timers currently will call their complete callbacks, which
                            // will dequeue but only if they were gotoEnd.
                            if (dequeue || !gotoEnd) jQuery1.dequeue(this, type);
                        });
                    },
                    finish: function finish(type) {
                        if (type !== false) type = type || "fx";
                        return this.each(function() {
                            var index, data = dataPriv.get(this), queue = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery1.timers, length = queue ? queue.length : 0;
                            // Enable finishing flag on private data
                            data.finish = true;
                            // Empty the queue first
                            jQuery1.queue(this, type, []);
                            if (hooks && hooks.stop) hooks.stop.call(this, true);
                            // Look for any active animations, and finish them
                            for(index = timers.length; index--;)if (timers[index].elem === this && timers[index].queue === type) {
                                timers[index].anim.stop(true);
                                timers.splice(index, 1);
                            }
                            // Look for any animations in the old queue and finish them
                            for(index = 0; index < length; index++)if (queue[index] && queue[index].finish) queue[index].finish.call(this);
                            // Turn off finishing flag
                            delete data.finish;
                        });
                    }
                });
                jQuery1.each([
                    "toggle",
                    "show",
                    "hide"
                ], function(_i, name) {
                    var cssFn = jQuery1.fn[name];
                    jQuery1.fn[name] = function(speed, easing, callback) {
                        return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
                    };
                });
                // Generate shortcuts for custom animations
                jQuery1.each({
                    slideDown: genFx("show"),
                    slideUp: genFx("hide"),
                    slideToggle: genFx("toggle"),
                    fadeIn: {
                        opacity: "show"
                    },
                    fadeOut: {
                        opacity: "hide"
                    },
                    fadeToggle: {
                        opacity: "toggle"
                    }
                }, function(name, props) {
                    jQuery1.fn[name] = function(speed, easing, callback) {
                        return this.animate(props, speed, easing, callback);
                    };
                });
                jQuery1.timers = [];
                jQuery1.fx.tick = function() {
                    var timer, i = 0, timers = jQuery1.timers;
                    fxNow = Date.now();
                    for(; i < timers.length; i++){
                        timer = timers[i];
                        // Run the timer and safely remove it when done (allowing for external removal)
                        if (!timer() && timers[i] === timer) timers.splice(i--, 1);
                    }
                    if (!timers.length) jQuery1.fx.stop();
                    fxNow = undefined;
                };
                jQuery1.fx.timer = function(timer) {
                    jQuery1.timers.push(timer);
                    jQuery1.fx.start();
                };
                jQuery1.fx.interval = 13;
                jQuery1.fx.start = function() {
                    if (inProgress) return;
                    inProgress = true;
                    schedule();
                };
                jQuery1.fx.stop = function() {
                    inProgress = null;
                };
                jQuery1.fx.speeds = {
                    slow: 600,
                    fast: 200,
                    // Default speed
                    _default: 400
                };
                // Based off of the plugin by Clint Helfers, with permission.
                jQuery1.fn.delay = function(time, type) {
                    time = jQuery1.fx ? jQuery1.fx.speeds[time] || time : time;
                    type = type || "fx";
                    return this.queue(type, function(next, hooks) {
                        var timeout = window1.setTimeout(next, time);
                        hooks.stop = function() {
                            window1.clearTimeout(timeout);
                        };
                    });
                };
                (function() {
                    var input = document1.createElement("input"), select = document1.createElement("select"), opt = select.appendChild(document1.createElement("option"));
                    input.type = "checkbox";
                    // Support: Android <=4.3 only
                    // Default value for a checkbox should be "on"
                    support.checkOn = input.value !== "";
                    // Support: IE <=11 only
                    // Must access selectedIndex to make default options select
                    support.optSelected = opt.selected;
                    // Support: IE <=11 only
                    // An input loses its value after becoming a radio
                    input = document1.createElement("input");
                    input.value = "t";
                    input.type = "radio";
                    support.radioValue = input.value === "t";
                })();
                var boolHook, attrHandle = jQuery1.expr.attrHandle;
                jQuery1.fn.extend({
                    attr: function attr(name, value) {
                        return access(this, jQuery1.attr, name, value, arguments.length > 1);
                    },
                    removeAttr: function removeAttr(name) {
                        return this.each(function() {
                            jQuery1.removeAttr(this, name);
                        });
                    }
                });
                jQuery1.extend({
                    attr: function attr(elem, name, value) {
                        var ret, hooks, nType = elem.nodeType;
                        // Don't get/set attributes on text, comment and attribute nodes
                        if (nType === 3 || nType === 8 || nType === 2) return;
                        // Fallback to prop when attributes are not supported
                        if (typeof elem.getAttribute === "undefined") return jQuery1.prop(elem, name, value);
                        // Attribute hooks are determined by the lowercase version
                        // Grab necessary hook if one is defined
                        if (nType !== 1 || !jQuery1.isXMLDoc(elem)) hooks = jQuery1.attrHooks[name.toLowerCase()] || (jQuery1.expr.match.bool.test(name) ? boolHook : undefined);
                        if (value !== undefined) {
                            if (value === null) {
                                jQuery1.removeAttr(elem, name);
                                return;
                            }
                            if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) return ret;
                            elem.setAttribute(name, value + "");
                            return value;
                        }
                        if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) return ret;
                        ret = jQuery1.find.attr(elem, name);
                        // Non-existent attributes return null, we normalize to undefined
                        return ret == null ? undefined : ret;
                    },
                    attrHooks: {
                        type: {
                            set: function set(elem, value) {
                                if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
                                    var val = elem.value;
                                    elem.setAttribute("type", value);
                                    if (val) elem.value = val;
                                    return value;
                                }
                            }
                        }
                    },
                    removeAttr: function removeAttr(elem, value) {
                        var name, i = 0, // Attribute names can contain non-HTML whitespace characters
                        // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
                        attrNames = value && value.match(rnothtmlwhite);
                        if (attrNames && elem.nodeType === 1) while(name = attrNames[i++])elem.removeAttribute(name);
                    }
                });
                // Hooks for boolean attributes
                boolHook = {
                    set: function set(elem, value, name) {
                        if (value === false) // Remove boolean attributes when set to false
                        jQuery1.removeAttr(elem, name);
                        else elem.setAttribute(name, name);
                        return name;
                    }
                };
                jQuery1.each(jQuery1.expr.match.bool.source.match(/\w+/g), function(_i, name) {
                    var getter = attrHandle[name] || jQuery1.find.attr;
                    attrHandle[name] = function(elem, name, isXML) {
                        var ret, handle, lowercaseName = name.toLowerCase();
                        if (!isXML) {
                            // Avoid an infinite loop by temporarily removing this function from the getter
                            handle = attrHandle[lowercaseName];
                            attrHandle[lowercaseName] = ret;
                            ret = getter(elem, name, isXML) != null ? lowercaseName : null;
                            attrHandle[lowercaseName] = handle;
                        }
                        return ret;
                    };
                });
                var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
                jQuery1.fn.extend({
                    prop: function prop(name, value) {
                        return access(this, jQuery1.prop, name, value, arguments.length > 1);
                    },
                    removeProp: function removeProp(name) {
                        return this.each(function() {
                            delete this[jQuery1.propFix[name] || name];
                        });
                    }
                });
                jQuery1.extend({
                    prop: function prop(elem, name, value) {
                        var ret, hooks, nType = elem.nodeType;
                        // Don't get/set properties on text, comment and attribute nodes
                        if (nType === 3 || nType === 8 || nType === 2) return;
                        if (nType !== 1 || !jQuery1.isXMLDoc(elem)) {
                            // Fix name and attach hooks
                            name = jQuery1.propFix[name] || name;
                            hooks = jQuery1.propHooks[name];
                        }
                        if (value !== undefined) {
                            if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) return ret;
                            return elem[name] = value;
                        }
                        if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) return ret;
                        return elem[name];
                    },
                    propHooks: {
                        tabIndex: {
                            get: function get(elem) {
                                // Support: IE <=9 - 11 only
                                // elem.tabIndex doesn't always return the
                                // correct value when it hasn't been explicitly set
                                // Use proper attribute retrieval (trac-12072)
                                var tabindex = jQuery1.find.attr(elem, "tabindex");
                                if (tabindex) return parseInt(tabindex, 10);
                                if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) return 0;
                                return -1;
                            }
                        }
                    },
                    propFix: {
                        "for": "htmlFor",
                        "class": "className"
                    }
                });
                // Support: IE <=11 only
                // Accessing the selectedIndex property
                // forces the browser to respect setting selected
                // on the option
                // The getter ensures a default option is selected
                // when in an optgroup
                // eslint rule "no-unused-expressions" is disabled for this code
                // since it considers such accessions noop
                if (!support.optSelected) jQuery1.propHooks.selected = {
                    get: function get(elem) {
                        /* eslint no-unused-expressions: "off" */ var parent = elem.parentNode;
                        if (parent && parent.parentNode) parent.parentNode.selectedIndex;
                        return null;
                    },
                    set: function set(elem) {
                        /* eslint no-unused-expressions: "off" */ var parent = elem.parentNode;
                        if (parent) {
                            parent.selectedIndex;
                            if (parent.parentNode) parent.parentNode.selectedIndex;
                        }
                    }
                };
                jQuery1.each([
                    "tabIndex",
                    "readOnly",
                    "maxLength",
                    "cellSpacing",
                    "cellPadding",
                    "rowSpan",
                    "colSpan",
                    "useMap",
                    "frameBorder",
                    "contentEditable"
                ], function() {
                    jQuery1.propFix[this.toLowerCase()] = this;
                });
                // Strip and collapse whitespace according to HTML spec
                // https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
                function stripAndCollapse(value) {
                    var tokens = value.match(rnothtmlwhite) || [];
                    return tokens.join(" ");
                }
                function getClass(elem) {
                    return elem.getAttribute && elem.getAttribute("class") || "";
                }
                function classesToArray(value) {
                    if (Array.isArray(value)) return value;
                    if (typeof value === "string") return value.match(rnothtmlwhite) || [];
                    return [];
                }
                jQuery1.fn.extend({
                    addClass: function addClass(value) {
                        var classNames, cur, curValue, className, i, finalValue;
                        if (isFunction(value)) return this.each(function(j) {
                            jQuery1(this).addClass(value.call(this, j, getClass(this)));
                        });
                        classNames = classesToArray(value);
                        if (classNames.length) return this.each(function() {
                            curValue = getClass(this);
                            cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
                            if (cur) {
                                for(i = 0; i < classNames.length; i++){
                                    className = classNames[i];
                                    if (cur.indexOf(" " + className + " ") < 0) cur += className + " ";
                                }
                                // Only assign if different to avoid unneeded rendering.
                                finalValue = stripAndCollapse(cur);
                                if (curValue !== finalValue) this.setAttribute("class", finalValue);
                            }
                        });
                        return this;
                    },
                    removeClass: function removeClass(value) {
                        var classNames, cur, curValue, className, i, finalValue;
                        if (isFunction(value)) return this.each(function(j) {
                            jQuery1(this).removeClass(value.call(this, j, getClass(this)));
                        });
                        if (!arguments.length) return this.attr("class", "");
                        classNames = classesToArray(value);
                        if (classNames.length) return this.each(function() {
                            curValue = getClass(this);
                            // This expression is here for better compressibility (see addClass)
                            cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
                            if (cur) {
                                for(i = 0; i < classNames.length; i++){
                                    className = classNames[i];
                                    // Remove *all* instances
                                    while(cur.indexOf(" " + className + " ") > -1)cur = cur.replace(" " + className + " ", " ");
                                }
                                // Only assign if different to avoid unneeded rendering.
                                finalValue = stripAndCollapse(cur);
                                if (curValue !== finalValue) this.setAttribute("class", finalValue);
                            }
                        });
                        return this;
                    },
                    toggleClass: function toggleClass(value, stateVal) {
                        var classNames, className, i, self1, type = typeof value === "undefined" ? "undefined" : (0, _typeOf._)(value), isValidValue = type === "string" || Array.isArray(value);
                        if (isFunction(value)) return this.each(function(i) {
                            jQuery1(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
                        });
                        if (typeof stateVal === "boolean" && isValidValue) return stateVal ? this.addClass(value) : this.removeClass(value);
                        classNames = classesToArray(value);
                        return this.each(function() {
                            if (isValidValue) {
                                // Toggle individual class names
                                self1 = jQuery1(this);
                                for(i = 0; i < classNames.length; i++){
                                    className = classNames[i];
                                    // Check each className given, space separated list
                                    if (self1.hasClass(className)) self1.removeClass(className);
                                    else self1.addClass(className);
                                }
                            // Toggle whole class name
                            } else if (value === undefined || type === "boolean") {
                                className = getClass(this);
                                if (className) // Store className if set
                                dataPriv.set(this, "__className__", className);
                                // If the element has a class name or if we're passed `false`,
                                // then remove the whole classname (if there was one, the above saved it).
                                // Otherwise bring back whatever was previously saved (if anything),
                                // falling back to the empty string if nothing was stored.
                                if (this.setAttribute) this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
                            }
                        });
                    },
                    hasClass: function hasClass(selector) {
                        var className, elem, i = 0;
                        className = " " + selector + " ";
                        while(elem = this[i++]){
                            if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) return true;
                        }
                        return false;
                    }
                });
                var rreturn = /\r/g;
                jQuery1.fn.extend({
                    val: function val(value) {
                        var hooks, ret, valueIsFunction, elem = this[0];
                        if (!arguments.length) {
                            if (elem) {
                                hooks = jQuery1.valHooks[elem.type] || jQuery1.valHooks[elem.nodeName.toLowerCase()];
                                if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) return ret;
                                ret = elem.value;
                                // Handle most common string cases
                                if (typeof ret === "string") return ret.replace(rreturn, "");
                                // Handle cases where value is null/undef or number
                                return ret == null ? "" : ret;
                            }
                            return;
                        }
                        valueIsFunction = isFunction(value);
                        return this.each(function(i) {
                            var val;
                            if (this.nodeType !== 1) return;
                            if (valueIsFunction) val = value.call(this, i, jQuery1(this).val());
                            else val = value;
                            // Treat null/undefined as ""; convert numbers to string
                            if (val == null) val = "";
                            else if (typeof val === "number") val += "";
                            else if (Array.isArray(val)) val = jQuery1.map(val, function(value) {
                                return value == null ? "" : value + "";
                            });
                            hooks = jQuery1.valHooks[this.type] || jQuery1.valHooks[this.nodeName.toLowerCase()];
                            // If set returns undefined, fall back to normal setting
                            if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) this.value = val;
                        });
                    }
                });
                jQuery1.extend({
                    valHooks: {
                        option: {
                            get: function get(elem) {
                                var val = jQuery1.find.attr(elem, "value");
                                return val != null ? val : // Support: IE <=10 - 11 only
                                // option.text throws exceptions (trac-14686, trac-14858)
                                // Strip and collapse whitespace
                                // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                                stripAndCollapse(jQuery1.text(elem));
                            }
                        },
                        select: {
                            get: function get(elem) {
                                var value, option, i, options = elem.options, index = elem.selectedIndex, one = elem.type === "select-one", values = one ? null : [], max = one ? index + 1 : options.length;
                                if (index < 0) i = max;
                                else i = one ? index : 0;
                                // Loop through all the selected options
                                for(; i < max; i++){
                                    option = options[i];
                                    // Support: IE <=9 only
                                    // IE8-9 doesn't update selected after form reset (trac-2551)
                                    if ((option.selected || i === index) && // Don't return options that are disabled or in a disabled optgroup
                                    !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
                                        // Get the specific value for the option
                                        value = jQuery1(option).val();
                                        // We don't need an array for one selects
                                        if (one) return value;
                                        // Multi-Selects return an array
                                        values.push(value);
                                    }
                                }
                                return values;
                            },
                            set: function set(elem, value) {
                                var optionSet, option, options = elem.options, values = jQuery1.makeArray(value), i = options.length;
                                while(i--){
                                    option = options[i];
                                    /* eslint-disable no-cond-assign */ if (option.selected = jQuery1.inArray(jQuery1.valHooks.option.get(option), values) > -1) optionSet = true;
                                /* eslint-enable no-cond-assign */ }
                                // Force browsers to behave consistently when non-matching value is set
                                if (!optionSet) elem.selectedIndex = -1;
                                return values;
                            }
                        }
                    }
                });
                // Radios and checkboxes getter/setter
                jQuery1.each([
                    "radio",
                    "checkbox"
                ], function() {
                    jQuery1.valHooks[this] = {
                        set: function set(elem, value) {
                            if (Array.isArray(value)) return elem.checked = jQuery1.inArray(jQuery1(elem).val(), value) > -1;
                        }
                    };
                    if (!support.checkOn) jQuery1.valHooks[this].get = function(elem) {
                        return elem.getAttribute("value") === null ? "on" : elem.value;
                    };
                });
                // Return jQuery for attributes-only inclusion
                var location = window1.location;
                var nonce = {
                    guid: Date.now()
                };
                var rquery = /\?/;
                // Cross-browser xml parsing
                jQuery1.parseXML = function(data) {
                    var xml, parserErrorElem;
                    if (!data || typeof data !== "string") return null;
                    // Support: IE 9 - 11 only
                    // IE throws on parseFromString with invalid input.
                    try {
                        xml = new window1.DOMParser().parseFromString(data, "text/xml");
                    } catch (e) {}
                    parserErrorElem = xml && xml.getElementsByTagName("parsererror")[0];
                    if (!xml || parserErrorElem) jQuery1.error("Invalid XML: " + (parserErrorElem ? jQuery1.map(parserErrorElem.childNodes, function(el) {
                        return el.textContent;
                    }).join("\n") : data));
                    return xml;
                };
                var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, stopPropagationCallback = function stopPropagationCallback(e) {
                    e.stopPropagation();
                };
                jQuery1.extend(jQuery1.event, {
                    trigger: function trigger(event, data, elem, onlyHandlers) {
                        var i, cur, tmp, bubbleType, ontype, handle, special, lastElement, eventPath = [
                            elem || document1
                        ], type = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
                        cur = lastElement = tmp = elem = elem || document1;
                        // Don't do events on text and comment nodes
                        if (elem.nodeType === 3 || elem.nodeType === 8) return;
                        // focus/blur morphs to focusin/out; ensure we're not firing them right now
                        if (rfocusMorph.test(type + jQuery1.event.triggered)) return;
                        if (type.indexOf(".") > -1) {
                            // Namespaced trigger; create a regexp to match event type in handle()
                            namespaces = type.split(".");
                            type = namespaces.shift();
                            namespaces.sort();
                        }
                        ontype = type.indexOf(":") < 0 && "on" + type;
                        // Caller can pass in a jQuery.Event object, Object, or just an event type string
                        event = event[jQuery1.expando] ? event : new jQuery1.Event(type, typeof event === "object" && event);
                        // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
                        event.isTrigger = onlyHandlers ? 2 : 3;
                        event.namespace = namespaces.join(".");
                        event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
                        // Clean up the event in case it is being reused
                        event.result = undefined;
                        if (!event.target) event.target = elem;
                        // Clone any incoming data and prepend the event, creating the handler arg list
                        data = data == null ? [
                            event
                        ] : jQuery1.makeArray(data, [
                            event
                        ]);
                        // Allow special events to draw outside the lines
                        special = jQuery1.event.special[type] || {};
                        if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) return;
                        // Determine event propagation path in advance, per W3C events spec (trac-9951)
                        // Bubble up to document, then to window; watch for a global ownerDocument var (trac-9724)
                        if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
                            bubbleType = special.delegateType || type;
                            if (!rfocusMorph.test(bubbleType + type)) cur = cur.parentNode;
                            for(; cur; cur = cur.parentNode){
                                eventPath.push(cur);
                                tmp = cur;
                            }
                            // Only add window if we got to document (e.g., not plain obj or detached DOM)
                            if (tmp === (elem.ownerDocument || document1)) eventPath.push(tmp.defaultView || tmp.parentWindow || window1);
                        }
                        // Fire handlers on the event path
                        i = 0;
                        while((cur = eventPath[i++]) && !event.isPropagationStopped()){
                            lastElement = cur;
                            event.type = i > 1 ? bubbleType : special.bindType || type;
                            // jQuery handler
                            handle = (dataPriv.get(cur, "events") || Object.create(null))[event.type] && dataPriv.get(cur, "handle");
                            if (handle) handle.apply(cur, data);
                            // Native handler
                            handle = ontype && cur[ontype];
                            if (handle && handle.apply && acceptData(cur)) {
                                event.result = handle.apply(cur, data);
                                if (event.result === false) event.preventDefault();
                            }
                        }
                        event.type = type;
                        // If nobody prevented the default action, do it now
                        if (!onlyHandlers && !event.isDefaultPrevented()) {
                            if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) // Call a native DOM method on the target with the same name as the event.
                            // Don't do default actions on window, that's where global variables be (trac-6170)
                            {
                                if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
                                    // Don't re-trigger an onFOO event when we call its FOO() method
                                    tmp = elem[ontype];
                                    if (tmp) elem[ontype] = null;
                                    // Prevent re-triggering of the same event, since we already bubbled it above
                                    jQuery1.event.triggered = type;
                                    if (event.isPropagationStopped()) lastElement.addEventListener(type, stopPropagationCallback);
                                    elem[type]();
                                    if (event.isPropagationStopped()) lastElement.removeEventListener(type, stopPropagationCallback);
                                    jQuery1.event.triggered = undefined;
                                    if (tmp) elem[ontype] = tmp;
                                }
                            }
                        }
                        return event.result;
                    },
                    // Piggyback on a donor event to simulate a different one
                    // Used only for `focus(in | out)` events
                    simulate: function simulate(type, elem, event) {
                        var e = jQuery1.extend(new jQuery1.Event(), event, {
                            type: type,
                            isSimulated: true
                        });
                        jQuery1.event.trigger(e, null, elem);
                    }
                });
                jQuery1.fn.extend({
                    trigger: function trigger(type, data) {
                        return this.each(function() {
                            jQuery1.event.trigger(type, data, this);
                        });
                    },
                    triggerHandler: function triggerHandler(type, data) {
                        var elem = this[0];
                        if (elem) return jQuery1.event.trigger(type, data, elem, true);
                    }
                });
                var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
                function buildParams(prefix, obj, traditional, add) {
                    var name;
                    if (Array.isArray(obj)) // Serialize array item.
                    jQuery1.each(obj, function(i, v) {
                        if (traditional || rbracket.test(prefix)) // Treat each array item as a scalar.
                        add(prefix, v);
                        else // Item is non-scalar (array or object), encode its numeric index.
                        buildParams(prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]", v, traditional, add);
                    });
                    else if (!traditional && toType(obj) === "object") // Serialize object item.
                    for(name in obj)buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
                    else // Serialize scalar item.
                    add(prefix, obj);
                }
                // Serialize an array of form elements or a set of
                // key/values into a query string
                jQuery1.param = function(a, traditional) {
                    var prefix, s = [], add = function add(key, valueOrFunction) {
                        // If value is a function, invoke it and use its return value
                        var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
                        s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
                    };
                    if (a == null) return "";
                    // If an array was passed in, assume that it is an array of form elements.
                    if (Array.isArray(a) || a.jquery && !jQuery1.isPlainObject(a)) // Serialize the form elements
                    jQuery1.each(a, function() {
                        add(this.name, this.value);
                    });
                    else // If traditional, encode the "old" way (the way 1.3.2 or older
                    // did it), otherwise encode params recursively.
                    for(prefix in a)buildParams(prefix, a[prefix], traditional, add);
                    // Return the resulting serialization
                    return s.join("&");
                };
                jQuery1.fn.extend({
                    serialize: function serialize() {
                        return jQuery1.param(this.serializeArray());
                    },
                    serializeArray: function serializeArray() {
                        return this.map(function() {
                            // Can add propHook for "elements" to filter or add form elements
                            var elements = jQuery1.prop(this, "elements");
                            return elements ? jQuery1.makeArray(elements) : this;
                        }).filter(function() {
                            var type = this.type;
                            // Use .is( ":disabled" ) so that fieldset[disabled] works
                            return this.name && !jQuery1(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
                        }).map(function(_i, elem) {
                            var val = jQuery1(this).val();
                            if (val == null) return null;
                            if (Array.isArray(val)) return jQuery1.map(val, function(val) {
                                return {
                                    name: elem.name,
                                    value: val.replace(rCRLF, "\r\n")
                                };
                            });
                            return {
                                name: elem.name,
                                value: val.replace(rCRLF, "\r\n")
                            };
                        }).get();
                    }
                });
                var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg, // trac-7653, trac-8125, trac-8152: local protocol detection
                rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, /* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */ prefilters = {}, /* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */ transports = {}, // Avoid comment-prolog char sequence (trac-10098); must appease lint and evade compression
                allTypes = "*/".concat("*"), // Anchor tag for parsing the document origin
                originAnchor = document1.createElement("a");
                originAnchor.href = location.href;
                // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
                function addToPrefiltersOrTransports(structure) {
                    // dataTypeExpression is optional and defaults to "*"
                    return function(dataTypeExpression, func) {
                        if (typeof dataTypeExpression !== "string") {
                            func = dataTypeExpression;
                            dataTypeExpression = "*";
                        }
                        var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
                        if (isFunction(func)) {
                            // For each dataType in the dataTypeExpression
                            while(dataType = dataTypes[i++])// Prepend if requested
                            if (dataType[0] === "+") {
                                dataType = dataType.slice(1) || "*";
                                (structure[dataType] = structure[dataType] || []).unshift(func);
                            // Otherwise append
                            } else (structure[dataType] = structure[dataType] || []).push(func);
                        }
                    };
                }
                // Base inspection function for prefilters and transports
                function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
                    var inspected = {}, seekingTransport = structure === transports;
                    function inspect(dataType) {
                        var selected;
                        inspected[dataType] = true;
                        jQuery1.each(structure[dataType] || [], function(_, prefilterOrFactory) {
                            var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                            if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
                                options.dataTypes.unshift(dataTypeOrTransport);
                                inspect(dataTypeOrTransport);
                                return false;
                            } else if (seekingTransport) return !(selected = dataTypeOrTransport);
                        });
                        return selected;
                    }
                    return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
                }
                // A special extend for ajax options
                // that takes "flat" options (not to be deep extended)
                // Fixes trac-9887
                function ajaxExtend(target, src) {
                    var key, deep, flatOptions = jQuery1.ajaxSettings.flatOptions || {};
                    for(key in src)if (src[key] !== undefined) (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
                    if (deep) jQuery1.extend(true, target, deep);
                    return target;
                }
                /* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */ function ajaxHandleResponses(s, jqXHR, responses) {
                    var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
                    // Remove auto dataType and get content-type in the process
                    while(dataTypes[0] === "*"){
                        dataTypes.shift();
                        if (ct === undefined) ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
                    }
                    // Check if we're dealing with a known content-type
                    if (ct) {
                        for(type in contents)if (contents[type] && contents[type].test(ct)) {
                            dataTypes.unshift(type);
                            break;
                        }
                    }
                    // Check to see if we have a response for the expected dataType
                    if (dataTypes[0] in responses) finalDataType = dataTypes[0];
                    else {
                        // Try convertible dataTypes
                        for(type in responses){
                            if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                                finalDataType = type;
                                break;
                            }
                            if (!firstDataType) firstDataType = type;
                        }
                        // Or just use first one
                        finalDataType = finalDataType || firstDataType;
                    }
                    // If we found a dataType
                    // We add the dataType to the list if needed
                    // and return the corresponding response
                    if (finalDataType) {
                        if (finalDataType !== dataTypes[0]) dataTypes.unshift(finalDataType);
                        return responses[finalDataType];
                    }
                }
                /* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */ function ajaxConvert(s, response, jqXHR, isSuccess) {
                    var conv2, current, conv, tmp, prev, converters = {}, // Work with a copy of dataTypes in case we need to modify it for conversion
                    dataTypes = s.dataTypes.slice();
                    // Create converters map with lowercased keys
                    if (dataTypes[1]) for(conv in s.converters)converters[conv.toLowerCase()] = s.converters[conv];
                    current = dataTypes.shift();
                    // Convert to each sequential dataType
                    while(current){
                        if (s.responseFields[current]) jqXHR[s.responseFields[current]] = response;
                        // Apply the dataFilter if provided
                        if (!prev && isSuccess && s.dataFilter) response = s.dataFilter(response, s.dataType);
                        prev = current;
                        current = dataTypes.shift();
                        if (current) {
                            // There's only work to do if current dataType is non-auto
                            if (current === "*") current = prev;
                            else if (prev !== "*" && prev !== current) {
                                // Seek a direct converter
                                conv = converters[prev + " " + current] || converters["* " + current];
                                // If none found, seek a pair
                                if (!conv) for(conv2 in converters){
                                    // If conv2 outputs current
                                    tmp = conv2.split(" ");
                                    if (tmp[1] === current) {
                                        // If prev can be converted to accepted input
                                        conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                                        if (conv) {
                                            // Condense equivalence converters
                                            if (conv === true) conv = converters[conv2];
                                            else if (converters[conv2] !== true) {
                                                current = tmp[0];
                                                dataTypes.unshift(tmp[1]);
                                            }
                                            break;
                                        }
                                    }
                                }
                                // Apply converter (if not an equivalence)
                                if (conv !== true) {
                                    // Unless errors are allowed to bubble, catch and return them
                                    if (conv && s.throws) response = conv(response);
                                    else try {
                                        response = conv(response);
                                    } catch (e) {
                                        return {
                                            state: "parsererror",
                                            error: conv ? e : "No conversion from " + prev + " to " + current
                                        };
                                    }
                                }
                            }
                        }
                    }
                    return {
                        state: "success",
                        data: response
                    };
                }
                jQuery1.extend({
                    // Counter for holding the number of active queries
                    active: 0,
                    // Last-Modified header cache for next request
                    lastModified: {},
                    etag: {},
                    ajaxSettings: {
                        url: location.href,
                        type: "GET",
                        isLocal: rlocalProtocol.test(location.protocol),
                        global: true,
                        processData: true,
                        async: true,
                        contentType: "application/x-www-form-urlencoded; charset=UTF-8",
                        /*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/ accepts: {
                            "*": allTypes,
                            text: "text/plain",
                            html: "text/html",
                            xml: "application/xml, text/xml",
                            json: "application/json, text/javascript"
                        },
                        contents: {
                            xml: /\bxml\b/,
                            html: /\bhtml/,
                            json: /\bjson\b/
                        },
                        responseFields: {
                            xml: "responseXML",
                            text: "responseText",
                            json: "responseJSON"
                        },
                        // Data converters
                        // Keys separate source (or catchall "*") and destination types with a single space
                        converters: {
                            // Convert anything to text
                            "* text": String,
                            // Text to html (true = no transformation)
                            "text html": true,
                            // Evaluate text as a json expression
                            "text json": JSON.parse,
                            // Parse text as xml
                            "text xml": jQuery1.parseXML
                        },
                        // For options that shouldn't be deep extended:
                        // you can add your own custom options here if
                        // and when you create one that shouldn't be
                        // deep extended (see ajaxExtend)
                        flatOptions: {
                            url: true,
                            context: true
                        }
                    },
                    // Creates a full fledged settings object into target
                    // with both ajaxSettings and settings fields.
                    // If target is omitted, writes into ajaxSettings.
                    ajaxSetup: function ajaxSetup(target, settings) {
                        return settings ? // Building a settings object
                        ajaxExtend(ajaxExtend(target, jQuery1.ajaxSettings), settings) : // Extending ajaxSettings
                        ajaxExtend(jQuery1.ajaxSettings, target);
                    },
                    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
                    ajaxTransport: addToPrefiltersOrTransports(transports),
                    // Main method
                    ajax: function ajax(url, options) {
                        // If url is an object, simulate pre-1.5 signature
                        if (typeof url === "object") {
                            options = url;
                            url = undefined;
                        }
                        // Force options to be an object
                        options = options || {};
                        var transport, // URL without anti-cache param
                        cacheURL, // Response headers
                        responseHeadersString, responseHeaders, // timeout handle
                        timeoutTimer, // Url cleanup var
                        urlAnchor, // Request state (becomes false upon send and true upon completion)
                        _$completed, // To know if global events are to be dispatched
                        fireGlobals, // Loop variable
                        i, // uncached part of the url
                        uncached, // Create the final options object
                        s = jQuery1.ajaxSetup({}, options), // Callbacks context
                        callbackContext = s.context || s, // Context for global events is callbackContext if it is a DOM node or jQuery collection
                        globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery1(callbackContext) : jQuery1.event, // Deferreds
                        deferred = jQuery1.Deferred(), completeDeferred = jQuery1.Callbacks("once memory"), // Status-dependent callbacks
                        statusCode = s.statusCode || {}, // Headers (they are sent all at once)
                        requestHeaders = {}, requestHeadersNames = {}, // Default abort message
                        strAbort = "canceled", // Fake xhr
                        jqXHR = {
                            readyState: 0,
                            // Builds headers hashtable if needed
                            getResponseHeader: function getResponseHeader(key) {
                                var match;
                                if (_$completed) {
                                    if (!responseHeaders) {
                                        responseHeaders = {};
                                        while(match = rheaders.exec(responseHeadersString))responseHeaders[match[1].toLowerCase() + " "] = (responseHeaders[match[1].toLowerCase() + " "] || []).concat(match[2]);
                                    }
                                    match = responseHeaders[key.toLowerCase() + " "];
                                }
                                return match == null ? null : match.join(", ");
                            },
                            // Raw string
                            getAllResponseHeaders: function getAllResponseHeaders() {
                                return _$completed ? responseHeadersString : null;
                            },
                            // Caches the header
                            setRequestHeader: function setRequestHeader(name, value) {
                                if (_$completed == null) {
                                    name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
                                    requestHeaders[name] = value;
                                }
                                return this;
                            },
                            // Overrides response content-type header
                            overrideMimeType: function overrideMimeType(type) {
                                if (_$completed == null) s.mimeType = type;
                                return this;
                            },
                            // Status-dependent callbacks
                            statusCode: function statusCode1(map) {
                                var code;
                                if (map) {
                                    if (_$completed) // Execute the appropriate callbacks
                                    jqXHR.always(map[jqXHR.status]);
                                    else // Lazy-add the new callbacks in a way that preserves old ones
                                    for(code in map)statusCode[code] = [
                                        statusCode[code],
                                        map[code]
                                    ];
                                }
                                return this;
                            },
                            // Cancel the request
                            abort: function abort(statusText) {
                                var finalText = statusText || strAbort;
                                if (transport) transport.abort(finalText);
                                done(0, finalText);
                                return this;
                            }
                        };
                        // Attach deferreds
                        deferred.promise(jqXHR);
                        // Add protocol if not provided (prefilters might expect it)
                        // Handle falsy url in the settings object (trac-10093: consistency with old signature)
                        // We also use the url parameter if available
                        s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//");
                        // Alias method option to type as per ticket trac-12004
                        s.type = options.method || options.type || s.method || s.type;
                        // Extract dataTypes list
                        s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [
                            ""
                        ];
                        // A cross-domain request is in order when the origin doesn't match the current origin.
                        if (s.crossDomain == null) {
                            urlAnchor = document1.createElement("a");
                            // Support: IE <=8 - 11, Edge 12 - 15
                            // IE throws exception on accessing the href property if url is malformed,
                            // e.g. http://example.com:80x/
                            try {
                                urlAnchor.href = s.url;
                                // Support: IE <=8 - 11 only
                                // Anchor's host property isn't correctly set when s.url is relative
                                urlAnchor.href = urlAnchor.href;
                                s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
                            } catch (e) {
                                // If there is an error parsing the URL, assume it is crossDomain,
                                // it can be rejected by the transport if it is invalid
                                s.crossDomain = true;
                            }
                        }
                        // Convert data if not already a string
                        if (s.data && s.processData && typeof s.data !== "string") s.data = jQuery1.param(s.data, s.traditional);
                        // Apply prefilters
                        inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
                        // If request was aborted inside a prefilter, stop there
                        if (_$completed) return jqXHR;
                        // We can fire global events as of now if asked to
                        // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (trac-15118)
                        fireGlobals = jQuery1.event && s.global;
                        // Watch for a new set of requests
                        if (fireGlobals && jQuery1.active++ === 0) jQuery1.event.trigger("ajaxStart");
                        // Uppercase the type
                        s.type = s.type.toUpperCase();
                        // Determine if request has content
                        s.hasContent = !rnoContent.test(s.type);
                        // Save the URL in case we're toying with the If-Modified-Since
                        // and/or If-None-Match header later on
                        // Remove hash to simplify url manipulation
                        cacheURL = s.url.replace(rhash, "");
                        // More options handling for requests with no content
                        if (!s.hasContent) {
                            // Remember the hash so we can put it back
                            uncached = s.url.slice(cacheURL.length);
                            // If data is available and should be processed, append data to url
                            if (s.data && (s.processData || typeof s.data === "string")) {
                                cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data;
                                // trac-9682: remove data so that it's not used in an eventual retry
                                delete s.data;
                            }
                            // Add or update anti-cache param if needed
                            if (s.cache === false) {
                                cacheURL = cacheURL.replace(rantiCache, "$1");
                                uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached;
                            }
                            // Put hash and anti-cache on the URL that will be requested (gh-1732)
                            s.url = cacheURL + uncached;
                        // Change '%20' to '+' if this is encoded form body content (gh-2658)
                        } else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) s.data = s.data.replace(r20, "+");
                        // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                        if (s.ifModified) {
                            if (jQuery1.lastModified[cacheURL]) jqXHR.setRequestHeader("If-Modified-Since", jQuery1.lastModified[cacheURL]);
                            if (jQuery1.etag[cacheURL]) jqXHR.setRequestHeader("If-None-Match", jQuery1.etag[cacheURL]);
                        }
                        // Set the correct header, if data is being sent
                        if (s.data && s.hasContent && s.contentType !== false || options.contentType) jqXHR.setRequestHeader("Content-Type", s.contentType);
                        // Set the Accepts header for the server, depending on the dataType
                        jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
                        // Check for headers option
                        for(i in s.headers)jqXHR.setRequestHeader(i, s.headers[i]);
                        // Allow custom headers/mimetypes and early abort
                        if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || _$completed)) // Abort if not done already and return
                        return jqXHR.abort();
                        // Aborting is no longer a cancellation
                        strAbort = "abort";
                        // Install callbacks on deferreds
                        completeDeferred.add(s.complete);
                        jqXHR.done(s.success);
                        jqXHR.fail(s.error);
                        // Get transport
                        transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
                        // If no transport, we auto-abort
                        if (!transport) done(-1, "No Transport");
                        else {
                            jqXHR.readyState = 1;
                            // Send global event
                            if (fireGlobals) globalEventContext.trigger("ajaxSend", [
                                jqXHR,
                                s
                            ]);
                            // If request was aborted inside ajaxSend, stop there
                            if (_$completed) return jqXHR;
                            // Timeout
                            if (s.async && s.timeout > 0) timeoutTimer = window1.setTimeout(function() {
                                jqXHR.abort("timeout");
                            }, s.timeout);
                            try {
                                _$completed = false;
                                transport.send(requestHeaders, done);
                            } catch (e) {
                                // Rethrow post-completion exceptions
                                if (_$completed) throw e;
                                // Propagate others as results
                                done(-1, e);
                            }
                        }
                        // Callback for when everything is done
                        function done(status, nativeStatusText, responses, headers) {
                            var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                            // Ignore repeat invocations
                            if (_$completed) return;
                            _$completed = true;
                            // Clear timeout if it exists
                            if (timeoutTimer) window1.clearTimeout(timeoutTimer);
                            // Dereference transport for early garbage collection
                            // (no matter how long the jqXHR object will be used)
                            transport = undefined;
                            // Cache response headers
                            responseHeadersString = headers || "";
                            // Set readyState
                            jqXHR.readyState = status > 0 ? 4 : 0;
                            // Determine if successful
                            isSuccess = status >= 200 && status < 300 || status === 304;
                            // Get response data
                            if (responses) response = ajaxHandleResponses(s, jqXHR, responses);
                            // Use a noop converter for missing script but not if jsonp
                            if (!isSuccess && jQuery1.inArray("script", s.dataTypes) > -1 && jQuery1.inArray("json", s.dataTypes) < 0) s.converters["text script"] = function() {};
                            // Convert no matter what (that way responseXXX fields are always set)
                            response = ajaxConvert(s, response, jqXHR, isSuccess);
                            // If successful, handle type chaining
                            if (isSuccess) {
                                // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                                if (s.ifModified) {
                                    modified = jqXHR.getResponseHeader("Last-Modified");
                                    if (modified) jQuery1.lastModified[cacheURL] = modified;
                                    modified = jqXHR.getResponseHeader("etag");
                                    if (modified) jQuery1.etag[cacheURL] = modified;
                                }
                                // if no content
                                if (status === 204 || s.type === "HEAD") statusText = "nocontent";
                                else if (status === 304) statusText = "notmodified";
                                else {
                                    statusText = response.state;
                                    success = response.data;
                                    error = response.error;
                                    isSuccess = !error;
                                }
                            } else {
                                // Extract error from statusText and normalize for non-aborts
                                error = statusText;
                                if (status || !statusText) {
                                    statusText = "error";
                                    if (status < 0) status = 0;
                                }
                            }
                            // Set data for the fake xhr object
                            jqXHR.status = status;
                            jqXHR.statusText = (nativeStatusText || statusText) + "";
                            // Success/Error
                            if (isSuccess) deferred.resolveWith(callbackContext, [
                                success,
                                statusText,
                                jqXHR
                            ]);
                            else deferred.rejectWith(callbackContext, [
                                jqXHR,
                                statusText,
                                error
                            ]);
                            // Status-dependent callbacks
                            jqXHR.statusCode(statusCode);
                            statusCode = undefined;
                            if (fireGlobals) globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [
                                jqXHR,
                                s,
                                isSuccess ? success : error
                            ]);
                            // Complete
                            completeDeferred.fireWith(callbackContext, [
                                jqXHR,
                                statusText
                            ]);
                            if (fireGlobals) {
                                globalEventContext.trigger("ajaxComplete", [
                                    jqXHR,
                                    s
                                ]);
                                // Handle the global AJAX counter
                                if (!--jQuery1.active) jQuery1.event.trigger("ajaxStop");
                            }
                        }
                        return jqXHR;
                    },
                    getJSON: function getJSON(url, data, callback) {
                        return jQuery1.get(url, data, callback, "json");
                    },
                    getScript: function getScript(url, callback) {
                        return jQuery1.get(url, undefined, callback, "script");
                    }
                });
                jQuery1.each([
                    "get",
                    "post"
                ], function(_i, method) {
                    jQuery1[method] = function(url, data, callback, type) {
                        // Shift arguments if data argument was omitted
                        if (isFunction(data)) {
                            type = type || callback;
                            callback = data;
                            data = undefined;
                        }
                        // The url can be an options object (which then must have .url)
                        return jQuery1.ajax(jQuery1.extend({
                            url: url,
                            type: method,
                            dataType: type,
                            data: data,
                            success: callback
                        }, jQuery1.isPlainObject(url) && url));
                    };
                });
                jQuery1.ajaxPrefilter(function(s) {
                    var i;
                    for(i in s.headers)if (i.toLowerCase() === "content-type") s.contentType = s.headers[i] || "";
                });
                jQuery1._evalUrl = function(url, options, doc) {
                    return jQuery1.ajax({
                        url: url,
                        // Make this explicit, since user can override this through ajaxSetup (trac-11264)
                        type: "GET",
                        dataType: "script",
                        cache: true,
                        async: false,
                        global: false,
                        // Only evaluate the response if it is successful (gh-4126)
                        // dataFilter is not invoked for failure responses, so using it instead
                        // of the default converter is kludgy but it works.
                        converters: {
                            "text script": function() {}
                        },
                        dataFilter: function dataFilter(response) {
                            jQuery1.globalEval(response, options, doc);
                        }
                    });
                };
                jQuery1.fn.extend({
                    wrapAll: function wrapAll(html) {
                        var wrap;
                        if (this[0]) {
                            if (isFunction(html)) html = html.call(this[0]);
                            // The elements to wrap the target around
                            wrap = jQuery1(html, this[0].ownerDocument).eq(0).clone(true);
                            if (this[0].parentNode) wrap.insertBefore(this[0]);
                            wrap.map(function() {
                                var elem = this;
                                while(elem.firstElementChild)elem = elem.firstElementChild;
                                return elem;
                            }).append(this);
                        }
                        return this;
                    },
                    wrapInner: function wrapInner(html) {
                        if (isFunction(html)) return this.each(function(i) {
                            jQuery1(this).wrapInner(html.call(this, i));
                        });
                        return this.each(function() {
                            var self1 = jQuery1(this), contents = self1.contents();
                            if (contents.length) contents.wrapAll(html);
                            else self1.append(html);
                        });
                    },
                    wrap: function wrap(html) {
                        var htmlIsFunction = isFunction(html);
                        return this.each(function(i) {
                            jQuery1(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
                        });
                    },
                    unwrap: function unwrap(selector) {
                        this.parent(selector).not("body").each(function() {
                            jQuery1(this).replaceWith(this.childNodes);
                        });
                        return this;
                    }
                });
                jQuery1.expr.pseudos.hidden = function(elem) {
                    return !jQuery1.expr.pseudos.visible(elem);
                };
                jQuery1.expr.pseudos.visible = function(elem) {
                    return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
                };
                jQuery1.ajaxSettings.xhr = function() {
                    try {
                        return new window1.XMLHttpRequest();
                    } catch (e) {}
                };
                var xhrSuccessStatus = {
                    // File protocol always yields status code 0, assume 200
                    0: 200,
                    // Support: IE <=9 only
                    // trac-1450: sometimes IE returns 1223 when it should be 204
                    1223: 204
                }, xhrSupported = jQuery1.ajaxSettings.xhr();
                support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
                support.ajax = xhrSupported = !!xhrSupported;
                jQuery1.ajaxTransport(function(options) {
                    var callback, errorCallback;
                    // Cross domain only allowed if supported through XMLHttpRequest
                    if (support.cors || xhrSupported && !options.crossDomain) return {
                        send: function send(headers, complete) {
                            var i, xhr = options.xhr();
                            xhr.open(options.type, options.url, options.async, options.username, options.password);
                            // Apply custom fields if provided
                            if (options.xhrFields) for(i in options.xhrFields)xhr[i] = options.xhrFields[i];
                            // Override mime type if needed
                            if (options.mimeType && xhr.overrideMimeType) xhr.overrideMimeType(options.mimeType);
                            // X-Requested-With header
                            // For cross-domain requests, seeing as conditions for a preflight are
                            // akin to a jigsaw puzzle, we simply never set it to be sure.
                            // (it can always be set on a per-request basis or even using ajaxSetup)
                            // For same-domain requests, won't change header if already provided.
                            if (!options.crossDomain && !headers["X-Requested-With"]) headers["X-Requested-With"] = "XMLHttpRequest";
                            // Set headers
                            for(i in headers)xhr.setRequestHeader(i, headers[i]);
                            // Callback
                            callback = function(type) {
                                return function() {
                                    if (callback) {
                                        callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;
                                        if (type === "abort") xhr.abort();
                                        else if (type === "error") {
                                            // Support: IE <=9 only
                                            // On a manual native abort, IE9 throws
                                            // errors on any property access that is not readyState
                                            if (typeof xhr.status !== "number") complete(0, "error");
                                            else complete(// File: protocol always yields status 0; see trac-8605, trac-14207
                                            xhr.status, xhr.statusText);
                                        } else complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, // Support: IE <=9 only
                                        // IE9 has no XHR2 but throws on binary (trac-11426)
                                        // For XHR2 non-text, let the caller handle it (gh-2498)
                                        (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? {
                                            binary: xhr.response
                                        } : {
                                            text: xhr.responseText
                                        }, xhr.getAllResponseHeaders());
                                    }
                                };
                            };
                            // Listen to events
                            xhr.onload = callback();
                            errorCallback = xhr.onerror = xhr.ontimeout = callback("error");
                            // Support: IE 9 only
                            // Use onreadystatechange to replace onabort
                            // to handle uncaught aborts
                            if (xhr.onabort !== undefined) xhr.onabort = errorCallback;
                            else xhr.onreadystatechange = function() {
                                // Check readyState before timeout as it changes
                                if (xhr.readyState === 4) // Allow onerror to be called first,
                                // but that will not handle a native abort
                                // Also, save errorCallback to a variable
                                // as xhr.onerror cannot be accessed
                                window1.setTimeout(function() {
                                    if (callback) errorCallback();
                                });
                            };
                            // Create the abort callback
                            callback = callback("abort");
                            try {
                                // Do send the request (this may raise an exception)
                                xhr.send(options.hasContent && options.data || null);
                            } catch (e) {
                                // trac-14683: Only rethrow if this hasn't been notified as an error yet
                                if (callback) throw e;
                            }
                        },
                        abort: function abort() {
                            if (callback) callback();
                        }
                    };
                });
                // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
                jQuery1.ajaxPrefilter(function(s) {
                    if (s.crossDomain) s.contents.script = false;
                });
                // Install script dataType
                jQuery1.ajaxSetup({
                    accepts: {
                        script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
                    },
                    contents: {
                        script: /\b(?:java|ecma)script\b/
                    },
                    converters: {
                        "text script": function(text) {
                            jQuery1.globalEval(text);
                            return text;
                        }
                    }
                });
                // Handle cache's special case and crossDomain
                jQuery1.ajaxPrefilter("script", function(s) {
                    if (s.cache === undefined) s.cache = false;
                    if (s.crossDomain) s.type = "GET";
                });
                // Bind script tag hack transport
                jQuery1.ajaxTransport("script", function(s) {
                    // This transport only deals with cross domain or forced-by-attrs requests
                    if (s.crossDomain || s.scriptAttrs) {
                        var script, callback;
                        return {
                            send: function send(_, complete) {
                                script = jQuery1("<script>").attr(s.scriptAttrs || {}).prop({
                                    charset: s.scriptCharset,
                                    src: s.url
                                }).on("load error", callback = function(evt) {
                                    script.remove();
                                    callback = null;
                                    if (evt) complete(evt.type === "error" ? 404 : 200, evt.type);
                                });
                                // Use native DOM manipulation to avoid our domManip AJAX trickery
                                document1.head.appendChild(script[0]);
                            },
                            abort: function abort() {
                                if (callback) callback();
                            }
                        };
                    }
                });
                var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
                // Default jsonp settings
                jQuery1.ajaxSetup({
                    jsonp: "callback",
                    jsonpCallback: function jsonpCallback() {
                        var callback = oldCallbacks.pop() || jQuery1.expando + "_" + nonce.guid++;
                        this[callback] = true;
                        return callback;
                    }
                });
                // Detect, normalize options and install callbacks for jsonp requests
                jQuery1.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
                    var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");
                    // Handle iff the expected data type is "jsonp" or we have a parameter to set
                    if (jsonProp || s.dataTypes[0] === "jsonp") {
                        // Get callback name, remembering preexisting value associated with it
                        callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
                        // Insert callback into url or form data
                        if (jsonProp) s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
                        else if (s.jsonp !== false) s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
                        // Use data converter to retrieve json after script execution
                        s.converters["script json"] = function() {
                            if (!responseContainer) jQuery1.error(callbackName + " was not called");
                            return responseContainer[0];
                        };
                        // Force json dataType
                        s.dataTypes[0] = "json";
                        // Install callback
                        overwritten = window1[callbackName];
                        window1[callbackName] = function() {
                            responseContainer = arguments;
                        };
                        // Clean-up function (fires after converters)
                        jqXHR.always(function() {
                            // If previous value didn't exist - remove it
                            if (overwritten === undefined) jQuery1(window1).removeProp(callbackName);
                            else window1[callbackName] = overwritten;
                            // Save back as free
                            if (s[callbackName]) {
                                // Make sure that re-using the options doesn't screw things around
                                s.jsonpCallback = originalSettings.jsonpCallback;
                                // Save the callback name for future use
                                oldCallbacks.push(callbackName);
                            }
                            // Call if it was a function and we have a response
                            if (responseContainer && isFunction(overwritten)) overwritten(responseContainer[0]);
                            responseContainer = overwritten = undefined;
                        });
                        // Delegate to script
                        return "script";
                    }
                });
                // Support: Safari 8 only
                // In Safari 8 documents created via document.implementation.createHTMLDocument
                // collapse sibling forms: the second one becomes a child of the first one.
                // Because of that, this security measure has to be disabled in Safari 8.
                // https://bugs.webkit.org/show_bug.cgi?id=137337
                support.createHTMLDocument = function() {
                    var body = document1.implementation.createHTMLDocument("").body;
                    body.innerHTML = "<form></form><form></form>";
                    return body.childNodes.length === 2;
                }();
                // Argument "data" should be string of html
                // context (optional): If specified, the fragment will be created in this context,
                // defaults to document
                // keepScripts (optional): If true, will include scripts passed in the html string
                jQuery1.parseHTML = function(data, context, keepScripts) {
                    if (typeof data !== "string") return [];
                    if (typeof context === "boolean") {
                        keepScripts = context;
                        context = false;
                    }
                    var base, parsed, scripts;
                    if (!context) {
                        // Stop scripts or inline event handlers from being executed immediately
                        // by using document.implementation
                        if (support.createHTMLDocument) {
                            context = document1.implementation.createHTMLDocument("");
                            // Set the base href for the created document
                            // so any parsed elements with URLs
                            // are based on the document's URL (gh-2965)
                            base = context.createElement("base");
                            base.href = document1.location.href;
                            context.head.appendChild(base);
                        } else context = document1;
                    }
                    parsed = rsingleTag.exec(data);
                    scripts = !keepScripts && [];
                    // Single tag
                    if (parsed) return [
                        context.createElement(parsed[1])
                    ];
                    parsed = buildFragment([
                        data
                    ], context, scripts);
                    if (scripts && scripts.length) jQuery1(scripts).remove();
                    return jQuery1.merge([], parsed.childNodes);
                };
                /**
 * Load a url into a page
 */ jQuery1.fn.load = function(url, params, callback) {
                    var selector, type, response, self1 = this, off = url.indexOf(" ");
                    if (off > -1) {
                        selector = stripAndCollapse(url.slice(off));
                        url = url.slice(0, off);
                    }
                    // If it's a function
                    if (isFunction(params)) {
                        // We assume that it's the callback
                        callback = params;
                        params = undefined;
                    // Otherwise, build a param string
                    } else if (params && typeof params === "object") type = "POST";
                    // If we have elements to modify, make the request
                    if (self1.length > 0) jQuery1.ajax({
                        url: url,
                        // If "type" variable is undefined, then "GET" method will be used.
                        // Make value of this field explicit since
                        // user can override it through ajaxSetup method
                        type: type || "GET",
                        dataType: "html",
                        data: params
                    }).done(function(responseText) {
                        // Save response for use in complete callback
                        response = arguments;
                        self1.html(selector ? // If a selector was specified, locate the right elements in a dummy div
                        // Exclude scripts to avoid IE 'Permission Denied' errors
                        jQuery1("<div>").append(jQuery1.parseHTML(responseText)).find(selector) : // Otherwise use the full result
                        responseText);
                    // If the request succeeds, this function gets "data", "status", "jqXHR"
                    // but they are ignored because response was set above.
                    // If it fails, this function gets "jqXHR", "status", "error"
                    }).always(callback && function(jqXHR, status) {
                        self1.each(function() {
                            callback.apply(this, response || [
                                jqXHR.responseText,
                                status,
                                jqXHR
                            ]);
                        });
                    });
                    return this;
                };
                jQuery1.expr.pseudos.animated = function(elem) {
                    return jQuery1.grep(jQuery1.timers, function(fn) {
                        return elem === fn.elem;
                    }).length;
                };
                jQuery1.offset = {
                    setOffset: function setOffset(elem, options, i) {
                        var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery1.css(elem, "position"), curElem = jQuery1(elem), props = {};
                        // Set position first, in-case top/left are set even on static elem
                        if (position === "static") elem.style.position = "relative";
                        curOffset = curElem.offset();
                        curCSSTop = jQuery1.css(elem, "top");
                        curCSSLeft = jQuery1.css(elem, "left");
                        calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
                        // Need to be able to calculate position if either
                        // top or left is auto and position is either absolute or fixed
                        if (calculatePosition) {
                            curPosition = curElem.position();
                            curTop = curPosition.top;
                            curLeft = curPosition.left;
                        } else {
                            curTop = parseFloat(curCSSTop) || 0;
                            curLeft = parseFloat(curCSSLeft) || 0;
                        }
                        if (isFunction(options)) // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
                        options = options.call(elem, i, jQuery1.extend({}, curOffset));
                        if (options.top != null) props.top = options.top - curOffset.top + curTop;
                        if (options.left != null) props.left = options.left - curOffset.left + curLeft;
                        if ("using" in options) options.using.call(elem, props);
                        else curElem.css(props);
                    }
                };
                jQuery1.fn.extend({
                    // offset() relates an element's border box to the document origin
                    offset: function offset(options) {
                        // Preserve chaining for setter
                        if (arguments.length) return options === undefined ? this : this.each(function(i) {
                            jQuery1.offset.setOffset(this, options, i);
                        });
                        var rect, win, elem = this[0];
                        if (!elem) return;
                        // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
                        // Support: IE <=11 only
                        // Running getBoundingClientRect on a
                        // disconnected node in IE throws an error
                        if (!elem.getClientRects().length) return {
                            top: 0,
                            left: 0
                        };
                        // Get document-relative position by adding viewport scroll to viewport-relative gBCR
                        rect = elem.getBoundingClientRect();
                        win = elem.ownerDocument.defaultView;
                        return {
                            top: rect.top + win.pageYOffset,
                            left: rect.left + win.pageXOffset
                        };
                    },
                    // position() relates an element's margin box to its offset parent's padding box
                    // This corresponds to the behavior of CSS absolute positioning
                    position: function position() {
                        if (!this[0]) return;
                        var offsetParent, offset, doc, elem = this[0], parentOffset = {
                            top: 0,
                            left: 0
                        };
                        // position:fixed elements are offset from the viewport, which itself always has zero offset
                        if (jQuery1.css(elem, "position") === "fixed") // Assume position:fixed implies availability of getBoundingClientRect
                        offset = elem.getBoundingClientRect();
                        else {
                            offset = this.offset();
                            // Account for the *real* offset parent, which can be the document or its root element
                            // when a statically positioned element is identified
                            doc = elem.ownerDocument;
                            offsetParent = elem.offsetParent || doc.documentElement;
                            while(offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery1.css(offsetParent, "position") === "static")offsetParent = offsetParent.parentNode;
                            if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
                                // Incorporate borders into its offset, since they are outside its content origin
                                parentOffset = jQuery1(offsetParent).offset();
                                parentOffset.top += jQuery1.css(offsetParent, "borderTopWidth", true);
                                parentOffset.left += jQuery1.css(offsetParent, "borderLeftWidth", true);
                            }
                        }
                        // Subtract parent offsets and element margins
                        return {
                            top: offset.top - parentOffset.top - jQuery1.css(elem, "marginTop", true),
                            left: offset.left - parentOffset.left - jQuery1.css(elem, "marginLeft", true)
                        };
                    },
                    // This method will return documentElement in the following cases:
                    // 1) For the element inside the iframe without offsetParent, this method will return
                    //    documentElement of the parent window
                    // 2) For the hidden or detached element
                    // 3) For body or html element, i.e. in case of the html node - it will return itself
                    //
                    // but those exceptions were never presented as a real life use-cases
                    // and might be considered as more preferable results.
                    //
                    // This logic, however, is not guaranteed and can change at any point in the future
                    offsetParent: function offsetParent() {
                        return this.map(function() {
                            var offsetParent = this.offsetParent;
                            while(offsetParent && jQuery1.css(offsetParent, "position") === "static")offsetParent = offsetParent.offsetParent;
                            return offsetParent || documentElement;
                        });
                    }
                });
                // Create scrollLeft and scrollTop methods
                jQuery1.each({
                    scrollLeft: "pageXOffset",
                    scrollTop: "pageYOffset"
                }, function(method, prop) {
                    var top = "pageYOffset" === prop;
                    jQuery1.fn[method] = function(val) {
                        return access(this, function(elem, method, val) {
                            // Coalesce documents and windows
                            var win;
                            if (isWindow(elem)) win = elem;
                            else if (elem.nodeType === 9) win = elem.defaultView;
                            if (val === undefined) return win ? win[prop] : elem[method];
                            if (win) win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
                            else elem[method] = val;
                        }, method, val, arguments.length);
                    };
                });
                // Support: Safari <=7 - 9.1, Chrome <=37 - 49
                // Add the top/left cssHooks using jQuery.fn.position
                // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
                // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
                // getComputedStyle returns percent when specified for top/left/bottom/right;
                // rather than make the css module depend on the offset module, just check for it here
                jQuery1.each([
                    "top",
                    "left"
                ], function(_i, prop) {
                    jQuery1.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
                        if (computed) {
                            computed = curCSS(elem, prop);
                            // If curCSS returns percentage, fallback to offset
                            return rnumnonpx.test(computed) ? jQuery1(elem).position()[prop] + "px" : computed;
                        }
                    });
                });
                // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
                jQuery1.each({
                    Height: "height",
                    Width: "width"
                }, function(name, type) {
                    jQuery1.each({
                        padding: "inner" + name,
                        content: type,
                        "": "outer" + name
                    }, function(defaultExtra, funcName) {
                        // Margin is only for outerHeight, outerWidth
                        jQuery1.fn[funcName] = function(margin, value) {
                            var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
                            return access(this, function(elem, type, value) {
                                var doc;
                                if (isWindow(elem)) // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
                                return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
                                // Get document width or height
                                if (elem.nodeType === 9) {
                                    doc = elem.documentElement;
                                    // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
                                    // whichever is greatest
                                    return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
                                }
                                return value === undefined ? // Get width or height on the element, requesting but not forcing parseFloat
                                jQuery1.css(elem, type, extra) : // Set width or height on the element
                                jQuery1.style(elem, type, value, extra);
                            }, type, chainable ? margin : undefined, chainable);
                        };
                    });
                });
                jQuery1.each([
                    "ajaxStart",
                    "ajaxStop",
                    "ajaxComplete",
                    "ajaxError",
                    "ajaxSuccess",
                    "ajaxSend"
                ], function(_i, type) {
                    jQuery1.fn[type] = function(fn) {
                        return this.on(type, fn);
                    };
                });
                jQuery1.fn.extend({
                    bind: function bind(types, data, fn) {
                        return this.on(types, null, data, fn);
                    },
                    unbind: function unbind(types, fn) {
                        return this.off(types, null, fn);
                    },
                    delegate: function delegate(selector, types, data, fn) {
                        return this.on(types, selector, data, fn);
                    },
                    undelegate: function undelegate(selector, types, fn) {
                        // ( namespace ) or ( selector, types [, fn] )
                        return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
                    },
                    hover: function hover(fnOver, fnOut) {
                        return this.on("mouseenter", fnOver).on("mouseleave", fnOut || fnOver);
                    }
                });
                jQuery1.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function(_i, name) {
                    // Handle event binding
                    jQuery1.fn[name] = function(data, fn) {
                        return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
                    };
                });
                // Support: Android <=4.0 only
                // Make sure we trim BOM and NBSP
                // Require that the "whitespace run" starts from a non-whitespace
                // to avoid O(N^2) behavior when the engine would try matching "\s+$" at each space position.
                var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;
                // Bind a function to a context, optionally partially applying any
                // arguments.
                // jQuery.proxy is deprecated to promote standards (specifically Function#bind)
                // However, it is not slated for removal any time soon
                jQuery1.proxy = function(fn, context) {
                    var tmp, args, proxy;
                    if (typeof context === "string") {
                        tmp = fn[context];
                        context = fn;
                        fn = tmp;
                    }
                    // Quick check to determine if target is callable, in the spec
                    // this throws a TypeError, but we will just return undefined.
                    if (!isFunction(fn)) return undefined;
                    // Simulated bind
                    args = slice.call(arguments, 2);
                    proxy = function proxy() {
                        return fn.apply(context || this, args.concat(slice.call(arguments)));
                    };
                    // Set the guid of unique handler to the same of original handler, so it can be removed
                    proxy.guid = fn.guid = fn.guid || jQuery1.guid++;
                    return proxy;
                };
                jQuery1.holdReady = function(hold) {
                    if (hold) jQuery1.readyWait++;
                    else jQuery1.ready(true);
                };
                jQuery1.isArray = Array.isArray;
                jQuery1.parseJSON = JSON.parse;
                jQuery1.nodeName = nodeName;
                jQuery1.isFunction = isFunction;
                jQuery1.isWindow = isWindow;
                jQuery1.camelCase = camelCase;
                jQuery1.type = toType;
                jQuery1.now = Date.now;
                jQuery1.isNumeric = function(obj) {
                    // As of jQuery 3.0, isNumeric is limited to
                    // strings and numbers (primitives or objects)
                    // that can be coerced to finite numbers (gh-2662)
                    var type = jQuery1.type(obj);
                    return (type === "number" || type === "string") && // parseFloat NaNs numeric-cast false positives ("")
                    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
                    // subtraction forces infinities to NaN
                    !isNaN(obj - parseFloat(obj));
                };
                jQuery1.trim = function(text) {
                    return text == null ? "" : (text + "").replace(rtrim, "$1");
                };
                // Register as a named AMD module, since jQuery can be concatenated with other
                // files that may use define, but not via a proper concatenation script that
                // understands anonymous AMD modules. A named AMD is safest and most robust
                // way to register. Lowercase jquery is used because AMD module names are
                // derived from file names, and jQuery is normally delivered in a lowercase
                // file name. Do this after creating the global so that if an AMD module wants
                // to call noConflict to hide this version of jQuery, it will work.
                // Note that for maximum portability, libraries that are not jQuery should
                // declare themselves as anonymous modules, and avoid setting a global if an
                // AMD loader is present. jQuery is a special case. For more information, see
                // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon
                if (typeof define === "function" && define.amd) define("jquery", [], function() {
                    return jQuery1;
                });
                var // Map over jQuery in case of overwrite
                _jQuery = window1.jQuery, // Map over the $ in case of overwrite
                _$ = window1.$;
                jQuery1.noConflict = function(deep) {
                    if (window1.$ === jQuery1) window1.$ = _$;
                    if (deep && window1.jQuery === jQuery1) window1.jQuery = _jQuery;
                    return jQuery1;
                };
                // Expose jQuery and $ identifiers, even in AMD
                // (trac-7102#comment:10, https://github.com/jquery/jquery/pull/557)
                // and CommonJS for browser emulators (trac-13566)
                if (typeof noGlobal === "undefined") window1.jQuery = window1.$ = jQuery1;
                return jQuery1;
            });
        },
        {}
    ],
    15: [
        function(require1, module, exports) {
            /*!
 * Masonry v4.2.2
 * Cascading grid layout library
 * https://masonry.desandro.com
 * MIT License
 * by David DeSandro
 */ (function(window1, factory) {
                // universal module definition
                /* jshint strict: false */ /*globals define, module, require */ if (typeof define == "function" && define.amd) // AMD
                define([
                    "outlayer/outlayer",
                    "get-size/get-size"
                ], factory);
                else if (typeof module == "object" && module.exports) // CommonJS
                module.exports = factory(require1("outlayer"), require1("get-size"));
                else // browser global
                window1.Masonry = factory(window1.Outlayer, window1.getSize);
            })(window, function factory(Outlayer, getSize) {
                "use strict";
                // -------------------------- masonryDefinition -------------------------- //
                // create an Outlayer layout class
                var Masonry = Outlayer.create("masonry");
                // isFitWidth -> fitWidth
                Masonry.compatOptions.fitWidth = "isFitWidth";
                var proto = Masonry.prototype;
                proto._resetLayout = function() {
                    this.getSize();
                    this._getMeasurement("columnWidth", "outerWidth");
                    this._getMeasurement("gutter", "outerWidth");
                    this.measureColumns();
                    // reset column Y
                    this.colYs = [];
                    for(var i = 0; i < this.cols; i++)this.colYs.push(0);
                    this.maxY = 0;
                    this.horizontalColIndex = 0;
                };
                proto.measureColumns = function() {
                    this.getContainerWidth();
                    // if columnWidth is 0, default to outerWidth of first item
                    if (!this.columnWidth) {
                        var firstItem = this.items[0];
                        var firstItemElem = firstItem && firstItem.element;
                        // columnWidth fall back to item of first element
                        this.columnWidth = firstItemElem && getSize(firstItemElem).outerWidth || // if first elem has no width, default to size of container
                        this.containerWidth;
                    }
                    var columnWidth = this.columnWidth += this.gutter;
                    // calculate columns
                    var containerWidth = this.containerWidth + this.gutter;
                    var cols = containerWidth / columnWidth;
                    // fix rounding errors, typically with gutters
                    var excess = columnWidth - containerWidth % columnWidth;
                    // if overshoot is less than a pixel, round up, otherwise floor it
                    var mathMethod = excess && excess < 1 ? "round" : "floor";
                    cols = Math[mathMethod](cols);
                    this.cols = Math.max(cols, 1);
                };
                proto.getContainerWidth = function() {
                    // container is parent if fit width
                    var isFitWidth = this._getOption("fitWidth");
                    var container = isFitWidth ? this.element.parentNode : this.element;
                    // check that this.size and size are there
                    // IE8 triggers resize on body size change, so they might not be
                    var size = getSize(container);
                    this.containerWidth = size && size.innerWidth;
                };
                proto._getItemLayoutPosition = function(item) {
                    item.getSize();
                    // how many columns does this brick span
                    var remainder = item.size.outerWidth % this.columnWidth;
                    var mathMethod = remainder && remainder < 1 ? "round" : "ceil";
                    // round if off by 1 pixel, otherwise use ceil
                    var colSpan = Math[mathMethod](item.size.outerWidth / this.columnWidth);
                    colSpan = Math.min(colSpan, this.cols);
                    // use horizontal or top column position
                    var colPosMethod = this.options.horizontalOrder ? "_getHorizontalColPosition" : "_getTopColPosition";
                    var colPosition = this[colPosMethod](colSpan, item);
                    // position the brick
                    var position = {
                        x: this.columnWidth * colPosition.col,
                        y: colPosition.y
                    };
                    // apply setHeight to necessary columns
                    var setHeight = colPosition.y + item.size.outerHeight;
                    var setMax = colSpan + colPosition.col;
                    for(var i = colPosition.col; i < setMax; i++)this.colYs[i] = setHeight;
                    return position;
                };
                proto._getTopColPosition = function(colSpan) {
                    var colGroup = this._getTopColGroup(colSpan);
                    // get the minimum Y value from the columns
                    var minimumY = Math.min.apply(Math, colGroup);
                    return {
                        col: colGroup.indexOf(minimumY),
                        y: minimumY
                    };
                };
                /**
   * @param {Number} colSpan - number of columns the element spans
   * @returns {Array} colGroup
   */ proto._getTopColGroup = function(colSpan) {
                    if (colSpan < 2) // if brick spans only one column, use all the column Ys
                    return this.colYs;
                    var colGroup = [];
                    // how many different places could this brick fit horizontally
                    var groupCount = this.cols + 1 - colSpan;
                    // for each group potential horizontal position
                    for(var i = 0; i < groupCount; i++)colGroup[i] = this._getColGroupY(i, colSpan);
                    return colGroup;
                };
                proto._getColGroupY = function(col, colSpan) {
                    if (colSpan < 2) return this.colYs[col];
                    // make an array of colY values for that one group
                    var groupColYs = this.colYs.slice(col, col + colSpan);
                    // and get the max value of the array
                    return Math.max.apply(Math, groupColYs);
                };
                // get column position based on horizontal index. #873
                proto._getHorizontalColPosition = function(colSpan, item) {
                    var col = this.horizontalColIndex % this.cols;
                    var isOver = colSpan > 1 && col + colSpan > this.cols;
                    // shift to next row if item can't fit on current row
                    col = isOver ? 0 : col;
                    // don't let zero-size items take up space
                    var hasSize = item.size.outerWidth && item.size.outerHeight;
                    this.horizontalColIndex = hasSize ? col + colSpan : this.horizontalColIndex;
                    return {
                        col: col,
                        y: this._getColGroupY(col, colSpan)
                    };
                };
                proto._manageStamp = function(stamp) {
                    var stampSize = getSize(stamp);
                    var offset = this._getElementOffset(stamp);
                    // get the columns that this stamp affects
                    var isOriginLeft = this._getOption("originLeft");
                    var firstX = isOriginLeft ? offset.left : offset.right;
                    var lastX = firstX + stampSize.outerWidth;
                    var firstCol = Math.floor(firstX / this.columnWidth);
                    firstCol = Math.max(0, firstCol);
                    var lastCol = Math.floor(lastX / this.columnWidth);
                    // lastCol should not go over if multiple of columnWidth #425
                    lastCol -= lastX % this.columnWidth ? 0 : 1;
                    lastCol = Math.min(this.cols - 1, lastCol);
                    // set colYs to bottom of the stamp
                    var isOriginTop = this._getOption("originTop");
                    var stampMaxY = (isOriginTop ? offset.top : offset.bottom) + stampSize.outerHeight;
                    for(var i = firstCol; i <= lastCol; i++)this.colYs[i] = Math.max(stampMaxY, this.colYs[i]);
                };
                proto._getContainerSize = function() {
                    this.maxY = Math.max.apply(Math, this.colYs);
                    var size = {
                        height: this.maxY
                    };
                    if (this._getOption("fitWidth")) size.width = this._getContainerFitWidth();
                    return size;
                };
                proto._getContainerFitWidth = function() {
                    var unusedCols = 0;
                    // count unused columns
                    var i = this.cols;
                    while(--i){
                        if (this.colYs[i] !== 0) break;
                        unusedCols++;
                    }
                    // fit container to columns that have been used
                    return (this.cols - unusedCols) * this.columnWidth - this.gutter;
                };
                proto.needsResizeLayout = function() {
                    var previousWidth = this.containerWidth;
                    this.getContainerWidth();
                    return previousWidth != this.containerWidth;
                };
                return Masonry;
            });
        },
        {
            "get-size": 6,
            "outlayer": 17
        }
    ],
    16: [
        function(require1, module, exports) {
            /**
 * Outlayer Item
 */ (function(window1, factory) {
                // universal module definition
                /* jshint strict: false */ /* globals define, module, require */ if (typeof define == "function" && define.amd) // AMD - RequireJS
                define([
                    "ev-emitter/ev-emitter",
                    "get-size/get-size"
                ], factory);
                else if (typeof module == "object" && module.exports) // CommonJS - Browserify, Webpack
                module.exports = factory(require1("ev-emitter"), require1("get-size"));
                else {
                    // browser global
                    window1.Outlayer = {};
                    window1.Outlayer.Item = factory(window1.EvEmitter, window1.getSize);
                }
            })(window, function factory(EvEmitter, getSize) {
                "use strict";
                // ----- helpers ----- //
                function isEmptyObj(obj) {
                    for(var prop in obj)return false;
                    prop = null;
                    return true;
                }
                // -------------------------- CSS3 support -------------------------- //
                var docElemStyle = document.documentElement.style;
                var transitionProperty = typeof docElemStyle.transition == "string" ? "transition" : "WebkitTransition";
                var transformProperty = typeof docElemStyle.transform == "string" ? "transform" : "WebkitTransform";
                var transitionEndEvent = {
                    WebkitTransition: "webkitTransitionEnd",
                    transition: "transitionend"
                }[transitionProperty];
                // cache all vendor properties that could have vendor prefix
                var vendorProperties = {
                    transform: transformProperty,
                    transition: transitionProperty,
                    transitionDuration: transitionProperty + "Duration",
                    transitionProperty: transitionProperty + "Property",
                    transitionDelay: transitionProperty + "Delay"
                };
                // -------------------------- Item -------------------------- //
                function Item(element, layout) {
                    if (!element) return;
                    this.element = element;
                    // parent layout class, i.e. Masonry, Isotope, or Packery
                    this.layout = layout;
                    this.position = {
                        x: 0,
                        y: 0
                    };
                    this._create();
                }
                // inherit EvEmitter
                var proto = Item.prototype = Object.create(EvEmitter.prototype);
                proto.constructor = Item;
                proto._create = function() {
                    // transition objects
                    this._transn = {
                        ingProperties: {},
                        clean: {},
                        onEnd: {}
                    };
                    this.css({
                        position: "absolute"
                    });
                };
                // trigger specified handler for event type
                proto.handleEvent = function(event) {
                    var method = "on" + event.type;
                    if (this[method]) this[method](event);
                };
                proto.getSize = function() {
                    this.size = getSize(this.element);
                };
                /**
 * apply CSS styles to element
 * @param {Object} style
 */ proto.css = function(style) {
                    var elemStyle = this.element.style;
                    for(var prop in style){
                        // use vendor property if available
                        var supportedProp = vendorProperties[prop] || prop;
                        elemStyle[supportedProp] = style[prop];
                    }
                };
                // measure position, and sets it
                proto.getPosition = function() {
                    var style = getComputedStyle(this.element);
                    var isOriginLeft = this.layout._getOption("originLeft");
                    var isOriginTop = this.layout._getOption("originTop");
                    var xValue = style[isOriginLeft ? "left" : "right"];
                    var yValue = style[isOriginTop ? "top" : "bottom"];
                    var x = parseFloat(xValue);
                    var y = parseFloat(yValue);
                    // convert percent to pixels
                    var layoutSize = this.layout.size;
                    if (xValue.indexOf("%") != -1) x = x / 100 * layoutSize.width;
                    if (yValue.indexOf("%") != -1) y = y / 100 * layoutSize.height;
                    // clean up 'auto' or other non-integer values
                    x = isNaN(x) ? 0 : x;
                    y = isNaN(y) ? 0 : y;
                    // remove padding from measurement
                    x -= isOriginLeft ? layoutSize.paddingLeft : layoutSize.paddingRight;
                    y -= isOriginTop ? layoutSize.paddingTop : layoutSize.paddingBottom;
                    this.position.x = x;
                    this.position.y = y;
                };
                // set settled position, apply padding
                proto.layoutPosition = function() {
                    var layoutSize = this.layout.size;
                    var style = {};
                    var isOriginLeft = this.layout._getOption("originLeft");
                    var isOriginTop = this.layout._getOption("originTop");
                    // x
                    var xPadding = isOriginLeft ? "paddingLeft" : "paddingRight";
                    var xProperty = isOriginLeft ? "left" : "right";
                    var xResetProperty = isOriginLeft ? "right" : "left";
                    var x = this.position.x + layoutSize[xPadding];
                    // set in percentage or pixels
                    style[xProperty] = this.getXValue(x);
                    // reset other property
                    style[xResetProperty] = "";
                    // y
                    var yPadding = isOriginTop ? "paddingTop" : "paddingBottom";
                    var yProperty = isOriginTop ? "top" : "bottom";
                    var yResetProperty = isOriginTop ? "bottom" : "top";
                    var y = this.position.y + layoutSize[yPadding];
                    // set in percentage or pixels
                    style[yProperty] = this.getYValue(y);
                    // reset other property
                    style[yResetProperty] = "";
                    this.css(style);
                    this.emitEvent("layout", [
                        this
                    ]);
                };
                proto.getXValue = function(x) {
                    var isHorizontal = this.layout._getOption("horizontal");
                    return this.layout.options.percentPosition && !isHorizontal ? x / this.layout.size.width * 100 + "%" : x + "px";
                };
                proto.getYValue = function(y) {
                    var isHorizontal = this.layout._getOption("horizontal");
                    return this.layout.options.percentPosition && isHorizontal ? y / this.layout.size.height * 100 + "%" : y + "px";
                };
                proto._transitionTo = function(x, y) {
                    this.getPosition();
                    // get current x & y from top/left
                    var curX = this.position.x;
                    var curY = this.position.y;
                    var didNotMove = x == this.position.x && y == this.position.y;
                    // save end position
                    this.setPosition(x, y);
                    // if did not move and not transitioning, just go to layout
                    if (didNotMove && !this.isTransitioning) {
                        this.layoutPosition();
                        return;
                    }
                    var transX = x - curX;
                    var transY = y - curY;
                    var transitionStyle = {};
                    transitionStyle.transform = this.getTranslate(transX, transY);
                    this.transition({
                        to: transitionStyle,
                        onTransitionEnd: {
                            transform: this.layoutPosition
                        },
                        isCleaning: true
                    });
                };
                proto.getTranslate = function(x, y) {
                    // flip cooridinates if origin on right or bottom
                    var isOriginLeft = this.layout._getOption("originLeft");
                    var isOriginTop = this.layout._getOption("originTop");
                    x = isOriginLeft ? x : -x;
                    y = isOriginTop ? y : -y;
                    return "translate3d(" + x + "px, " + y + "px, 0)";
                };
                // non transition + transform support
                proto.goTo = function(x, y) {
                    this.setPosition(x, y);
                    this.layoutPosition();
                };
                proto.moveTo = proto._transitionTo;
                proto.setPosition = function(x, y) {
                    this.position.x = parseFloat(x);
                    this.position.y = parseFloat(y);
                };
                // ----- transition ----- //
                /**
 * @param {Object} style - CSS
 * @param {Function} onTransitionEnd
 */ // non transition, just trigger callback
                proto._nonTransition = function(args) {
                    this.css(args.to);
                    if (args.isCleaning) this._removeStyles(args.to);
                    for(var prop in args.onTransitionEnd)args.onTransitionEnd[prop].call(this);
                };
                /**
 * proper transition
 * @param {Object} args - arguments
 *   @param {Object} to - style to transition to
 *   @param {Object} from - style to start transition from
 *   @param {Boolean} isCleaning - removes transition styles after transition
 *   @param {Function} onTransitionEnd - callback
 */ proto.transition = function(args) {
                    // redirect to nonTransition if no transition duration
                    if (!parseFloat(this.layout.options.transitionDuration)) {
                        this._nonTransition(args);
                        return;
                    }
                    var _transition = this._transn;
                    // keep track of onTransitionEnd callback by css property
                    for(var prop in args.onTransitionEnd)_transition.onEnd[prop] = args.onTransitionEnd[prop];
                    // keep track of properties that are transitioning
                    for(prop in args.to){
                        _transition.ingProperties[prop] = true;
                        // keep track of properties to clean up when transition is done
                        if (args.isCleaning) _transition.clean[prop] = true;
                    }
                    // set from styles
                    if (args.from) {
                        this.css(args.from);
                        // force redraw. http://blog.alexmaccaw.com/css-transitions
                        var h = this.element.offsetHeight;
                        // hack for JSHint to hush about unused var
                        h = null;
                    }
                    // enable transition
                    this.enableTransition(args.to);
                    // set styles that are transitioning
                    this.css(args.to);
                    this.isTransitioning = true;
                };
                // dash before all cap letters, including first for
                // WebkitTransform => -webkit-transform
                function toDashedAll(str) {
                    return str.replace(/([A-Z])/g, function($1) {
                        return "-" + $1.toLowerCase();
                    });
                }
                var transitionProps = "opacity," + toDashedAll(transformProperty);
                proto.enableTransition = function() {
                    // HACK changing transitionProperty during a transition
                    // will cause transition to jump
                    if (this.isTransitioning) return;
                    // make `transition: foo, bar, baz` from style object
                    // HACK un-comment this when enableTransition can work
                    // while a transition is happening
                    // var transitionValues = [];
                    // for ( var prop in style ) {
                    //   // dash-ify camelCased properties like WebkitTransition
                    //   prop = vendorProperties[ prop ] || prop;
                    //   transitionValues.push( toDashedAll( prop ) );
                    // }
                    // munge number to millisecond, to match stagger
                    var duration = this.layout.options.transitionDuration;
                    duration = typeof duration == "number" ? duration + "ms" : duration;
                    // enable transition styles
                    this.css({
                        transitionProperty: transitionProps,
                        transitionDuration: duration,
                        transitionDelay: this.staggerDelay || 0
                    });
                    // listen for transition end event
                    this.element.addEventListener(transitionEndEvent, this, false);
                };
                // ----- events ----- //
                proto.onwebkitTransitionEnd = function(event) {
                    this.ontransitionend(event);
                };
                proto.onotransitionend = function(event) {
                    this.ontransitionend(event);
                };
                // properties that I munge to make my life easier
                var dashedVendorProperties = {
                    "-webkit-transform": "transform"
                };
                proto.ontransitionend = function(event) {
                    // disregard bubbled events from children
                    if (event.target !== this.element) return;
                    var _transition = this._transn;
                    // get property name of transitioned property, convert to prefix-free
                    var propertyName = dashedVendorProperties[event.propertyName] || event.propertyName;
                    // remove property that has completed transitioning
                    delete _transition.ingProperties[propertyName];
                    // check if any properties are still transitioning
                    if (isEmptyObj(_transition.ingProperties)) // all properties have completed transitioning
                    this.disableTransition();
                    // clean style
                    if (propertyName in _transition.clean) {
                        // clean up style
                        this.element.style[event.propertyName] = "";
                        delete _transition.clean[propertyName];
                    }
                    // trigger onTransitionEnd callback
                    if (propertyName in _transition.onEnd) {
                        var onTransitionEnd = _transition.onEnd[propertyName];
                        onTransitionEnd.call(this);
                        delete _transition.onEnd[propertyName];
                    }
                    this.emitEvent("transitionEnd", [
                        this
                    ]);
                };
                proto.disableTransition = function() {
                    this.removeTransitionStyles();
                    this.element.removeEventListener(transitionEndEvent, this, false);
                    this.isTransitioning = false;
                };
                /**
 * removes style property from element
 * @param {Object} style
**/ proto._removeStyles = function(style) {
                    // clean up transition styles
                    var cleanStyle = {};
                    for(var prop in style)cleanStyle[prop] = "";
                    this.css(cleanStyle);
                };
                var cleanTransitionStyle = {
                    transitionProperty: "",
                    transitionDuration: "",
                    transitionDelay: ""
                };
                proto.removeTransitionStyles = function() {
                    // remove transition
                    this.css(cleanTransitionStyle);
                };
                // ----- stagger ----- //
                proto.stagger = function(delay) {
                    delay = isNaN(delay) ? 0 : delay;
                    this.staggerDelay = delay + "ms";
                };
                // ----- show/hide/remove ----- //
                // remove element from DOM
                proto.removeElem = function() {
                    this.element.parentNode.removeChild(this.element);
                    // remove display: none
                    this.css({
                        display: ""
                    });
                    this.emitEvent("remove", [
                        this
                    ]);
                };
                proto.remove = function() {
                    // just remove element if no transition support or no transition
                    if (!transitionProperty || !parseFloat(this.layout.options.transitionDuration)) {
                        this.removeElem();
                        return;
                    }
                    // start transition
                    this.once("transitionEnd", function() {
                        this.removeElem();
                    });
                    this.hide();
                };
                proto.reveal = function() {
                    delete this.isHidden;
                    // remove display: none
                    this.css({
                        display: ""
                    });
                    var options = this.layout.options;
                    var onTransitionEnd = {};
                    var transitionEndProperty = this.getHideRevealTransitionEndProperty("visibleStyle");
                    onTransitionEnd[transitionEndProperty] = this.onRevealTransitionEnd;
                    this.transition({
                        from: options.hiddenStyle,
                        to: options.visibleStyle,
                        isCleaning: true,
                        onTransitionEnd: onTransitionEnd
                    });
                };
                proto.onRevealTransitionEnd = function() {
                    // check if still visible
                    // during transition, item may have been hidden
                    if (!this.isHidden) this.emitEvent("reveal");
                };
                /**
 * get style property use for hide/reveal transition end
 * @param {String} styleProperty - hiddenStyle/visibleStyle
 * @returns {String}
 */ proto.getHideRevealTransitionEndProperty = function(styleProperty) {
                    var optionStyle = this.layout.options[styleProperty];
                    // use opacity
                    if (optionStyle.opacity) return "opacity";
                    // get first property
                    for(var prop in optionStyle)return prop;
                };
                proto.hide = function() {
                    // set flag
                    this.isHidden = true;
                    // remove display: none
                    this.css({
                        display: ""
                    });
                    var options = this.layout.options;
                    var onTransitionEnd = {};
                    var transitionEndProperty = this.getHideRevealTransitionEndProperty("hiddenStyle");
                    onTransitionEnd[transitionEndProperty] = this.onHideTransitionEnd;
                    this.transition({
                        from: options.visibleStyle,
                        to: options.hiddenStyle,
                        // keep hidden stuff hidden
                        isCleaning: true,
                        onTransitionEnd: onTransitionEnd
                    });
                };
                proto.onHideTransitionEnd = function() {
                    // check if still hidden
                    // during transition, item may have been un-hidden
                    if (this.isHidden) {
                        this.css({
                            display: "none"
                        });
                        this.emitEvent("hide");
                    }
                };
                proto.destroy = function() {
                    this.css({
                        position: "",
                        left: "",
                        right: "",
                        top: "",
                        bottom: "",
                        transition: "",
                        transform: ""
                    });
                };
                return Item;
            });
        },
        {
            "ev-emitter": 4,
            "get-size": 6
        }
    ],
    17: [
        function(require1, module, exports) {
            /*!
 * Outlayer v2.1.1
 * the brains and guts of a layout library
 * MIT license
 */ (function(window1, factory) {
                "use strict";
                // universal module definition
                /* jshint strict: false */ /* globals define, module, require */ if (typeof define == "function" && define.amd) // AMD - RequireJS
                define([
                    "ev-emitter/ev-emitter",
                    "get-size/get-size",
                    "fizzy-ui-utils/utils",
                    "./item"
                ], function(EvEmitter, getSize, utils, Item) {
                    return factory(window1, EvEmitter, getSize, utils, Item);
                });
                else if (typeof module == "object" && module.exports) // CommonJS - Browserify, Webpack
                module.exports = factory(window1, require1("ev-emitter"), require1("get-size"), require1("fizzy-ui-utils"), require1("./item"));
                else // browser global
                window1.Outlayer = factory(window1, window1.EvEmitter, window1.getSize, window1.fizzyUIUtils, window1.Outlayer.Item);
            })(window, function factory(window1, EvEmitter, getSize, utils, Item) {
                "use strict";
                // ----- vars ----- //
                var console1 = window1.console;
                var jQuery1 = window1.jQuery;
                var noop = function noop() {};
                // -------------------------- Outlayer -------------------------- //
                // globally unique identifiers
                var GUID = 0;
                // internal store of all Outlayer intances
                var instances = {};
                /**
 * @param {Element, String} element
 * @param {Object} options
 * @constructor
 */ function Outlayer(element, options) {
                    var queryElement = utils.getQueryElement(element);
                    if (!queryElement) {
                        if (console1) console1.error("Bad element for " + this.constructor.namespace + ": " + (queryElement || element));
                        return;
                    }
                    this.element = queryElement;
                    // add jQuery
                    if (jQuery1) this.$element = jQuery1(this.element);
                    // options
                    this.options = utils.extend({}, this.constructor.defaults);
                    this.option(options);
                    // add id for Outlayer.getFromElement
                    var id = ++GUID;
                    this.element.outlayerGUID = id; // expando
                    instances[id] = this; // associate via id
                    // kick it off
                    this._create();
                    var isInitLayout = this._getOption("initLayout");
                    if (isInitLayout) this.layout();
                }
                // settings are for internal use only
                Outlayer.namespace = "outlayer";
                Outlayer.Item = Item;
                // default options
                Outlayer.defaults = {
                    containerStyle: {
                        position: "relative"
                    },
                    initLayout: true,
                    originLeft: true,
                    originTop: true,
                    resize: true,
                    resizeContainer: true,
                    // item options
                    transitionDuration: "0.4s",
                    hiddenStyle: {
                        opacity: 0,
                        transform: "scale(0.001)"
                    },
                    visibleStyle: {
                        opacity: 1,
                        transform: "scale(1)"
                    }
                };
                var proto = Outlayer.prototype;
                // inherit EvEmitter
                utils.extend(proto, EvEmitter.prototype);
                /**
 * set options
 * @param {Object} opts
 */ proto.option = function(opts) {
                    utils.extend(this.options, opts);
                };
                /**
 * get backwards compatible option value, check old name
 */ proto._getOption = function(option) {
                    var oldOption = this.constructor.compatOptions[option];
                    return oldOption && this.options[oldOption] !== undefined ? this.options[oldOption] : this.options[option];
                };
                Outlayer.compatOptions = {
                    // currentName: oldName
                    initLayout: "isInitLayout",
                    horizontal: "isHorizontal",
                    layoutInstant: "isLayoutInstant",
                    originLeft: "isOriginLeft",
                    originTop: "isOriginTop",
                    resize: "isResizeBound",
                    resizeContainer: "isResizingContainer"
                };
                proto._create = function() {
                    // get items from children
                    this.reloadItems();
                    // elements that affect layout, but are not laid out
                    this.stamps = [];
                    this.stamp(this.options.stamp);
                    // set container style
                    utils.extend(this.element.style, this.options.containerStyle);
                    // bind resize method
                    var canBindResize = this._getOption("resize");
                    if (canBindResize) this.bindResize();
                };
                // goes through all children again and gets bricks in proper order
                proto.reloadItems = function() {
                    // collection of item elements
                    this.items = this._itemize(this.element.children);
                };
                /**
 * turn elements into Outlayer.Items to be used in layout
 * @param {Array or NodeList or HTMLElement} elems
 * @returns {Array} items - collection of new Outlayer Items
 */ proto._itemize = function(elems) {
                    var itemElems = this._filterFindItemElements(elems);
                    var _$Item = this.constructor.Item;
                    // create new Outlayer Items for collection
                    var items = [];
                    for(var i = 0; i < itemElems.length; i++){
                        var elem = itemElems[i];
                        var item = new _$Item(elem, this);
                        items.push(item);
                    }
                    return items;
                };
                /**
 * get item elements to be used in layout
 * @param {Array or NodeList or HTMLElement} elems
 * @returns {Array} items - item elements
 */ proto._filterFindItemElements = function(elems) {
                    return utils.filterFindElements(elems, this.options.itemSelector);
                };
                /**
 * getter method for getting item elements
 * @returns {Array} elems - collection of item elements
 */ proto.getItemElements = function() {
                    return this.items.map(function(item) {
                        return item.element;
                    });
                };
                // ----- init & layout ----- //
                /**
 * lays out all items
 */ proto.layout = function() {
                    this._resetLayout();
                    this._manageStamps();
                    // don't animate first layout
                    var layoutInstant = this._getOption("layoutInstant");
                    var isInstant = layoutInstant !== undefined ? layoutInstant : !this._isLayoutInited;
                    this.layoutItems(this.items, isInstant);
                    // flag for initalized
                    this._isLayoutInited = true;
                };
                // _init is alias for layout
                proto._init = proto.layout;
                /**
 * logic before any new layout
 */ proto._resetLayout = function() {
                    this.getSize();
                };
                proto.getSize = function() {
                    this.size = getSize(this.element);
                };
                /**
 * get measurement from option, for columnWidth, rowHeight, gutter
 * if option is String -> get element from selector string, & get size of element
 * if option is Element -> get size of element
 * else use option as a number
 *
 * @param {String} measurement
 * @param {String} size - width or height
 * @private
 */ proto._getMeasurement = function(measurement, size) {
                    var option = this.options[measurement];
                    var elem;
                    if (!option) // default to 0
                    this[measurement] = 0;
                    else {
                        // use option as an element
                        if (typeof option == "string") elem = this.element.querySelector(option);
                        else if (option instanceof HTMLElement) elem = option;
                        // use size of element, if element
                        this[measurement] = elem ? getSize(elem)[size] : option;
                    }
                };
                /**
 * layout a collection of item elements
 * @api public
 */ proto.layoutItems = function(items, isInstant) {
                    items = this._getItemsForLayout(items);
                    this._layoutItems(items, isInstant);
                    this._postLayout();
                };
                /**
 * get the items to be laid out
 * you may want to skip over some items
 * @param {Array} items
 * @returns {Array} items
 */ proto._getItemsForLayout = function(items) {
                    return items.filter(function(item) {
                        return !item.isIgnored;
                    });
                };
                /**
 * layout items
 * @param {Array} items
 * @param {Boolean} isInstant
 */ proto._layoutItems = function(items, isInstant) {
                    this._emitCompleteOnItems("layout", items);
                    if (!items || !items.length) // no items, emit event with empty array
                    return;
                    var queue = [];
                    items.forEach(function(item) {
                        // get x/y object from method
                        var position = this._getItemLayoutPosition(item);
                        // enqueue
                        position.item = item;
                        position.isInstant = isInstant || item.isLayoutInstant;
                        queue.push(position);
                    }, this);
                    this._processLayoutQueue(queue);
                };
                /**
 * get item layout position
 * @param {Outlayer.Item} item
 * @returns {Object} x and y position
 */ proto._getItemLayoutPosition = function() {
                    return {
                        x: 0,
                        y: 0
                    };
                };
                /**
 * iterate over array and position each item
 * Reason being - separating this logic prevents 'layout invalidation'
 * thx @paul_irish
 * @param {Array} queue
 */ proto._processLayoutQueue = function(queue) {
                    this.updateStagger();
                    queue.forEach(function(obj, i) {
                        this._positionItem(obj.item, obj.x, obj.y, obj.isInstant, i);
                    }, this);
                };
                // set stagger from option in milliseconds number
                proto.updateStagger = function() {
                    var stagger = this.options.stagger;
                    if (stagger === null || stagger === undefined) {
                        this.stagger = 0;
                        return;
                    }
                    this.stagger = getMilliseconds(stagger);
                    return this.stagger;
                };
                /**
 * Sets position of item in DOM
 * @param {Outlayer.Item} item
 * @param {Number} x - horizontal position
 * @param {Number} y - vertical position
 * @param {Boolean} isInstant - disables transitions
 */ proto._positionItem = function(item, x, y, isInstant, i) {
                    if (isInstant) // if not transition, just set CSS
                    item.goTo(x, y);
                    else {
                        item.stagger(i * this.stagger);
                        item.moveTo(x, y);
                    }
                };
                /**
 * Any logic you want to do after each layout,
 * i.e. size the container
 */ proto._postLayout = function() {
                    this.resizeContainer();
                };
                proto.resizeContainer = function() {
                    var isResizingContainer = this._getOption("resizeContainer");
                    if (!isResizingContainer) return;
                    var size = this._getContainerSize();
                    if (size) {
                        this._setContainerMeasure(size.width, true);
                        this._setContainerMeasure(size.height, false);
                    }
                };
                /**
 * Sets width or height of container if returned
 * @returns {Object} size
 *   @param {Number} width
 *   @param {Number} height
 */ proto._getContainerSize = noop;
                /**
 * @param {Number} measure - size of width or height
 * @param {Boolean} isWidth
 */ proto._setContainerMeasure = function(measure, isWidth) {
                    if (measure === undefined) return;
                    var elemSize = this.size;
                    // add padding and border width if border box
                    if (elemSize.isBorderBox) measure += isWidth ? elemSize.paddingLeft + elemSize.paddingRight + elemSize.borderLeftWidth + elemSize.borderRightWidth : elemSize.paddingBottom + elemSize.paddingTop + elemSize.borderTopWidth + elemSize.borderBottomWidth;
                    measure = Math.max(measure, 0);
                    this.element.style[isWidth ? "width" : "height"] = measure + "px";
                };
                /**
 * emit eventComplete on a collection of items events
 * @param {String} eventName
 * @param {Array} items - Outlayer.Items
 */ proto._emitCompleteOnItems = function(eventName, items) {
                    var _this = this;
                    function onComplete() {
                        _this.dispatchEvent(eventName + "Complete", null, [
                            items
                        ]);
                    }
                    var count = items.length;
                    if (!items || !count) {
                        onComplete();
                        return;
                    }
                    var doneCount = 0;
                    function tick() {
                        doneCount++;
                        if (doneCount == count) onComplete();
                    }
                    // bind callback
                    items.forEach(function(item) {
                        item.once(eventName, tick);
                    });
                };
                /**
 * emits events via EvEmitter and jQuery events
 * @param {String} type - name of event
 * @param {Event} event - original event
 * @param {Array} args - extra arguments
 */ proto.dispatchEvent = function(type, event, args) {
                    // add original event to arguments
                    var emitArgs = event ? [
                        event
                    ].concat(args) : args;
                    this.emitEvent(type, emitArgs);
                    if (jQuery1) {
                        // set this.$element
                        this.$element = this.$element || jQuery1(this.element);
                        if (event) {
                            // create jQuery event
                            var $event = jQuery1.Event(event);
                            $event.type = type;
                            this.$element.trigger($event, args);
                        } else // just trigger with type if no event available
                        this.$element.trigger(type, args);
                    }
                };
                // -------------------------- ignore & stamps -------------------------- //
                /**
 * keep item in collection, but do not lay it out
 * ignored items do not get skipped in layout
 * @param {Element} elem
 */ proto.ignore = function(elem) {
                    var item = this.getItem(elem);
                    if (item) item.isIgnored = true;
                };
                /**
 * return item to layout collection
 * @param {Element} elem
 */ proto.unignore = function(elem) {
                    var item = this.getItem(elem);
                    if (item) delete item.isIgnored;
                };
                /**
 * adds elements to stamps
 * @param {NodeList, Array, Element, or String} elems
 */ proto.stamp = function(elems) {
                    elems = this._find(elems);
                    if (!elems) return;
                    this.stamps = this.stamps.concat(elems);
                    // ignore
                    elems.forEach(this.ignore, this);
                };
                /**
 * removes elements to stamps
 * @param {NodeList, Array, or Element} elems
 */ proto.unstamp = function(elems) {
                    elems = this._find(elems);
                    if (!elems) return;
                    elems.forEach(function(elem) {
                        // filter out removed stamp elements
                        utils.removeFrom(this.stamps, elem);
                        this.unignore(elem);
                    }, this);
                };
                /**
 * finds child elements
 * @param {NodeList, Array, Element, or String} elems
 * @returns {Array} elems
 */ proto._find = function(elems) {
                    if (!elems) return;
                    // if string, use argument as selector string
                    if (typeof elems == "string") elems = this.element.querySelectorAll(elems);
                    elems = utils.makeArray(elems);
                    return elems;
                };
                proto._manageStamps = function() {
                    if (!this.stamps || !this.stamps.length) return;
                    this._getBoundingRect();
                    this.stamps.forEach(this._manageStamp, this);
                };
                // update boundingLeft / Top
                proto._getBoundingRect = function() {
                    // get bounding rect for container element
                    var boundingRect = this.element.getBoundingClientRect();
                    var size = this.size;
                    this._boundingRect = {
                        left: boundingRect.left + size.paddingLeft + size.borderLeftWidth,
                        top: boundingRect.top + size.paddingTop + size.borderTopWidth,
                        right: boundingRect.right - (size.paddingRight + size.borderRightWidth),
                        bottom: boundingRect.bottom - (size.paddingBottom + size.borderBottomWidth)
                    };
                };
                /**
 * @param {Element} stamp
**/ proto._manageStamp = noop;
                /**
 * get x/y position of element relative to container element
 * @param {Element} elem
 * @returns {Object} offset - has left, top, right, bottom
 */ proto._getElementOffset = function(elem) {
                    var boundingRect = elem.getBoundingClientRect();
                    var thisRect = this._boundingRect;
                    var size = getSize(elem);
                    var offset = {
                        left: boundingRect.left - thisRect.left - size.marginLeft,
                        top: boundingRect.top - thisRect.top - size.marginTop,
                        right: thisRect.right - boundingRect.right - size.marginRight,
                        bottom: thisRect.bottom - boundingRect.bottom - size.marginBottom
                    };
                    return offset;
                };
                // -------------------------- resize -------------------------- //
                // enable event handlers for listeners
                // i.e. resize -> onresize
                proto.handleEvent = utils.handleEvent;
                /**
 * Bind layout to window resizing
 */ proto.bindResize = function() {
                    window1.addEventListener("resize", this);
                    this.isResizeBound = true;
                };
                /**
 * Unbind layout to window resizing
 */ proto.unbindResize = function() {
                    window1.removeEventListener("resize", this);
                    this.isResizeBound = false;
                };
                proto.onresize = function() {
                    this.resize();
                };
                utils.debounceMethod(Outlayer, "onresize", 100);
                proto.resize = function() {
                    // don't trigger if size did not change
                    // or if resize was unbound. See #9
                    if (!this.isResizeBound || !this.needsResizeLayout()) return;
                    this.layout();
                };
                /**
 * check if layout is needed post layout
 * @returns Boolean
 */ proto.needsResizeLayout = function() {
                    var size = getSize(this.element);
                    // check that this.size and size are there
                    // IE8 triggers resize on body size change, so they might not be
                    var hasSizes = this.size && size;
                    return hasSizes && size.innerWidth !== this.size.innerWidth;
                };
                // -------------------------- methods -------------------------- //
                /**
 * add items to Outlayer instance
 * @param {Array or NodeList or Element} elems
 * @returns {Array} items - Outlayer.Items
**/ proto.addItems = function(elems) {
                    var items = this._itemize(elems);
                    // add items to collection
                    if (items.length) this.items = this.items.concat(items);
                    return items;
                };
                /**
 * Layout newly-appended item elements
 * @param {Array or NodeList or Element} elems
 */ proto.appended = function(elems) {
                    var items = this.addItems(elems);
                    if (!items.length) return;
                    // layout and reveal just the new items
                    this.layoutItems(items, true);
                    this.reveal(items);
                };
                /**
 * Layout prepended elements
 * @param {Array or NodeList or Element} elems
 */ proto.prepended = function(elems) {
                    var items = this._itemize(elems);
                    if (!items.length) return;
                    // add items to beginning of collection
                    var previousItems = this.items.slice(0);
                    this.items = items.concat(previousItems);
                    // start new layout
                    this._resetLayout();
                    this._manageStamps();
                    // layout new stuff without transition
                    this.layoutItems(items, true);
                    this.reveal(items);
                    // layout previous items
                    this.layoutItems(previousItems);
                };
                /**
 * reveal a collection of items
 * @param {Array of Outlayer.Items} items
 */ proto.reveal = function(items) {
                    this._emitCompleteOnItems("reveal", items);
                    if (!items || !items.length) return;
                    var stagger = this.updateStagger();
                    items.forEach(function(item, i) {
                        item.stagger(i * stagger);
                        item.reveal();
                    });
                };
                /**
 * hide a collection of items
 * @param {Array of Outlayer.Items} items
 */ proto.hide = function(items) {
                    this._emitCompleteOnItems("hide", items);
                    if (!items || !items.length) return;
                    var stagger = this.updateStagger();
                    items.forEach(function(item, i) {
                        item.stagger(i * stagger);
                        item.hide();
                    });
                };
                /**
 * reveal item elements
 * @param {Array}, {Element}, {NodeList} items
 */ proto.revealItemElements = function(elems) {
                    var items = this.getItems(elems);
                    this.reveal(items);
                };
                /**
 * hide item elements
 * @param {Array}, {Element}, {NodeList} items
 */ proto.hideItemElements = function(elems) {
                    var items = this.getItems(elems);
                    this.hide(items);
                };
                /**
 * get Outlayer.Item, given an Element
 * @param {Element} elem
 * @param {Function} callback
 * @returns {Outlayer.Item} item
 */ proto.getItem = function(elem) {
                    // loop through items to get the one that matches
                    for(var i = 0; i < this.items.length; i++){
                        var item = this.items[i];
                        if (item.element == elem) // return item
                        return item;
                    }
                };
                /**
 * get collection of Outlayer.Items, given Elements
 * @param {Array} elems
 * @returns {Array} items - Outlayer.Items
 */ proto.getItems = function(elems) {
                    elems = utils.makeArray(elems);
                    var items = [];
                    elems.forEach(function(elem) {
                        var item = this.getItem(elem);
                        if (item) items.push(item);
                    }, this);
                    return items;
                };
                /**
 * remove element(s) from instance and DOM
 * @param {Array or NodeList or Element} elems
 */ proto.remove = function(elems) {
                    var removeItems = this.getItems(elems);
                    this._emitCompleteOnItems("remove", removeItems);
                    // bail if no items to remove
                    if (!removeItems || !removeItems.length) return;
                    removeItems.forEach(function(item) {
                        item.remove();
                        // remove item from collection
                        utils.removeFrom(this.items, item);
                    }, this);
                };
                // ----- destroy ----- //
                // remove and disable Outlayer instance
                proto.destroy = function() {
                    // clean up dynamic styles
                    var style = this.element.style;
                    style.height = "";
                    style.position = "";
                    style.width = "";
                    // destroy items
                    this.items.forEach(function(item) {
                        item.destroy();
                    });
                    this.unbindResize();
                    var id = this.element.outlayerGUID;
                    delete instances[id]; // remove reference to instance by id
                    delete this.element.outlayerGUID;
                    // remove data for jQuery
                    if (jQuery1) jQuery1.removeData(this.element, this.constructor.namespace);
                };
                // -------------------------- data -------------------------- //
                /**
 * get Outlayer instance from element
 * @param {Element} elem
 * @returns {Outlayer}
 */ Outlayer.data = function(elem) {
                    elem = utils.getQueryElement(elem);
                    var id = elem && elem.outlayerGUID;
                    return id && instances[id];
                };
                // -------------------------- create Outlayer class -------------------------- //
                /**
 * create a layout class
 * @param {String} namespace
 */ Outlayer.create = function(namespace, options) {
                    // sub-class Outlayer
                    var Layout = subclass(Outlayer);
                    // apply new options and compatOptions
                    Layout.defaults = utils.extend({}, Outlayer.defaults);
                    utils.extend(Layout.defaults, options);
                    Layout.compatOptions = utils.extend({}, Outlayer.compatOptions);
                    Layout.namespace = namespace;
                    Layout.data = Outlayer.data;
                    // sub-class Item
                    Layout.Item = subclass(Item);
                    // -------------------------- declarative -------------------------- //
                    utils.htmlInit(Layout, namespace);
                    // -------------------------- jQuery bridge -------------------------- //
                    // make into jQuery plugin
                    if (jQuery1 && jQuery1.bridget) jQuery1.bridget(namespace, Layout);
                    return Layout;
                };
                function subclass(Parent) {
                    function SubClass() {
                        Parent.apply(this, arguments);
                    }
                    SubClass.prototype = Object.create(Parent.prototype);
                    SubClass.prototype.constructor = SubClass;
                    return SubClass;
                }
                // ----- helpers ----- //
                // how many milliseconds are in each unit
                var msUnits = {
                    ms: 1,
                    s: 1000
                };
                // munge time-like parameter into millisecond number
                // '0.4s' -> 40
                function getMilliseconds(time) {
                    if (typeof time == "number") return time;
                    var matches = time.match(/(^\d*\.?\d*)(\w*)/);
                    var num = matches && matches[1];
                    var unit = matches && matches[2];
                    if (!num.length) return 0;
                    num = parseFloat(num);
                    var mult = msUnits[unit] || 1;
                    return num * mult;
                }
                // ----- fin ----- //
                // back in global
                Outlayer.Item = Item;
                return Outlayer;
            });
        },
        {
            "./item": 16,
            "ev-emitter": 4,
            "fizzy-ui-utils": 5,
            "get-size": 6
        }
    ],
    18: [
        function(require1, module, exports) {
            (function(global) {
                (function() {
                    /*!
* Parsley.js
* Version 2.9.2 - built Tue, Dec 10th 2019, 6:18 pm
* http://parsleyjs.org
* Guillaume Potier - <guillaume@wisembly.com>
* Marc-Andre Lafortune - <petroselinum@marc-andre.ca>
* MIT Licensed
*/ // The source code below is generated by babel as
                    // Parsley is written in ECMAScript 6
                    //
                    (function(global, factory) {
                        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory(require1("jquery")) : typeof define === "function" && define.amd ? define([
                            "jquery"
                        ], factory) : (global = global || self, global.parsley = factory(global.jQuery));
                    })(this, function($) {
                        "use strict";
                        function _typeof(obj) {
                            if (typeof Symbol === "function" && (0, _typeOf._)(Symbol.iterator) === "symbol") _typeof = function _typeof(obj) {
                                return typeof obj === "undefined" ? "undefined" : (0, _typeOf._)(obj);
                            };
                            else _typeof = function _typeof(obj) {
                                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : (0, _typeOf._)(obj);
                            };
                            return _typeof(obj);
                        }
                        function _extends() {
                            _extends = Object.assign || function(target) {
                                for(var i = 1; i < arguments.length; i++){
                                    var source = arguments[i];
                                    for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
                                }
                                return target;
                            };
                            return _extends.apply(this, arguments);
                        }
                        function _slicedToArray(arr, i) {
                            return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
                        }
                        function _toConsumableArray(arr) {
                            return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
                        }
                        function _arrayWithoutHoles(arr) {
                            if (Array.isArray(arr)) {
                                for(var i = 0, arr2 = new Array(arr.length); i < arr.length; i++)arr2[i] = arr[i];
                                return arr2;
                            }
                        }
                        function _arrayWithHoles(arr) {
                            if (Array.isArray(arr)) return arr;
                        }
                        function _iterableToArray(iter) {
                            if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
                        }
                        function _iterableToArrayLimit(arr, i) {
                            if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) return;
                            var _arr = [];
                            var _n = true;
                            var _d = false;
                            var _e = undefined;
                            try {
                                for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){
                                    _arr.push(_s.value);
                                    if (i && _arr.length === i) break;
                                }
                            } catch (err) {
                                _d = true;
                                _e = err;
                            } finally{
                                try {
                                    if (!_n && _i["return"] != null) _i["return"]();
                                } finally{
                                    if (_d) throw _e;
                                }
                            }
                            return _arr;
                        }
                        function _nonIterableSpread() {
                            throw new TypeError("Invalid attempt to spread non-iterable instance");
                        }
                        function _nonIterableRest() {
                            throw new TypeError("Invalid attempt to destructure non-iterable instance");
                        }
                        var globalID = 1;
                        var pastWarnings = {};
                        var Utils = {
                            // Parsley DOM-API
                            // returns object from dom attributes and values
                            attr: function attr(element, namespace, obj) {
                                var i;
                                var attribute;
                                var attributes;
                                var regex = new RegExp("^" + namespace, "i");
                                if ("undefined" === typeof obj) obj = {};
                                else {
                                    // Clear all own properties. This won't affect prototype's values
                                    for(i in obj)if (obj.hasOwnProperty(i)) delete obj[i];
                                }
                                if (!element) return obj;
                                attributes = element.attributes;
                                for(i = attributes.length; i--;){
                                    attribute = attributes[i];
                                    if (attribute && attribute.specified && regex.test(attribute.name)) obj[this.camelize(attribute.name.slice(namespace.length))] = this.deserializeValue(attribute.value);
                                }
                                return obj;
                            },
                            checkAttr: function checkAttr(element, namespace, _checkAttr) {
                                return element.hasAttribute(namespace + _checkAttr);
                            },
                            setAttr: function setAttr(element, namespace, attr, value) {
                                element.setAttribute(this.dasherize(namespace + attr), String(value));
                            },
                            getType: function getType(element) {
                                return element.getAttribute("type") || "text";
                            },
                            generateID: function generateID() {
                                return "" + globalID++;
                            },
                            /** Third party functions **/ deserializeValue: function deserializeValue(value) {
                                var num;
                                try {
                                    return value ? value == "true" || (value == "false" ? false : value == "null" ? null : !isNaN(num = Number(value)) ? num : /^[\[\{]/.test(value) ? JSON.parse(value) : value) : value;
                                } catch (e) {
                                    return value;
                                }
                            },
                            // Zepto camelize function
                            camelize: function camelize(str) {
                                return str.replace(/-+(.)?/g, function(match, chr) {
                                    return chr ? chr.toUpperCase() : "";
                                });
                            },
                            // Zepto dasherize function
                            dasherize: function dasherize(str) {
                                return str.replace(/::/g, "/").replace(/([A-Z]+)([A-Z][a-z])/g, "$1_$2").replace(/([a-z\d])([A-Z])/g, "$1_$2").replace(/_/g, "-").toLowerCase();
                            },
                            warn: function warn() {
                                var _window$console;
                                if (window.console && "function" === typeof window.console.warn) (_window$console = window.console).warn.apply(_window$console, arguments);
                            },
                            warnOnce: function warnOnce(msg) {
                                if (!pastWarnings[msg]) {
                                    pastWarnings[msg] = true;
                                    this.warn.apply(this, arguments);
                                }
                            },
                            _resetWarnings: function _resetWarnings() {
                                pastWarnings = {};
                            },
                            trimString: function trimString(string) {
                                return string.replace(/^\s+|\s+$/g, "");
                            },
                            parse: {
                                date: function date(string) {
                                    var parsed = string.match(/^(\d{4,})-(\d\d)-(\d\d)$/);
                                    if (!parsed) return null;
                                    var _parsed$map = parsed.map(function(x) {
                                        return parseInt(x, 10);
                                    }), _parsed$map2 = _slicedToArray(_parsed$map, 4), _ = _parsed$map2[0], year = _parsed$map2[1], month = _parsed$map2[2], day = _parsed$map2[3];
                                    var date = new Date(year, month - 1, day);
                                    if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) return null;
                                    return date;
                                },
                                string: function string(_string) {
                                    return _string;
                                },
                                integer: function integer(string) {
                                    if (isNaN(string)) return null;
                                    return parseInt(string, 10);
                                },
                                number: function number(string) {
                                    if (isNaN(string)) throw null;
                                    return parseFloat(string);
                                },
                                "boolean": function _boolean(string) {
                                    return !/^\s*false\s*$/i.test(string);
                                },
                                object: function object(string) {
                                    return Utils.deserializeValue(string);
                                },
                                regexp: function regexp(_regexp) {
                                    var flags = ""; // Test if RegExp is literal, if not, nothing to be done, otherwise, we need to isolate flags and pattern
                                    if (/^\/.*\/(?:[gimy]*)$/.test(_regexp)) {
                                        // Replace the regexp literal string with the first match group: ([gimy]*)
                                        // If no flag is present, this will be a blank string
                                        flags = _regexp.replace(/.*\/([gimy]*)$/, "$1"); // Again, replace the regexp literal string with the first match group:
                                        // everything excluding the opening and closing slashes and the flags
                                        _regexp = _regexp.replace(new RegExp("^/(.*?)/" + flags + "$"), "$1");
                                    } else // Anchor regexp:
                                    _regexp = "^" + _regexp + "$";
                                    return new RegExp(_regexp, flags);
                                }
                            },
                            parseRequirement: function parseRequirement(requirementType, string) {
                                var converter = this.parse[requirementType || "string"];
                                if (!converter) throw 'Unknown requirement specification: "' + requirementType + '"';
                                var converted = converter(string);
                                if (converted === null) throw "Requirement is not a ".concat(requirementType, ': "').concat(string, '"');
                                return converted;
                            },
                            namespaceEvents: function namespaceEvents(events, namespace) {
                                events = this.trimString(events || "").split(/\s+/);
                                if (!events[0]) return "";
                                return $.map(events, function(evt) {
                                    return "".concat(evt, ".").concat(namespace);
                                }).join(" ");
                            },
                            difference: function difference(array, remove) {
                                // This is O(N^2), should be optimized
                                var result = [];
                                $.each(array, function(_, elem) {
                                    if (remove.indexOf(elem) == -1) result.push(elem);
                                });
                                return result;
                            },
                            // Alter-ego to native Promise.all, but for jQuery
                            all: function all(promises) {
                                // jQuery treats $.when() and $.when(singlePromise) differently; let's avoid that and add spurious elements
                                return $.when.apply($, _toConsumableArray(promises).concat([
                                    42,
                                    42
                                ]));
                            },
                            // Object.create polyfill, see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create#Polyfill
                            objectCreate: Object.create || function() {
                                var _$Object = function Object1() {};
                                return function(prototype) {
                                    if (arguments.length > 1) throw Error("Second argument not supported");
                                    if (_typeof(prototype) != "object") throw TypeError("Argument must be an object");
                                    _$Object.prototype = prototype;
                                    var result = new _$Object();
                                    _$Object.prototype = null;
                                    return result;
                                };
                            }(),
                            _SubmitSelector: 'input[type="submit"], button:submit'
                        };
                        // All these options could be overriden and specified directly in DOM using
                        // `data-parsley-` default DOM-API
                        // eg: `inputs` can be set in DOM using `data-parsley-inputs="input, textarea"`
                        // eg: `data-parsley-stop-on-first-failing-constraint="false"`
                        var Defaults = {
                            // ### General
                            // Default data-namespace for DOM API
                            namespace: "data-parsley-",
                            // Supported inputs by default
                            inputs: "input, textarea, select",
                            // Excluded inputs by default
                            excluded: "input[type=button], input[type=submit], input[type=reset], input[type=hidden]",
                            // Stop validating field on highest priority failing constraint
                            priorityEnabled: true,
                            // ### Field only
                            // identifier used to group together inputs (e.g. radio buttons...)
                            multiple: null,
                            // identifier (or array of identifiers) used to validate only a select group of inputs
                            group: null,
                            // ### UI
                            // Enable\Disable error messages
                            uiEnabled: true,
                            // Key events threshold before validation
                            validationThreshold: 3,
                            // Focused field on form validation error. 'first'|'last'|'none'
                            focus: "first",
                            // event(s) that will trigger validation before first failure. eg: `input`...
                            trigger: false,
                            // event(s) that will trigger validation after first failure.
                            triggerAfterFailure: "input",
                            // Class that would be added on every failing validation Parsley field
                            errorClass: "parsley-error",
                            // Same for success validation
                            successClass: "parsley-success",
                            // Return the `$element` that will receive these above success or error classes
                            // Could also be (and given directly from DOM) a valid selector like `'#div'`
                            classHandler: function classHandler(Field) {},
                            // Return the `$element` where errors will be appended
                            // Could also be (and given directly from DOM) a valid selector like `'#div'`
                            errorsContainer: function errorsContainer(Field) {},
                            // ul elem that would receive errors' list
                            errorsWrapper: '<ul class="parsley-errors-list"></ul>',
                            // li elem that would receive error message
                            errorTemplate: "<li></li>"
                        };
                        var Base = function Base() {
                            this.__id__ = Utils.generateID();
                        };
                        Base.prototype = {
                            asyncSupport: true,
                            // Deprecated
                            _pipeAccordingToValidationResult: function _pipeAccordingToValidationResult() {
                                var _this = this;
                                var pipe = function pipe() {
                                    var r = $.Deferred();
                                    if (true !== _this.validationResult) r.reject();
                                    return r.resolve().promise();
                                };
                                return [
                                    pipe,
                                    pipe
                                ];
                            },
                            actualizeOptions: function actualizeOptions() {
                                Utils.attr(this.element, this.options.namespace, this.domOptions);
                                if (this.parent && this.parent.actualizeOptions) this.parent.actualizeOptions();
                                return this;
                            },
                            _resetOptions: function _resetOptions(initOptions) {
                                this.domOptions = Utils.objectCreate(this.parent.options);
                                this.options = Utils.objectCreate(this.domOptions); // Shallow copy of ownProperties of initOptions:
                                for(var i in initOptions)if (initOptions.hasOwnProperty(i)) this.options[i] = initOptions[i];
                                this.actualizeOptions();
                            },
                            _listeners: null,
                            // Register a callback for the given event name
                            // Callback is called with context as the first argument and the `this`
                            // The context is the current parsley instance, or window.Parsley if global
                            // A return value of `false` will interrupt the calls
                            on: function on(name, fn) {
                                this._listeners = this._listeners || {};
                                var queue = this._listeners[name] = this._listeners[name] || [];
                                queue.push(fn);
                                return this;
                            },
                            // Deprecated. Use `on` instead
                            subscribe: function subscribe(name, fn) {
                                $.listenTo(this, name.toLowerCase(), fn);
                            },
                            // Unregister a callback (or all if none is given) for the given event name
                            off: function off(name, fn) {
                                var queue = this._listeners && this._listeners[name];
                                if (queue) {
                                    if (!fn) delete this._listeners[name];
                                    else {
                                        for(var i = queue.length; i--;)if (queue[i] === fn) queue.splice(i, 1);
                                    }
                                }
                                return this;
                            },
                            // Deprecated. Use `off`
                            unsubscribe: function unsubscribe(name, fn) {
                                $.unsubscribeTo(this, name.toLowerCase());
                            },
                            // Trigger an event of the given name
                            // A return value of `false` interrupts the callback chain
                            // Returns false if execution was interrupted
                            trigger: function trigger(name, target, extraArg) {
                                target = target || this;
                                var queue = this._listeners && this._listeners[name];
                                var result;
                                if (queue) for(var i = queue.length; i--;){
                                    result = queue[i].call(target, target, extraArg);
                                    if (result === false) return result;
                                }
                                if (this.parent) return this.parent.trigger(name, target, extraArg);
                                return true;
                            },
                            asyncIsValid: function asyncIsValid(group, force) {
                                Utils.warnOnce("asyncIsValid is deprecated; please use whenValid instead");
                                return this.whenValid({
                                    group: group,
                                    force: force
                                });
                            },
                            _findRelated: function _findRelated() {
                                return this.options.multiple ? $(this.parent.element.querySelectorAll("[".concat(this.options.namespace, 'multiple="').concat(this.options.multiple, '"]'))) : this.$element;
                            }
                        };
                        var convertArrayRequirement = function convertArrayRequirement(string, length) {
                            var m = string.match(/^\s*\[(.*)\]\s*$/);
                            if (!m) throw 'Requirement is not an array: "' + string + '"';
                            var values = m[1].split(",").map(Utils.trimString);
                            if (values.length !== length) throw "Requirement has " + values.length + " values when " + length + " are needed";
                            return values;
                        };
                        var convertExtraOptionRequirement = function convertExtraOptionRequirement(requirementSpec, string, extraOptionReader) {
                            var main = null;
                            var extra = {};
                            for(var key in requirementSpec)if (key) {
                                var value = extraOptionReader(key);
                                if ("string" === typeof value) value = Utils.parseRequirement(requirementSpec[key], value);
                                extra[key] = value;
                            } else main = Utils.parseRequirement(requirementSpec[key], string);
                            return [
                                main,
                                extra
                            ];
                        }; // A Validator needs to implement the methods `validate` and `parseRequirements`
                        var Validator = function Validator(spec) {
                            $.extend(true, this, spec);
                        };
                        Validator.prototype = {
                            // Returns `true` iff the given `value` is valid according the given requirements.
                            validate: function validate(value, requirementFirstArg) {
                                if (this.fn) {
                                    // Legacy style validator
                                    if (arguments.length > 3) requirementFirstArg = [].slice.call(arguments, 1, -1); // Skip first arg (value) and last (instance), combining the rest
                                    return this.fn(value, requirementFirstArg);
                                }
                                if (Array.isArray(value)) {
                                    if (!this.validateMultiple) throw "Validator `" + this.name + "` does not handle multiple values";
                                    return this.validateMultiple.apply(this, arguments);
                                } else {
                                    var instance = arguments[arguments.length - 1];
                                    if (this.validateDate && instance._isDateInput()) {
                                        arguments[0] = Utils.parse.date(arguments[0]);
                                        if (arguments[0] === null) return false;
                                        return this.validateDate.apply(this, arguments);
                                    }
                                    if (this.validateNumber) {
                                        if (!value) return true;
                                        if (isNaN(value)) return false;
                                        arguments[0] = parseFloat(arguments[0]);
                                        return this.validateNumber.apply(this, arguments);
                                    }
                                    if (this.validateString) return this.validateString.apply(this, arguments);
                                    throw "Validator `" + this.name + "` only handles multiple values";
                                }
                            },
                            // Parses `requirements` into an array of arguments,
                            // according to `this.requirementType`
                            parseRequirements: function parseRequirements(requirements, extraOptionReader) {
                                if ("string" !== typeof requirements) // Assume requirement already parsed
                                // but make sure we return an array
                                return Array.isArray(requirements) ? requirements : [
                                    requirements
                                ];
                                var type = this.requirementType;
                                if (Array.isArray(type)) {
                                    var values = convertArrayRequirement(requirements, type.length);
                                    for(var i = 0; i < values.length; i++)values[i] = Utils.parseRequirement(type[i], values[i]);
                                    return values;
                                } else if ($.isPlainObject(type)) return convertExtraOptionRequirement(type, requirements, extraOptionReader);
                                else return [
                                    Utils.parseRequirement(type, requirements)
                                ];
                            },
                            // Defaults:
                            requirementType: "string",
                            priority: 2
                        };
                        var ValidatorRegistry = function ValidatorRegistry(validators, catalog) {
                            this.__class__ = "ValidatorRegistry"; // Default Parsley locale is en
                            this.locale = "en";
                            this.init(validators || {}, catalog || {});
                        };
                        var typeTesters = {
                            email: /^((([a-zA-Z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-zA-Z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-zA-Z]|\d|-|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-zA-Z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-zA-Z]|\d|-|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-zA-Z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))$/,
                            // Follow https://www.w3.org/TR/html5/infrastructure.html#floating-point-numbers
                            number: /^-?(\d*\.)?\d+(e[-+]?\d+)?$/i,
                            integer: /^-?\d+$/,
                            digits: /^\d+$/,
                            alphanum: /^\w+$/i,
                            date: {
                                test: function test(value) {
                                    return Utils.parse.date(value) !== null;
                                }
                            },
                            url: new RegExp("^(?:(?:https?|ftp)://)?(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-zA-Z\\u00a1-\\uffff0-9]-*)*[a-zA-Z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-zA-Z\\u00a1-\\uffff0-9]-*)*[a-zA-Z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-zA-Z\\u00a1-\\uffff]{2,})))(?::\\d{2,5})?(?:/\\S*)?$")
                        };
                        typeTesters.range = typeTesters.number; // See http://stackoverflow.com/a/10454560/8279
                        var decimalPlaces = function decimalPlaces(num) {
                            var match = ("" + num).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
                            if (!match) return 0;
                            return Math.max(0, (match[1] ? match[1].length : 0) - (match[2] ? +match[2] : 0));
                        }; // parseArguments('number', ['1', '2']) => [1, 2]
                        var parseArguments = function parseArguments(type, args) {
                            return args.map(Utils.parse[type]);
                        }; // operatorToValidator returns a validating function for an operator function, applied to the given type
                        var operatorToValidator = function operatorToValidator(type, operator) {
                            return function(value) {
                                for(var _len = arguments.length, requirementsAndInput = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)requirementsAndInput[_key - 1] = arguments[_key];
                                requirementsAndInput.pop(); // Get rid of `input` argument
                                return operator.apply(void 0, [
                                    value
                                ].concat(_toConsumableArray(parseArguments(type, requirementsAndInput))));
                            };
                        };
                        var comparisonOperator = function comparisonOperator(operator) {
                            return {
                                validateDate: operatorToValidator("date", operator),
                                validateNumber: operatorToValidator("number", operator),
                                requirementType: operator.length <= 2 ? "string" : [
                                    "string",
                                    "string"
                                ],
                                // Support operators with a 1 or 2 requirement(s)
                                priority: 30
                            };
                        };
                        ValidatorRegistry.prototype = {
                            init: function init(validators, catalog) {
                                this.catalog = catalog; // Copy prototype's validators:
                                this.validators = _extends({}, this.validators);
                                for(var name in validators)this.addValidator(name, validators[name].fn, validators[name].priority);
                                window.Parsley.trigger("parsley:validator:init");
                            },
                            // Set new messages locale if we have dictionary loaded in ParsleyConfig.i18n
                            setLocale: function setLocale(locale) {
                                if ("undefined" === typeof this.catalog[locale]) throw new Error(locale + " is not available in the catalog");
                                this.locale = locale;
                                return this;
                            },
                            // Add a new messages catalog for a given locale. Set locale for this catalog if set === `true`
                            addCatalog: function addCatalog(locale, messages, set) {
                                if ("object" === _typeof(messages)) this.catalog[locale] = messages;
                                if (true === set) return this.setLocale(locale);
                                return this;
                            },
                            // Add a specific message for a given constraint in a given locale
                            addMessage: function addMessage(locale, name, message) {
                                if ("undefined" === typeof this.catalog[locale]) this.catalog[locale] = {};
                                this.catalog[locale][name] = message;
                                return this;
                            },
                            // Add messages for a given locale
                            addMessages: function addMessages(locale, nameMessageObject) {
                                for(var name in nameMessageObject)this.addMessage(locale, name, nameMessageObject[name]);
                                return this;
                            },
                            // Add a new validator
                            //
                            //    addValidator('custom', {
                            //        requirementType: ['integer', 'integer'],
                            //        validateString: function(value, from, to) {},
                            //        priority: 22,
                            //        messages: {
                            //          en: "Hey, that's no good",
                            //          fr: "Aye aye, pas bon du tout",
                            //        }
                            //    })
                            //
                            // Old API was addValidator(name, function, priority)
                            //
                            addValidator: function addValidator(name, arg1, arg2) {
                                if (this.validators[name]) Utils.warn('Validator "' + name + '" is already defined.');
                                else if (Defaults.hasOwnProperty(name)) {
                                    Utils.warn('"' + name + '" is a restricted keyword and is not a valid validator name.');
                                    return;
                                }
                                return this._setValidator.apply(this, arguments);
                            },
                            hasValidator: function hasValidator(name) {
                                return !!this.validators[name];
                            },
                            updateValidator: function updateValidator(name, arg1, arg2) {
                                if (!this.validators[name]) {
                                    Utils.warn('Validator "' + name + '" is not already defined.');
                                    return this.addValidator.apply(this, arguments);
                                }
                                return this._setValidator.apply(this, arguments);
                            },
                            removeValidator: function removeValidator(name) {
                                if (!this.validators[name]) Utils.warn('Validator "' + name + '" is not defined.');
                                delete this.validators[name];
                                return this;
                            },
                            _setValidator: function _setValidator(name, validator, priority) {
                                if ("object" !== _typeof(validator)) // Old style validator, with `fn` and `priority`
                                validator = {
                                    fn: validator,
                                    priority: priority
                                };
                                if (!validator.validate) validator = new Validator(validator);
                                this.validators[name] = validator;
                                for(var locale in validator.messages || {})this.addMessage(locale, name, validator.messages[locale]);
                                return this;
                            },
                            getErrorMessage: function getErrorMessage(constraint) {
                                var message; // Type constraints are a bit different, we have to match their requirements too to find right error message
                                if ("type" === constraint.name) {
                                    var typeMessages = this.catalog[this.locale][constraint.name] || {};
                                    message = typeMessages[constraint.requirements];
                                } else message = this.formatMessage(this.catalog[this.locale][constraint.name], constraint.requirements);
                                return message || this.catalog[this.locale].defaultMessage || this.catalog.en.defaultMessage;
                            },
                            // Kind of light `sprintf()` implementation
                            formatMessage: function formatMessage(string, parameters) {
                                if ("object" === _typeof(parameters)) {
                                    for(var i in parameters)string = this.formatMessage(string, parameters[i]);
                                    return string;
                                }
                                return "string" === typeof string ? string.replace(/%s/i, parameters) : "";
                            },
                            // Here is the Parsley default validators list.
                            // A validator is an object with the following key values:
                            //  - priority: an integer
                            //  - requirement: 'string' (default), 'integer', 'number', 'regexp' or an Array of these
                            //  - validateString, validateMultiple, validateNumber: functions returning `true`, `false` or a promise
                            // Alternatively, a validator can be a function that returns such an object
                            //
                            validators: {
                                notblank: {
                                    validateString: function validateString(value) {
                                        return /\S/.test(value);
                                    },
                                    priority: 2
                                },
                                required: {
                                    validateMultiple: function validateMultiple(values) {
                                        return values.length > 0;
                                    },
                                    validateString: function validateString(value) {
                                        return /\S/.test(value);
                                    },
                                    priority: 512
                                },
                                type: {
                                    validateString: function validateString(value, type) {
                                        var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {}, _ref$step = _ref.step, step = _ref$step === void 0 ? "any" : _ref$step, _ref$base = _ref.base, base = _ref$base === void 0 ? 0 : _ref$base;
                                        var tester = typeTesters[type];
                                        if (!tester) throw new Error("validator type `" + type + "` is not supported");
                                        if (!value) return true; // Builtin validators all accept empty strings, except `required` of course
                                        if (!tester.test(value)) return false;
                                        if ("number" === type) {
                                            if (!/^any$/i.test(step || "")) {
                                                var nb = Number(value);
                                                var decimals = Math.max(decimalPlaces(step), decimalPlaces(base));
                                                if (decimalPlaces(nb) > decimals) return false; // Be careful of rounding errors by using integers.
                                                var toInt = function toInt(f) {
                                                    return Math.round(f * Math.pow(10, decimals));
                                                };
                                                if ((toInt(nb) - toInt(base)) % toInt(step) != 0) return false;
                                            }
                                        }
                                        return true;
                                    },
                                    requirementType: {
                                        "": "string",
                                        step: "string",
                                        base: "number"
                                    },
                                    priority: 256
                                },
                                pattern: {
                                    validateString: function validateString(value, regexp) {
                                        if (!value) return true; // Builtin validators all accept empty strings, except `required` of course
                                        return regexp.test(value);
                                    },
                                    requirementType: "regexp",
                                    priority: 64
                                },
                                minlength: {
                                    validateString: function validateString(value, requirement) {
                                        if (!value) return true; // Builtin validators all accept empty strings, except `required` of course
                                        return value.length >= requirement;
                                    },
                                    requirementType: "integer",
                                    priority: 30
                                },
                                maxlength: {
                                    validateString: function validateString(value, requirement) {
                                        return value.length <= requirement;
                                    },
                                    requirementType: "integer",
                                    priority: 30
                                },
                                length: {
                                    validateString: function validateString(value, min, max) {
                                        if (!value) return true; // Builtin validators all accept empty strings, except `required` of course
                                        return value.length >= min && value.length <= max;
                                    },
                                    requirementType: [
                                        "integer",
                                        "integer"
                                    ],
                                    priority: 30
                                },
                                mincheck: {
                                    validateMultiple: function validateMultiple(values, requirement) {
                                        return values.length >= requirement;
                                    },
                                    requirementType: "integer",
                                    priority: 30
                                },
                                maxcheck: {
                                    validateMultiple: function validateMultiple(values, requirement) {
                                        return values.length <= requirement;
                                    },
                                    requirementType: "integer",
                                    priority: 30
                                },
                                check: {
                                    validateMultiple: function validateMultiple(values, min, max) {
                                        return values.length >= min && values.length <= max;
                                    },
                                    requirementType: [
                                        "integer",
                                        "integer"
                                    ],
                                    priority: 30
                                },
                                min: comparisonOperator(function(value, requirement) {
                                    return value >= requirement;
                                }),
                                max: comparisonOperator(function(value, requirement) {
                                    return value <= requirement;
                                }),
                                range: comparisonOperator(function(value, min, max) {
                                    return value >= min && value <= max;
                                }),
                                equalto: {
                                    validateString: function validateString(value, refOrValue) {
                                        if (!value) return true; // Builtin validators all accept empty strings, except `required` of course
                                        var $reference = $(refOrValue);
                                        if ($reference.length) return value === $reference.val();
                                        else return value === refOrValue;
                                    },
                                    priority: 256
                                },
                                euvatin: {
                                    validateString: function validateString(value, refOrValue) {
                                        if (!value) return true; // Builtin validators all accept empty strings, except `required` of course
                                        var re = /^[A-Z][A-Z][A-Za-z0-9 -]{2,}$/;
                                        return re.test(value);
                                    },
                                    priority: 30
                                }
                            }
                        };
                        var UI = {};
                        var diffResults = function diffResults(newResult, oldResult, deep) {
                            var added = [];
                            var kept = [];
                            for(var i = 0; i < newResult.length; i++){
                                var found = false;
                                for(var j = 0; j < oldResult.length; j++)if (newResult[i].assert.name === oldResult[j].assert.name) {
                                    found = true;
                                    break;
                                }
                                if (found) kept.push(newResult[i]);
                                else added.push(newResult[i]);
                            }
                            return {
                                kept: kept,
                                added: added,
                                removed: !deep ? diffResults(oldResult, newResult, true).added : []
                            };
                        };
                        UI.Form = {
                            _actualizeTriggers: function _actualizeTriggers() {
                                var _this = this;
                                this.$element.on("submit.Parsley", function(evt) {
                                    _this.onSubmitValidate(evt);
                                });
                                this.$element.on("click.Parsley", Utils._SubmitSelector, function(evt) {
                                    _this.onSubmitButton(evt);
                                }); // UI could be disabled
                                if (false === this.options.uiEnabled) return;
                                this.element.setAttribute("novalidate", "");
                            },
                            focus: function focus() {
                                this._focusedField = null;
                                if (true === this.validationResult || "none" === this.options.focus) return null;
                                for(var i = 0; i < this.fields.length; i++){
                                    var field = this.fields[i];
                                    if (true !== field.validationResult && field.validationResult.length > 0 && "undefined" === typeof field.options.noFocus) {
                                        this._focusedField = field.$element;
                                        if ("first" === this.options.focus) break;
                                    }
                                }
                                if (null === this._focusedField) return null;
                                return this._focusedField.focus();
                            },
                            _destroyUI: function _destroyUI() {
                                // Reset all event listeners
                                this.$element.off(".Parsley");
                            }
                        };
                        UI.Field = {
                            _reflowUI: function _reflowUI() {
                                this._buildUI(); // If this field doesn't have an active UI don't bother doing something
                                if (!this._ui) return; // Diff between two validation results
                                var diff = diffResults(this.validationResult, this._ui.lastValidationResult); // Then store current validation result for next reflow
                                this._ui.lastValidationResult = this.validationResult; // Handle valid / invalid / none field class
                                this._manageStatusClass(); // Add, remove, updated errors messages
                                this._manageErrorsMessages(diff); // Triggers impl
                                this._actualizeTriggers(); // If field is not valid for the first time, bind keyup trigger to ease UX and quickly inform user
                                if ((diff.kept.length || diff.added.length) && !this._failedOnce) {
                                    this._failedOnce = true;
                                    this._actualizeTriggers();
                                }
                            },
                            // Returns an array of field's error message(s)
                            getErrorsMessages: function getErrorsMessages() {
                                // No error message, field is valid
                                if (true === this.validationResult) return [];
                                var messages = [];
                                for(var i = 0; i < this.validationResult.length; i++)messages.push(this.validationResult[i].errorMessage || this._getErrorMessage(this.validationResult[i].assert));
                                return messages;
                            },
                            // It's a goal of Parsley that this method is no longer required [#1073]
                            addError: function addError(name) {
                                var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, message = _ref.message, assert = _ref.assert, _ref$updateClass = _ref.updateClass, updateClass = _ref$updateClass === void 0 ? true : _ref$updateClass;
                                this._buildUI();
                                this._addError(name, {
                                    message: message,
                                    assert: assert
                                });
                                if (updateClass) this._errorClass();
                            },
                            // It's a goal of Parsley that this method is no longer required [#1073]
                            updateError: function updateError(name) {
                                var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, message = _ref2.message, assert = _ref2.assert, _ref2$updateClass = _ref2.updateClass, updateClass = _ref2$updateClass === void 0 ? true : _ref2$updateClass;
                                this._buildUI();
                                this._updateError(name, {
                                    message: message,
                                    assert: assert
                                });
                                if (updateClass) this._errorClass();
                            },
                            // It's a goal of Parsley that this method is no longer required [#1073]
                            removeError: function removeError(name) {
                                var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref3$updateClass = _ref3.updateClass, updateClass = _ref3$updateClass === void 0 ? true : _ref3$updateClass;
                                this._buildUI();
                                this._removeError(name); // edge case possible here: remove a standard Parsley error that is still failing in this.validationResult
                                // but highly improbable cuz' manually removing a well Parsley handled error makes no sense.
                                if (updateClass) this._manageStatusClass();
                            },
                            _manageStatusClass: function _manageStatusClass() {
                                if (this.hasConstraints() && this.needsValidation() && true === this.validationResult) this._successClass();
                                else if (this.validationResult.length > 0) this._errorClass();
                                else this._resetClass();
                            },
                            _manageErrorsMessages: function _manageErrorsMessages(diff) {
                                if ("undefined" !== typeof this.options.errorsMessagesDisabled) return; // Case where we have errorMessage option that configure an unique field error message, regardless failing validators
                                if ("undefined" !== typeof this.options.errorMessage) {
                                    if (diff.added.length || diff.kept.length) {
                                        this._insertErrorWrapper();
                                        if (0 === this._ui.$errorsWrapper.find(".parsley-custom-error-message").length) this._ui.$errorsWrapper.append($(this.options.errorTemplate).addClass("parsley-custom-error-message"));
                                        this._ui.$errorClassHandler.attr("aria-describedby", this._ui.errorsWrapperId);
                                        return this._ui.$errorsWrapper.addClass("filled").attr("aria-hidden", "false").find(".parsley-custom-error-message").html(this.options.errorMessage);
                                    }
                                    this._ui.$errorClassHandler.removeAttr("aria-describedby");
                                    return this._ui.$errorsWrapper.removeClass("filled").attr("aria-hidden", "true").find(".parsley-custom-error-message").remove();
                                } // Show, hide, update failing constraints messages
                                for(var i = 0; i < diff.removed.length; i++)this._removeError(diff.removed[i].assert.name);
                                for(i = 0; i < diff.added.length; i++)this._addError(diff.added[i].assert.name, {
                                    message: diff.added[i].errorMessage,
                                    assert: diff.added[i].assert
                                });
                                for(i = 0; i < diff.kept.length; i++)this._updateError(diff.kept[i].assert.name, {
                                    message: diff.kept[i].errorMessage,
                                    assert: diff.kept[i].assert
                                });
                            },
                            _addError: function _addError(name, _ref4) {
                                var message = _ref4.message, assert = _ref4.assert;
                                this._insertErrorWrapper();
                                this._ui.$errorClassHandler.attr("aria-describedby", this._ui.errorsWrapperId);
                                this._ui.$errorsWrapper.addClass("filled").attr("aria-hidden", "false").append($(this.options.errorTemplate).addClass("parsley-" + name).html(message || this._getErrorMessage(assert)));
                            },
                            _updateError: function _updateError(name, _ref5) {
                                var message = _ref5.message, assert = _ref5.assert;
                                this._ui.$errorsWrapper.addClass("filled").find(".parsley-" + name).html(message || this._getErrorMessage(assert));
                            },
                            _removeError: function _removeError(name) {
                                this._ui.$errorClassHandler.removeAttr("aria-describedby");
                                this._ui.$errorsWrapper.removeClass("filled").attr("aria-hidden", "true").find(".parsley-" + name).remove();
                            },
                            _getErrorMessage: function _getErrorMessage(constraint) {
                                var customConstraintErrorMessage = constraint.name + "Message";
                                if ("undefined" !== typeof this.options[customConstraintErrorMessage]) return window.Parsley.formatMessage(this.options[customConstraintErrorMessage], constraint.requirements);
                                return window.Parsley.getErrorMessage(constraint);
                            },
                            _buildUI: function _buildUI() {
                                // UI could be already built or disabled
                                if (this._ui || false === this.options.uiEnabled) return;
                                var _ui = {}; // Give field its Parsley id in DOM
                                this.element.setAttribute(this.options.namespace + "id", this.__id__);
                                /** Generate important UI elements and store them in this **/ // $errorClassHandler is the $element that woul have parsley-error and parsley-success classes
                                _ui.$errorClassHandler = this._manageClassHandler(); // $errorsWrapper is a div that would contain the various field errors, it will be appended into $errorsContainer
                                _ui.errorsWrapperId = "parsley-id-" + (this.options.multiple ? "multiple-" + this.options.multiple : this.__id__);
                                _ui.$errorsWrapper = $(this.options.errorsWrapper).attr("id", _ui.errorsWrapperId); // ValidationResult UI storage to detect what have changed bwt two validations, and update DOM accordingly
                                _ui.lastValidationResult = [];
                                _ui.validationInformationVisible = false; // Store it in this for later
                                this._ui = _ui;
                            },
                            // Determine which element will have `parsley-error` and `parsley-success` classes
                            _manageClassHandler: function _manageClassHandler() {
                                // Class handled could also be determined by function given in Parsley options
                                if ("string" === typeof this.options.classHandler && $(this.options.classHandler).length) return $(this.options.classHandler); // Class handled could also be determined by function given in Parsley options
                                var $handlerFunction = this.options.classHandler; // It might also be the function name of a global function
                                if ("string" === typeof this.options.classHandler && "function" === typeof window[this.options.classHandler]) $handlerFunction = window[this.options.classHandler];
                                if ("function" === typeof $handlerFunction) {
                                    var $handler = $handlerFunction.call(this, this); // If this function returned a valid existing DOM element, go for it
                                    if ("undefined" !== typeof $handler && $handler.length) return $handler;
                                } else if ("object" === _typeof($handlerFunction) && $handlerFunction instanceof jQuery && $handlerFunction.length) return $handlerFunction;
                                else if ($handlerFunction) Utils.warn("The class handler `" + $handlerFunction + "` does not exist in DOM nor as a global JS function");
                                return this._inputHolder();
                            },
                            _inputHolder: function _inputHolder() {
                                // if simple element (input, texatrea, select...) it will perfectly host the classes and precede the error container
                                if (!this.options.multiple || this.element.nodeName === "SELECT") return this.$element; // But if multiple element (radio, checkbox), that would be their parent
                                return this.$element.parent();
                            },
                            _insertErrorWrapper: function _insertErrorWrapper() {
                                var $errorsContainer = this.options.errorsContainer; // Nothing to do if already inserted
                                if (0 !== this._ui.$errorsWrapper.parent().length) return this._ui.$errorsWrapper.parent();
                                if ("string" === typeof $errorsContainer) {
                                    if ($($errorsContainer).length) return $($errorsContainer).append(this._ui.$errorsWrapper);
                                    else if ("function" === typeof window[$errorsContainer]) $errorsContainer = window[$errorsContainer];
                                    else Utils.warn("The errors container `" + $errorsContainer + "` does not exist in DOM nor as a global JS function");
                                }
                                if ("function" === typeof $errorsContainer) $errorsContainer = $errorsContainer.call(this, this);
                                if ("object" === _typeof($errorsContainer) && $errorsContainer.length) return $errorsContainer.append(this._ui.$errorsWrapper);
                                return this._inputHolder().after(this._ui.$errorsWrapper);
                            },
                            _actualizeTriggers: function _actualizeTriggers() {
                                var _this2 = this;
                                var $toBind = this._findRelated();
                                var trigger; // Remove Parsley events already bound on this field
                                $toBind.off(".Parsley");
                                if (this._failedOnce) $toBind.on(Utils.namespaceEvents(this.options.triggerAfterFailure, "Parsley"), function() {
                                    _this2._validateIfNeeded();
                                });
                                else if (trigger = Utils.namespaceEvents(this.options.trigger, "Parsley")) $toBind.on(trigger, function(event) {
                                    _this2._validateIfNeeded(event);
                                });
                            },
                            _validateIfNeeded: function _validateIfNeeded(event) {
                                var _this3 = this;
                                // For keyup, keypress, keydown, input... events that could be a little bit obstrusive
                                // do not validate if val length < min threshold on first validation. Once field have been validated once and info
                                // about success or failure have been displayed, always validate with this trigger to reflect every yalidation change.
                                if (event && /key|input/.test(event.type)) {
                                    if (!(this._ui && this._ui.validationInformationVisible) && this.getValue().length <= this.options.validationThreshold) return;
                                }
                                if (this.options.debounce) {
                                    window.clearTimeout(this._debounced);
                                    this._debounced = window.setTimeout(function() {
                                        return _this3.validate();
                                    }, this.options.debounce);
                                } else this.validate();
                            },
                            _resetUI: function _resetUI() {
                                // Reset all event listeners
                                this._failedOnce = false;
                                this._actualizeTriggers(); // Nothing to do if UI never initialized for this field
                                if ("undefined" === typeof this._ui) return; // Reset all errors' li
                                this._ui.$errorsWrapper.removeClass("filled").children().remove(); // Reset validation class
                                this._resetClass(); // Reset validation flags and last validation result
                                this._ui.lastValidationResult = [];
                                this._ui.validationInformationVisible = false;
                            },
                            _destroyUI: function _destroyUI() {
                                this._resetUI();
                                if ("undefined" !== typeof this._ui) this._ui.$errorsWrapper.remove();
                                delete this._ui;
                            },
                            _successClass: function _successClass() {
                                this._ui.validationInformationVisible = true;
                                this._ui.$errorClassHandler.removeClass(this.options.errorClass).addClass(this.options.successClass);
                            },
                            _errorClass: function _errorClass() {
                                this._ui.validationInformationVisible = true;
                                this._ui.$errorClassHandler.removeClass(this.options.successClass).addClass(this.options.errorClass);
                            },
                            _resetClass: function _resetClass() {
                                this._ui.$errorClassHandler.removeClass(this.options.successClass).removeClass(this.options.errorClass);
                            }
                        };
                        var Form = function Form(element, domOptions, options) {
                            this.__class__ = "Form";
                            this.element = element;
                            this.$element = $(element);
                            this.domOptions = domOptions;
                            this.options = options;
                            this.parent = window.Parsley;
                            this.fields = [];
                            this.validationResult = null;
                        };
                        var statusMapping = {
                            pending: null,
                            resolved: true,
                            rejected: false
                        };
                        Form.prototype = {
                            onSubmitValidate: function onSubmitValidate(event) {
                                var _this = this;
                                // This is a Parsley generated submit event, do not validate, do not prevent, simply exit and keep normal behavior
                                if (true === event.parsley) return; // If we didn't come here through a submit button, use the first one in the form
                                var submitSource = this._submitSource || this.$element.find(Utils._SubmitSelector)[0];
                                this._submitSource = null;
                                this.$element.find(".parsley-synthetic-submit-button").prop("disabled", true);
                                if (submitSource && null !== submitSource.getAttribute("formnovalidate")) return;
                                window.Parsley._remoteCache = {};
                                var promise = this.whenValidate({
                                    event: event
                                });
                                if ("resolved" === promise.state() && false !== this._trigger("submit")) ;
                                else {
                                    // Rejected or pending: cancel this submit
                                    event.stopImmediatePropagation();
                                    event.preventDefault();
                                    if ("pending" === promise.state()) promise.done(function() {
                                        _this._submit(submitSource);
                                    });
                                }
                            },
                            onSubmitButton: function onSubmitButton(event) {
                                this._submitSource = event.currentTarget;
                            },
                            // internal
                            // _submit submits the form, this time without going through the validations.
                            // Care must be taken to "fake" the actual submit button being clicked.
                            _submit: function _submit(submitSource) {
                                if (false === this._trigger("submit")) return; // Add submit button's data
                                if (submitSource) {
                                    var $synthetic = this.$element.find(".parsley-synthetic-submit-button").prop("disabled", false);
                                    if (0 === $synthetic.length) $synthetic = $('<input class="parsley-synthetic-submit-button" type="hidden">').appendTo(this.$element);
                                    $synthetic.attr({
                                        name: submitSource.getAttribute("name"),
                                        value: submitSource.getAttribute("value")
                                    });
                                }
                                this.$element.trigger(_extends($.Event("submit"), {
                                    parsley: true
                                }));
                            },
                            // Performs validation on fields while triggering events.
                            // @returns `true` if all validations succeeds, `false`
                            // if a failure is immediately detected, or `null`
                            // if dependant on a promise.
                            // Consider using `whenValidate` instead.
                            validate: function validate(options) {
                                if (arguments.length >= 1 && !$.isPlainObject(options)) {
                                    Utils.warnOnce("Calling validate on a parsley form without passing arguments as an object is deprecated.");
                                    var _arguments = Array.prototype.slice.call(arguments), group = _arguments[0], force = _arguments[1], event = _arguments[2];
                                    options = {
                                        group: group,
                                        force: force,
                                        event: event
                                    };
                                }
                                return statusMapping[this.whenValidate(options).state()];
                            },
                            whenValidate: function whenValidate() {
                                var _this2 = this, _Utils$all$done$fail$;
                                var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, group = _ref.group, force = _ref.force, event = _ref.event;
                                this.submitEvent = event;
                                if (event) this.submitEvent = _extends({}, event, {
                                    preventDefault: function preventDefault() {
                                        Utils.warnOnce("Using `this.submitEvent.preventDefault()` is deprecated; instead, call `this.validationResult = false`");
                                        _this2.validationResult = false;
                                    }
                                });
                                this.validationResult = true; // fire validate event to eventually modify things before every validation
                                this._trigger("validate"); // Refresh form DOM options and form's fields that could have changed
                                this._refreshFields();
                                var promises = this._withoutReactualizingFormOptions(function() {
                                    return $.map(_this2.fields, function(field) {
                                        return field.whenValidate({
                                            force: force,
                                            group: group
                                        });
                                    });
                                });
                                return (_Utils$all$done$fail$ = Utils.all(promises).done(function() {
                                    _this2._trigger("success");
                                }).fail(function() {
                                    _this2.validationResult = false;
                                    _this2.focus();
                                    _this2._trigger("error");
                                }).always(function() {
                                    _this2._trigger("validated");
                                })).pipe.apply(_Utils$all$done$fail$, _toConsumableArray(this._pipeAccordingToValidationResult()));
                            },
                            // Iterate over refreshed fields, and stop on first failure.
                            // Returns `true` if all fields are valid, `false` if a failure is detected
                            // or `null` if the result depends on an unresolved promise.
                            // Prefer using `whenValid` instead.
                            isValid: function isValid(options) {
                                if (arguments.length >= 1 && !$.isPlainObject(options)) {
                                    Utils.warnOnce("Calling isValid on a parsley form without passing arguments as an object is deprecated.");
                                    var _arguments2 = Array.prototype.slice.call(arguments), group = _arguments2[0], force = _arguments2[1];
                                    options = {
                                        group: group,
                                        force: force
                                    };
                                }
                                return statusMapping[this.whenValid(options).state()];
                            },
                            // Iterate over refreshed fields and validate them.
                            // Returns a promise.
                            // A validation that immediately fails will interrupt the validations.
                            whenValid: function whenValid() {
                                var _this3 = this;
                                var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, group = _ref2.group, force = _ref2.force;
                                this._refreshFields();
                                var promises = this._withoutReactualizingFormOptions(function() {
                                    return $.map(_this3.fields, function(field) {
                                        return field.whenValid({
                                            group: group,
                                            force: force
                                        });
                                    });
                                });
                                return Utils.all(promises);
                            },
                            refresh: function refresh() {
                                this._refreshFields();
                                return this;
                            },
                            // Reset UI
                            reset: function reset() {
                                // Form case: emit a reset event for each field
                                for(var i = 0; i < this.fields.length; i++)this.fields[i].reset();
                                this._trigger("reset");
                            },
                            // Destroy Parsley instance (+ UI)
                            destroy: function destroy() {
                                // Field case: emit destroy event to clean UI and then destroy stored instance
                                this._destroyUI(); // Form case: destroy all its fields and then destroy stored instance
                                for(var i = 0; i < this.fields.length; i++)this.fields[i].destroy();
                                this.$element.removeData("Parsley");
                                this._trigger("destroy");
                            },
                            _refreshFields: function _refreshFields() {
                                return this.actualizeOptions()._bindFields();
                            },
                            _bindFields: function _bindFields() {
                                var _this4 = this;
                                var oldFields = this.fields;
                                this.fields = [];
                                this.fieldsMappedById = {};
                                this._withoutReactualizingFormOptions(function() {
                                    _this4.$element.find(_this4.options.inputs).not(_this4.options.excluded).not("[".concat(_this4.options.namespace, "excluded=true]")).each(function(_, element) {
                                        var fieldInstance = new window.Parsley.Factory(element, {}, _this4); // Only add valid and not excluded `Field` and `FieldMultiple` children
                                        if ("Field" === fieldInstance.__class__ || "FieldMultiple" === fieldInstance.__class__) {
                                            var uniqueId = fieldInstance.__class__ + "-" + fieldInstance.__id__;
                                            if ("undefined" === typeof _this4.fieldsMappedById[uniqueId]) {
                                                _this4.fieldsMappedById[uniqueId] = fieldInstance;
                                                _this4.fields.push(fieldInstance);
                                            }
                                        }
                                    });
                                    $.each(Utils.difference(oldFields, _this4.fields), function(_, field) {
                                        field.reset();
                                    });
                                });
                                return this;
                            },
                            // Internal only.
                            // Looping on a form's fields to do validation or similar
                            // will trigger reactualizing options on all of them, which
                            // in turn will reactualize the form's options.
                            // To avoid calling actualizeOptions so many times on the form
                            // for nothing, _withoutReactualizingFormOptions temporarily disables
                            // the method actualizeOptions on this form while `fn` is called.
                            _withoutReactualizingFormOptions: function _withoutReactualizingFormOptions(fn) {
                                var oldActualizeOptions = this.actualizeOptions;
                                this.actualizeOptions = function() {
                                    return this;
                                };
                                var result = fn();
                                this.actualizeOptions = oldActualizeOptions;
                                return result;
                            },
                            // Internal only.
                            // Shortcut to trigger an event
                            // Returns true iff event is not interrupted and default not prevented.
                            _trigger: function _trigger(eventName) {
                                return this.trigger("form:" + eventName);
                            }
                        };
                        var Constraint = function Constraint(parsleyField, name, requirements, priority, isDomConstraint) {
                            var validatorSpec = window.Parsley._validatorRegistry.validators[name];
                            var validator = new Validator(validatorSpec);
                            priority = priority || parsleyField.options[name + "Priority"] || validator.priority;
                            isDomConstraint = true === isDomConstraint;
                            _extends(this, {
                                validator: validator,
                                name: name,
                                requirements: requirements,
                                priority: priority,
                                isDomConstraint: isDomConstraint
                            });
                            this._parseRequirements(parsleyField.options);
                        };
                        var capitalize = function capitalize(str) {
                            var cap = str[0].toUpperCase();
                            return cap + str.slice(1);
                        };
                        Constraint.prototype = {
                            validate: function validate(value, instance) {
                                var _this$validator;
                                return (_this$validator = this.validator).validate.apply(_this$validator, [
                                    value
                                ].concat(_toConsumableArray(this.requirementList), [
                                    instance
                                ]));
                            },
                            _parseRequirements: function _parseRequirements(options) {
                                var _this = this;
                                this.requirementList = this.validator.parseRequirements(this.requirements, function(key) {
                                    return options[_this.name + capitalize(key)];
                                });
                            }
                        };
                        var Field = function Field(field, domOptions, options, parsleyFormInstance) {
                            this.__class__ = "Field";
                            this.element = field;
                            this.$element = $(field); // Set parent if we have one
                            if ("undefined" !== typeof parsleyFormInstance) this.parent = parsleyFormInstance;
                            this.options = options;
                            this.domOptions = domOptions; // Initialize some properties
                            this.constraints = [];
                            this.constraintsByName = {};
                            this.validationResult = true; // Bind constraints
                            this._bindConstraints();
                        };
                        var statusMapping$1 = {
                            pending: null,
                            resolved: true,
                            rejected: false
                        };
                        Field.prototype = {
                            // # Public API
                            // Validate field and trigger some events for mainly `UI`
                            // @returns `true`, an array of the validators that failed, or
                            // `null` if validation is not finished. Prefer using whenValidate
                            validate: function validate(options) {
                                if (arguments.length >= 1 && !$.isPlainObject(options)) {
                                    Utils.warnOnce("Calling validate on a parsley field without passing arguments as an object is deprecated.");
                                    options = {
                                        options: options
                                    };
                                }
                                var promise = this.whenValidate(options);
                                if (!promise) return true;
                                switch(promise.state()){
                                    case "pending":
                                        return null;
                                    case "resolved":
                                        return true;
                                    case "rejected":
                                        return this.validationResult;
                                }
                            },
                            // Validate field and trigger some events for mainly `UI`
                            // @returns a promise that succeeds only when all validations do
                            // or `undefined` if field is not in the given `group`.
                            whenValidate: function whenValidate() {
                                var _this$whenValid$alway, _this = this;
                                var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, force = _ref.force, group = _ref.group;
                                // do not validate a field if not the same as given validation group
                                this.refresh();
                                if (group && !this._isInGroup(group)) return;
                                this.value = this.getValue(); // Field Validate event. `this.value` could be altered for custom needs
                                this._trigger("validate");
                                return (_this$whenValid$alway = this.whenValid({
                                    force: force,
                                    value: this.value,
                                    _refreshed: true
                                }).always(function() {
                                    _this._reflowUI();
                                }).done(function() {
                                    _this._trigger("success");
                                }).fail(function() {
                                    _this._trigger("error");
                                }).always(function() {
                                    _this._trigger("validated");
                                })).pipe.apply(_this$whenValid$alway, _toConsumableArray(this._pipeAccordingToValidationResult()));
                            },
                            hasConstraints: function hasConstraints() {
                                return 0 !== this.constraints.length;
                            },
                            // An empty optional field does not need validation
                            needsValidation: function needsValidation(value) {
                                if ("undefined" === typeof value) value = this.getValue(); // If a field is empty and not required, it is valid
                                // Except if `data-parsley-validate-if-empty` explicitely added, useful for some custom validators
                                if (!value.length && !this._isRequired() && "undefined" === typeof this.options.validateIfEmpty) return false;
                                return true;
                            },
                            _isInGroup: function _isInGroup(group) {
                                if (Array.isArray(this.options.group)) return -1 !== $.inArray(group, this.options.group);
                                return this.options.group === group;
                            },
                            // Just validate field. Do not trigger any event.
                            // Returns `true` iff all constraints pass, `false` if there are failures,
                            // or `null` if the result can not be determined yet (depends on a promise)
                            // See also `whenValid`.
                            isValid: function isValid(options) {
                                if (arguments.length >= 1 && !$.isPlainObject(options)) {
                                    Utils.warnOnce("Calling isValid on a parsley field without passing arguments as an object is deprecated.");
                                    var _arguments = Array.prototype.slice.call(arguments), force = _arguments[0], value = _arguments[1];
                                    options = {
                                        force: force,
                                        value: value
                                    };
                                }
                                var promise = this.whenValid(options);
                                if (!promise) return true;
                                return statusMapping$1[promise.state()];
                            },
                            // Just validate field. Do not trigger any event.
                            // @returns a promise that succeeds only when all validations do
                            // or `undefined` if the field is not in the given `group`.
                            // The argument `force` will force validation of empty fields.
                            // If a `value` is given, it will be validated instead of the value of the input.
                            whenValid: function whenValid() {
                                var _this2 = this;
                                var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, _ref2$force = _ref2.force, force = _ref2$force === void 0 ? false : _ref2$force, value = _ref2.value, group = _ref2.group, _refreshed = _ref2._refreshed;
                                // Recompute options and rebind constraints to have latest changes
                                if (!_refreshed) this.refresh(); // do not validate a field if not the same as given validation group
                                if (group && !this._isInGroup(group)) return;
                                this.validationResult = true; // A field without constraint is valid
                                if (!this.hasConstraints()) return $.when(); // Value could be passed as argument, needed to add more power to 'field:validate'
                                if ("undefined" === typeof value || null === value) value = this.getValue();
                                if (!this.needsValidation(value) && true !== force) return $.when();
                                var groupedConstraints = this._getGroupedConstraints();
                                var promises = [];
                                $.each(groupedConstraints, function(_, constraints) {
                                    // Process one group of constraints at a time, we validate the constraints
                                    // and combine the promises together.
                                    var promise = Utils.all($.map(constraints, function(constraint) {
                                        return _this2._validateConstraint(value, constraint);
                                    }));
                                    promises.push(promise);
                                    if (promise.state() === "rejected") return false; // Interrupt processing if a group has already failed
                                });
                                return Utils.all(promises);
                            },
                            // @returns a promise
                            _validateConstraint: function _validateConstraint(value, constraint) {
                                var _this3 = this;
                                var result = constraint.validate(value, this); // Map false to a failed promise
                                if (false === result) result = $.Deferred().reject(); // Make sure we return a promise and that we record failures
                                return Utils.all([
                                    result
                                ]).fail(function(errorMessage) {
                                    if (!(_this3.validationResult instanceof Array)) _this3.validationResult = [];
                                    _this3.validationResult.push({
                                        assert: constraint,
                                        errorMessage: "string" === typeof errorMessage && errorMessage
                                    });
                                });
                            },
                            // @returns Parsley field computed value that could be overrided or configured in DOM
                            getValue: function getValue() {
                                var value; // Value could be overriden in DOM or with explicit options
                                if ("function" === typeof this.options.value) value = this.options.value(this);
                                else if ("undefined" !== typeof this.options.value) value = this.options.value;
                                else value = this.$element.val(); // Handle wrong DOM or configurations
                                if ("undefined" === typeof value || null === value) return "";
                                return this._handleWhitespace(value);
                            },
                            // Reset UI
                            reset: function reset() {
                                this._resetUI();
                                return this._trigger("reset");
                            },
                            // Destroy Parsley instance (+ UI)
                            destroy: function destroy() {
                                // Field case: emit destroy event to clean UI and then destroy stored instance
                                this._destroyUI();
                                this.$element.removeData("Parsley");
                                this.$element.removeData("FieldMultiple");
                                this._trigger("destroy");
                            },
                            // Actualize options and rebind constraints
                            refresh: function refresh() {
                                this._refreshConstraints();
                                return this;
                            },
                            _refreshConstraints: function _refreshConstraints() {
                                return this.actualizeOptions()._bindConstraints();
                            },
                            refreshConstraints: function refreshConstraints() {
                                Utils.warnOnce("Parsley's refreshConstraints is deprecated. Please use refresh");
                                return this.refresh();
                            },
                            /**
    * Add a new constraint to a field
    *
    * @param {String}   name
    * @param {Mixed}    requirements      optional
    * @param {Number}   priority          optional
    * @param {Boolean}  isDomConstraint   optional
    */ addConstraint: function addConstraint(name, requirements, priority, isDomConstraint) {
                                if (window.Parsley._validatorRegistry.validators[name]) {
                                    var constraint = new Constraint(this, name, requirements, priority, isDomConstraint); // if constraint already exist, delete it and push new version
                                    if ("undefined" !== this.constraintsByName[constraint.name]) this.removeConstraint(constraint.name);
                                    this.constraints.push(constraint);
                                    this.constraintsByName[constraint.name] = constraint;
                                }
                                return this;
                            },
                            // Remove a constraint
                            removeConstraint: function removeConstraint(name) {
                                for(var i = 0; i < this.constraints.length; i++)if (name === this.constraints[i].name) {
                                    this.constraints.splice(i, 1);
                                    break;
                                }
                                delete this.constraintsByName[name];
                                return this;
                            },
                            // Update a constraint (Remove + re-add)
                            updateConstraint: function updateConstraint(name, parameters, priority) {
                                return this.removeConstraint(name).addConstraint(name, parameters, priority);
                            },
                            // # Internals
                            // Internal only.
                            // Bind constraints from config + options + DOM
                            _bindConstraints: function _bindConstraints() {
                                var constraints = [];
                                var constraintsByName = {}; // clean all existing DOM constraints to only keep javascript user constraints
                                for(var i = 0; i < this.constraints.length; i++)if (false === this.constraints[i].isDomConstraint) {
                                    constraints.push(this.constraints[i]);
                                    constraintsByName[this.constraints[i].name] = this.constraints[i];
                                }
                                this.constraints = constraints;
                                this.constraintsByName = constraintsByName; // then re-add Parsley DOM-API constraints
                                for(var name in this.options)this.addConstraint(name, this.options[name], undefined, true);
                                 // finally, bind special HTML5 constraints
                                return this._bindHtml5Constraints();
                            },
                            // Internal only.
                            // Bind specific HTML5 constraints to be HTML5 compliant
                            _bindHtml5Constraints: function _bindHtml5Constraints() {
                                // html5 required
                                if (null !== this.element.getAttribute("required")) this.addConstraint("required", true, undefined, true); // html5 pattern
                                if (null !== this.element.getAttribute("pattern")) this.addConstraint("pattern", this.element.getAttribute("pattern"), undefined, true); // range
                                var min = this.element.getAttribute("min");
                                var max = this.element.getAttribute("max");
                                if (null !== min && null !== max) this.addConstraint("range", [
                                    min,
                                    max
                                ], undefined, true); // HTML5 min
                                else if (null !== min) this.addConstraint("min", min, undefined, true); // HTML5 max
                                else if (null !== max) this.addConstraint("max", max, undefined, true); // length
                                if (null !== this.element.getAttribute("minlength") && null !== this.element.getAttribute("maxlength")) this.addConstraint("length", [
                                    this.element.getAttribute("minlength"),
                                    this.element.getAttribute("maxlength")
                                ], undefined, true); // HTML5 minlength
                                else if (null !== this.element.getAttribute("minlength")) this.addConstraint("minlength", this.element.getAttribute("minlength"), undefined, true); // HTML5 maxlength
                                else if (null !== this.element.getAttribute("maxlength")) this.addConstraint("maxlength", this.element.getAttribute("maxlength"), undefined, true); // html5 types
                                var type = Utils.getType(this.element); // Small special case here for HTML5 number: integer validator if step attribute is undefined or an integer value, number otherwise
                                if ("number" === type) return this.addConstraint("type", [
                                    "number",
                                    {
                                        step: this.element.getAttribute("step") || "1",
                                        base: min || this.element.getAttribute("value")
                                    }
                                ], undefined, true); // Regular other HTML5 supported types
                                else if (/^(email|url|range|date)$/i.test(type)) return this.addConstraint("type", type, undefined, true);
                                return this;
                            },
                            // Internal only.
                            // Field is required if have required constraint without `false` value
                            _isRequired: function _isRequired() {
                                if ("undefined" === typeof this.constraintsByName.required) return false;
                                return false !== this.constraintsByName.required.requirements;
                            },
                            // Internal only.
                            // Shortcut to trigger an event
                            _trigger: function _trigger(eventName) {
                                return this.trigger("field:" + eventName);
                            },
                            // Internal only
                            // Handles whitespace in a value
                            // Use `data-parsley-whitespace="squish"` to auto squish input value
                            // Use `data-parsley-whitespace="trim"` to auto trim input value
                            _handleWhitespace: function _handleWhitespace(value) {
                                if (true === this.options.trimValue) Utils.warnOnce('data-parsley-trim-value="true" is deprecated, please use data-parsley-whitespace="trim"');
                                if ("squish" === this.options.whitespace) value = value.replace(/\s{2,}/g, " ");
                                if ("trim" === this.options.whitespace || "squish" === this.options.whitespace || true === this.options.trimValue) value = Utils.trimString(value);
                                return value;
                            },
                            _isDateInput: function _isDateInput() {
                                var c = this.constraintsByName.type;
                                return c && c.requirements === "date";
                            },
                            // Internal only.
                            // Returns the constraints, grouped by descending priority.
                            // The result is thus an array of arrays of constraints.
                            _getGroupedConstraints: function _getGroupedConstraints() {
                                if (false === this.options.priorityEnabled) return [
                                    this.constraints
                                ];
                                var groupedConstraints = [];
                                var index = {}; // Create array unique of priorities
                                for(var i = 0; i < this.constraints.length; i++){
                                    var p = this.constraints[i].priority;
                                    if (!index[p]) groupedConstraints.push(index[p] = []);
                                    index[p].push(this.constraints[i]);
                                } // Sort them by priority DESC
                                groupedConstraints.sort(function(a, b) {
                                    return b[0].priority - a[0].priority;
                                });
                                return groupedConstraints;
                            }
                        };
                        var Multiple = function Multiple() {
                            this.__class__ = "FieldMultiple";
                        };
                        Multiple.prototype = {
                            // Add new `$element` sibling for multiple field
                            addElement: function addElement($element) {
                                this.$elements.push($element);
                                return this;
                            },
                            // See `Field._refreshConstraints()`
                            _refreshConstraints: function _refreshConstraints() {
                                var fieldConstraints;
                                this.constraints = []; // Select multiple special treatment
                                if (this.element.nodeName === "SELECT") {
                                    this.actualizeOptions()._bindConstraints();
                                    return this;
                                } // Gather all constraints for each input in the multiple group
                                for(var i = 0; i < this.$elements.length; i++){
                                    // Check if element have not been dynamically removed since last binding
                                    if (!$("html").has(this.$elements[i]).length) {
                                        this.$elements.splice(i, 1);
                                        continue;
                                    }
                                    fieldConstraints = this.$elements[i].data("FieldMultiple")._refreshConstraints().constraints;
                                    for(var j = 0; j < fieldConstraints.length; j++)this.addConstraint(fieldConstraints[j].name, fieldConstraints[j].requirements, fieldConstraints[j].priority, fieldConstraints[j].isDomConstraint);
                                }
                                return this;
                            },
                            // See `Field.getValue()`
                            getValue: function getValue() {
                                // Value could be overriden in DOM
                                if ("function" === typeof this.options.value) return this.options.value(this);
                                else if ("undefined" !== typeof this.options.value) return this.options.value; // Radio input case
                                if (this.element.nodeName === "INPUT") {
                                    var type = Utils.getType(this.element);
                                    if (type === "radio") return this._findRelated().filter(":checked").val() || ""; // checkbox input case
                                    if (type === "checkbox") {
                                        var values = [];
                                        this._findRelated().filter(":checked").each(function() {
                                            values.push($(this).val());
                                        });
                                        return values;
                                    }
                                } // Select multiple case
                                if (this.element.nodeName === "SELECT" && null === this.$element.val()) return []; // Default case that should never happen
                                return this.$element.val();
                            },
                            _init: function _init() {
                                this.$elements = [
                                    this.$element
                                ];
                                return this;
                            }
                        };
                        var Factory = function Factory(element, options, parsleyFormInstance) {
                            this.element = element;
                            this.$element = $(element); // If the element has already been bound, returns its saved Parsley instance
                            var savedparsleyFormInstance = this.$element.data("Parsley");
                            if (savedparsleyFormInstance) {
                                // If the saved instance has been bound without a Form parent and there is one given in this call, add it
                                if ("undefined" !== typeof parsleyFormInstance && savedparsleyFormInstance.parent === window.Parsley) {
                                    savedparsleyFormInstance.parent = parsleyFormInstance;
                                    savedparsleyFormInstance._resetOptions(savedparsleyFormInstance.options);
                                }
                                if ("object" === _typeof(options)) _extends(savedparsleyFormInstance.options, options);
                                return savedparsleyFormInstance;
                            } // Parsley must be instantiated with a DOM element or jQuery $element
                            if (!this.$element.length) throw new Error("You must bind Parsley on an existing element.");
                            if ("undefined" !== typeof parsleyFormInstance && "Form" !== parsleyFormInstance.__class__) throw new Error("Parent instance must be a Form instance");
                            this.parent = parsleyFormInstance || window.Parsley;
                            return this.init(options);
                        };
                        Factory.prototype = {
                            init: function init(options) {
                                this.__class__ = "Parsley";
                                this.__version__ = "2.9.2";
                                this.__id__ = Utils.generateID(); // Pre-compute options
                                this._resetOptions(options); // A Form instance is obviously a `<form>` element but also every node that is not an input and has the `data-parsley-validate` attribute
                                if (this.element.nodeName === "FORM" || Utils.checkAttr(this.element, this.options.namespace, "validate") && !this.$element.is(this.options.inputs)) return this.bind("parsleyForm"); // Every other element is bound as a `Field` or `FieldMultiple`
                                return this.isMultiple() ? this.handleMultiple() : this.bind("parsleyField");
                            },
                            isMultiple: function isMultiple() {
                                var type = Utils.getType(this.element);
                                return type === "radio" || type === "checkbox" || this.element.nodeName === "SELECT" && null !== this.element.getAttribute("multiple");
                            },
                            // Multiples fields are a real nightmare :(
                            // Maybe some refactoring would be appreciated here...
                            handleMultiple: function handleMultiple() {
                                var _this = this;
                                var name;
                                var parsleyMultipleInstance; // Handle multiple name
                                this.options.multiple = this.options.multiple || (name = this.element.getAttribute("name")) || this.element.getAttribute("id"); // Special select multiple input
                                if (this.element.nodeName === "SELECT" && null !== this.element.getAttribute("multiple")) {
                                    this.options.multiple = this.options.multiple || this.__id__;
                                    return this.bind("parsleyFieldMultiple"); // Else for radio / checkboxes, we need a `name` or `data-parsley-multiple` to properly bind it
                                } else if (!this.options.multiple) {
                                    Utils.warn("To be bound by Parsley, a radio, a checkbox and a multiple select input must have either a name or a multiple option.", this.$element);
                                    return this;
                                } // Remove special chars
                                this.options.multiple = this.options.multiple.replace(/(:|\.|\[|\]|\{|\}|\$)/g, ""); // Add proper `data-parsley-multiple` to siblings if we have a valid multiple name
                                if (name) $('input[name="' + name + '"]').each(function(i, input) {
                                    var type = Utils.getType(input);
                                    if (type === "radio" || type === "checkbox") input.setAttribute(_this.options.namespace + "multiple", _this.options.multiple);
                                });
                                 // Check here if we don't already have a related multiple instance saved
                                var $previouslyRelated = this._findRelated();
                                for(var i = 0; i < $previouslyRelated.length; i++){
                                    parsleyMultipleInstance = $($previouslyRelated.get(i)).data("Parsley");
                                    if ("undefined" !== typeof parsleyMultipleInstance) {
                                        if (!this.$element.data("FieldMultiple")) parsleyMultipleInstance.addElement(this.$element);
                                        break;
                                    }
                                } // Create a secret Field instance for every multiple field. It will be stored in `data('FieldMultiple')`
                                // And will be useful later to access classic `Field` stuff while being in a `FieldMultiple` instance
                                this.bind("parsleyField", true);
                                return parsleyMultipleInstance || this.bind("parsleyFieldMultiple");
                            },
                            // Return proper `Form`, `Field` or `FieldMultiple`
                            bind: function bind(type, doNotStore) {
                                var parsleyInstance;
                                switch(type){
                                    case "parsleyForm":
                                        parsleyInstance = $.extend(new Form(this.element, this.domOptions, this.options), new Base(), window.ParsleyExtend)._bindFields();
                                        break;
                                    case "parsleyField":
                                        parsleyInstance = $.extend(new Field(this.element, this.domOptions, this.options, this.parent), new Base(), window.ParsleyExtend);
                                        break;
                                    case "parsleyFieldMultiple":
                                        parsleyInstance = $.extend(new Field(this.element, this.domOptions, this.options, this.parent), new Multiple(), new Base(), window.ParsleyExtend)._init();
                                        break;
                                    default:
                                        throw new Error(type + "is not a supported Parsley type");
                                }
                                if (this.options.multiple) Utils.setAttr(this.element, this.options.namespace, "multiple", this.options.multiple);
                                if ("undefined" !== typeof doNotStore) {
                                    this.$element.data("FieldMultiple", parsleyInstance);
                                    return parsleyInstance;
                                } // Store the freshly bound instance in a DOM element for later access using jQuery `data()`
                                this.$element.data("Parsley", parsleyInstance); // Tell the world we have a new Form or Field instance!
                                parsleyInstance._actualizeTriggers();
                                parsleyInstance._trigger("init");
                                return parsleyInstance;
                            }
                        };
                        var vernums = $.fn.jquery.split(".");
                        if (parseInt(vernums[0]) <= 1 && parseInt(vernums[1]) < 8) throw "The loaded version of jQuery is too old. Please upgrade to 1.8.x or better.";
                        if (!vernums.forEach) Utils.warn("Parsley requires ES5 to run properly. Please include https://github.com/es-shims/es5-shim");
                         // Inherit `on`, `off` & `trigger` to Parsley:
                        var Parsley = _extends(new Base(), {
                            element: document,
                            $element: $(document),
                            actualizeOptions: null,
                            _resetOptions: null,
                            Factory: Factory,
                            version: "2.9.2"
                        }); // Supplement Field and Form with Base
                        // This way, the constructors will have access to those methods
                        _extends(Field.prototype, UI.Field, Base.prototype);
                        _extends(Form.prototype, UI.Form, Base.prototype); // Inherit actualizeOptions and _resetOptions:
                        _extends(Factory.prototype, Base.prototype); // ### jQuery API
                        // `$('.elem').parsley(options)` or `$('.elem').psly(options)`
                        $.fn.parsley = $.fn.psly = function(options) {
                            if (this.length > 1) {
                                var instances = [];
                                this.each(function() {
                                    instances.push($(this).parsley(options));
                                });
                                return instances;
                            } // Return undefined if applied to non existing DOM element
                            if (this.length == 0) return;
                            return new Factory(this[0], options);
                        }; // ### Field and Form extension
                        // Ensure the extension is now defined if it wasn't previously
                        if ("undefined" === typeof window.ParsleyExtend) window.ParsleyExtend = {}; // ### Parsley config
                        // Inherit from ParsleyDefault, and copy over any existing values
                        Parsley.options = _extends(Utils.objectCreate(Defaults), window.ParsleyConfig);
                        window.ParsleyConfig = Parsley.options; // Old way of accessing global options
                        // ### Globals
                        window.Parsley = window.psly = Parsley;
                        Parsley.Utils = Utils;
                        window.ParsleyUtils = {};
                        $.each(Utils, function(key, value) {
                            if ("function" === typeof value) window.ParsleyUtils[key] = function() {
                                Utils.warnOnce("Accessing `window.ParsleyUtils` is deprecated. Use `window.Parsley.Utils` instead.");
                                return Utils[key].apply(Utils, arguments);
                            };
                        }); // ### Define methods that forward to the registry, and deprecate all access except through window.Parsley
                        var registry = window.Parsley._validatorRegistry = new ValidatorRegistry(window.ParsleyConfig.validators, window.ParsleyConfig.i18n);
                        window.ParsleyValidator = {};
                        $.each("setLocale addCatalog addMessage addMessages getErrorMessage formatMessage addValidator updateValidator removeValidator hasValidator".split(" "), function(i, method) {
                            window.Parsley[method] = function() {
                                return registry[method].apply(registry, arguments);
                            };
                            window.ParsleyValidator[method] = function() {
                                var _window$Parsley;
                                Utils.warnOnce("Accessing the method '".concat(method, "' through Validator is deprecated. Simply call 'window.Parsley.").concat(method, "(...)'"));
                                return (_window$Parsley = window.Parsley)[method].apply(_window$Parsley, arguments);
                            };
                        }); // ### UI
                        // Deprecated global object
                        window.Parsley.UI = UI;
                        window.ParsleyUI = {
                            removeError: function removeError(instance, name, doNotUpdateClass) {
                                var updateClass = true !== doNotUpdateClass;
                                Utils.warnOnce("Accessing UI is deprecated. Call 'removeError' on the instance directly. Please comment in issue 1073 as to your need to call this method.");
                                return instance.removeError(name, {
                                    updateClass: updateClass
                                });
                            },
                            getErrorsMessages: function getErrorsMessages(instance) {
                                Utils.warnOnce("Accessing UI is deprecated. Call 'getErrorsMessages' on the instance directly.");
                                return instance.getErrorsMessages();
                            }
                        };
                        $.each("addError updateError".split(" "), function(i, method) {
                            window.ParsleyUI[method] = function(instance, name, message, assert, doNotUpdateClass) {
                                var updateClass = true !== doNotUpdateClass;
                                Utils.warnOnce("Accessing UI is deprecated. Call '".concat(method, "' on the instance directly. Please comment in issue 1073 as to your need to call this method."));
                                return instance[method](name, {
                                    message: message,
                                    assert: assert,
                                    updateClass: updateClass
                                });
                            };
                        }); // ### PARSLEY auto-binding
                        // Prevent it by setting `ParsleyConfig.autoBind` to `false`
                        if (false !== window.ParsleyConfig.autoBind) $(function() {
                            // Works only on `data-parsley-validate`.
                            if ($("[data-parsley-validate]").length) $("[data-parsley-validate]").parsley();
                        });
                        var o = $({});
                        var deprecated = function deprecated() {
                            Utils.warnOnce("Parsley's pubsub module is deprecated; use the 'on' and 'off' methods on parsley instances or window.Parsley");
                        }; // Returns an event handler that calls `fn` with the arguments it expects
                        function adapt(fn, context) {
                            // Store to allow unbinding
                            if (!fn.parsleyAdaptedCallback) fn.parsleyAdaptedCallback = function() {
                                var args = Array.prototype.slice.call(arguments, 0);
                                args.unshift(this);
                                fn.apply(context || o, args);
                            };
                            return fn.parsleyAdaptedCallback;
                        }
                        var eventPrefix = "parsley:"; // Converts 'parsley:form:validate' into 'form:validate'
                        function eventName(name) {
                            if (name.lastIndexOf(eventPrefix, 0) === 0) return name.substr(eventPrefix.length);
                            return name;
                        } // $.listen is deprecated. Use Parsley.on instead.
                        $.listen = function(name, callback) {
                            var context;
                            deprecated();
                            if ("object" === _typeof(arguments[1]) && "function" === typeof arguments[2]) {
                                context = arguments[1];
                                callback = arguments[2];
                            }
                            if ("function" !== typeof callback) throw new Error("Wrong parameters");
                            window.Parsley.on(eventName(name), adapt(callback, context));
                        };
                        $.listenTo = function(instance, name, fn) {
                            deprecated();
                            if (!(instance instanceof Field) && !(instance instanceof Form)) throw new Error("Must give Parsley instance");
                            if ("string" !== typeof name || "function" !== typeof fn) throw new Error("Wrong parameters");
                            instance.on(eventName(name), adapt(fn));
                        };
                        $.unsubscribe = function(name, fn) {
                            deprecated();
                            if ("string" !== typeof name || "function" !== typeof fn) throw new Error("Wrong arguments");
                            window.Parsley.off(eventName(name), fn.parsleyAdaptedCallback);
                        };
                        $.unsubscribeTo = function(instance, name) {
                            deprecated();
                            if (!(instance instanceof Field) && !(instance instanceof Form)) throw new Error("Must give Parsley instance");
                            instance.off(eventName(name));
                        };
                        $.unsubscribeAll = function(name) {
                            deprecated();
                            window.Parsley.off(eventName(name));
                            $("form,input,textarea,select").each(function() {
                                var instance = $(this).data("Parsley");
                                if (instance) instance.off(eventName(name));
                            });
                        }; // $.emit is deprecated. Use jQuery events instead.
                        $.emit = function(name, instance) {
                            var _instance;
                            deprecated();
                            var instanceGiven = instance instanceof Field || instance instanceof Form;
                            var args = Array.prototype.slice.call(arguments, instanceGiven ? 2 : 1);
                            args.unshift(eventName(name));
                            if (!instanceGiven) instance = window.Parsley;
                            (_instance = instance).trigger.apply(_instance, _toConsumableArray(args));
                        };
                        $.extend(true, Parsley, {
                            asyncValidators: {
                                "default": {
                                    fn: function fn(xhr) {
                                        // By default, only status 2xx are deemed successful.
                                        // Note: we use status instead of state() because responses with status 200
                                        // but invalid messages (e.g. an empty body for content type set to JSON) will
                                        // result in state() === 'rejected'.
                                        return xhr.status >= 200 && xhr.status < 300;
                                    },
                                    url: false
                                },
                                reverse: {
                                    fn: function fn(xhr) {
                                        // If reverse option is set, a failing ajax request is considered successful
                                        return xhr.status < 200 || xhr.status >= 300;
                                    },
                                    url: false
                                }
                            },
                            addAsyncValidator: function addAsyncValidator(name, fn, url, options) {
                                Parsley.asyncValidators[name] = {
                                    fn: fn,
                                    url: url || false,
                                    options: options || {}
                                };
                                return this;
                            }
                        });
                        Parsley.addValidator("remote", {
                            requirementType: {
                                "": "string",
                                "validator": "string",
                                "reverse": "boolean",
                                "options": "object"
                            },
                            validateString: function validateString(value, url, options, instance) {
                                var data = {};
                                var ajaxOptions;
                                var csr;
                                var validator = options.validator || (true === options.reverse ? "reverse" : "default");
                                if ("undefined" === typeof Parsley.asyncValidators[validator]) throw new Error("Calling an undefined async validator: `" + validator + "`");
                                url = Parsley.asyncValidators[validator].url || url; // Fill current value
                                if (url.indexOf("{value}") > -1) url = url.replace("{value}", encodeURIComponent(value));
                                else data[instance.element.getAttribute("name") || instance.element.getAttribute("id")] = value;
                                 // Merge options passed in from the function with the ones in the attribute
                                var remoteOptions = $.extend(true, options.options || {}, Parsley.asyncValidators[validator].options); // All `$.ajax(options)` could be overridden or extended directly from DOM in `data-parsley-remote-options`
                                ajaxOptions = $.extend(true, {}, {
                                    url: url,
                                    data: data,
                                    type: "GET"
                                }, remoteOptions); // Generate store key based on ajax options
                                instance.trigger("field:ajaxoptions", instance, ajaxOptions);
                                csr = $.param(ajaxOptions); // Initialise querry cache
                                if ("undefined" === typeof Parsley._remoteCache) Parsley._remoteCache = {}; // Try to retrieve stored xhr
                                var xhr = Parsley._remoteCache[csr] = Parsley._remoteCache[csr] || $.ajax(ajaxOptions);
                                var handleXhr = function handleXhr() {
                                    var result = Parsley.asyncValidators[validator].fn.call(instance, xhr, url, options);
                                    if (!result) result = $.Deferred().reject();
                                    return $.when(result);
                                };
                                return xhr.then(handleXhr, handleXhr);
                            },
                            priority: -1
                        });
                        Parsley.on("form:submit", function() {
                            Parsley._remoteCache = {};
                        });
                        Base.prototype.addAsyncValidator = function() {
                            Utils.warnOnce("Accessing the method `addAsyncValidator` through an instance is deprecated. Simply call `Parsley.addAsyncValidator(...)`");
                            return Parsley.addAsyncValidator.apply(Parsley, arguments);
                        };
                        // This is included with the Parsley library itself,
                        Parsley.addMessages("en", {
                            defaultMessage: "This value seems to be invalid.",
                            type: {
                                email: "This value should be a valid email.",
                                url: "This value should be a valid url.",
                                number: "This value should be a valid number.",
                                integer: "This value should be a valid integer.",
                                digits: "This value should be digits.",
                                alphanum: "This value should be alphanumeric."
                            },
                            notblank: "This value should not be blank.",
                            required: "This value is required.",
                            pattern: "This value seems to be invalid.",
                            min: "This value should be greater than or equal to %s.",
                            max: "This value should be lower than or equal to %s.",
                            range: "This value should be between %s and %s.",
                            minlength: "This value is too short. It should have %s characters or more.",
                            maxlength: "This value is too long. It should have %s characters or fewer.",
                            length: "This value length is invalid. It should be between %s and %s characters long.",
                            mincheck: "You must select at least %s choices.",
                            maxcheck: "You must select %s choices or fewer.",
                            check: "You must select between %s and %s choices.",
                            equalto: "This value should be the same.",
                            euvatin: "It's not a valid VAT Identification Number."
                        });
                        Parsley.setLocale("en");
                        function InputEvent() {
                            var _this = this;
                            var globals = window || global; // Slightly odd way construct our object. This way methods are force bound.
                            // Used to test for duplicate library.
                            _extends(this, {
                                // For browsers that do not support isTrusted, assumes event is native.
                                isNativeEvent: function isNativeEvent(evt) {
                                    return evt.originalEvent && evt.originalEvent.isTrusted !== false;
                                },
                                fakeInputEvent: function fakeInputEvent(evt) {
                                    if (_this.isNativeEvent(evt)) $(evt.target).trigger("input");
                                },
                                misbehaves: function misbehaves(evt) {
                                    if (_this.isNativeEvent(evt)) {
                                        _this.behavesOk(evt);
                                        $(document).on("change.inputevent", evt.data.selector, _this.fakeInputEvent);
                                        _this.fakeInputEvent(evt);
                                    }
                                },
                                behavesOk: function behavesOk(evt) {
                                    if (_this.isNativeEvent(evt)) $(document) // Simply unbinds the testing handler
                                    .off("input.inputevent", evt.data.selector, _this.behavesOk).off("change.inputevent", evt.data.selector, _this.misbehaves);
                                },
                                // Bind the testing handlers
                                install: function install() {
                                    if (globals.inputEventPatched) return;
                                    globals.inputEventPatched = "0.0.3";
                                    for(var _i = 0, _arr = [
                                        "select",
                                        'input[type="checkbox"]',
                                        'input[type="radio"]',
                                        'input[type="file"]'
                                    ]; _i < _arr.length; _i++){
                                        var selector = _arr[_i];
                                        $(document).on("input.inputevent", selector, {
                                            selector: selector
                                        }, _this.behavesOk).on("change.inputevent", selector, {
                                            selector: selector
                                        }, _this.misbehaves);
                                    }
                                },
                                uninstall: function uninstall() {
                                    delete globals.inputEventPatched;
                                    $(document).off(".inputevent");
                                }
                            });
                        }
                        var inputevent = new InputEvent();
                        inputevent.install();
                        return Parsley;
                    });
                }).call(this);
            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        },
        {
            "jquery": 14
        }
    ],
    19: [
        function(require1, module, exports) {
            (function(global) {
                (function() {
                    /**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.16.1
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */ (function(global, factory) {
                        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global.Popper = factory();
                    })(this, function() {
                        "use strict";
                        var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && typeof navigator !== "undefined";
                        var timeoutDuration = function() {
                            var longerTimeoutBrowsers = [
                                "Edge",
                                "Trident",
                                "Firefox"
                            ];
                            for(var i = 0; i < longerTimeoutBrowsers.length; i += 1){
                                if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) return 1;
                            }
                            return 0;
                        }();
                        function microtaskDebounce(fn) {
                            var called = false;
                            return function() {
                                if (called) return;
                                called = true;
                                window.Promise.resolve().then(function() {
                                    called = false;
                                    fn();
                                });
                            };
                        }
                        function taskDebounce(fn) {
                            var scheduled = false;
                            return function() {
                                if (!scheduled) {
                                    scheduled = true;
                                    setTimeout(function() {
                                        scheduled = false;
                                        fn();
                                    }, timeoutDuration);
                                }
                            };
                        }
                        var supportsMicroTasks = isBrowser && window.Promise;
                        /**
* Create a debounced version of a method, that's asynchronously deferred
* but called in the minimum time possible.
*
* @method
* @memberof Popper.Utils
* @argument {Function} fn
* @returns {Function}
*/ var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;
                        /**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */ function isFunction(functionToCheck) {
                            var getType = {};
                            return functionToCheck && getType.toString.call(functionToCheck) === "[object Function]";
                        }
                        /**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */ function getStyleComputedProperty(element, property) {
                            if (element.nodeType !== 1) return [];
                            // NOTE: 1 DOM access here
                            var _$window = element.ownerDocument.defaultView;
                            var css = _$window.getComputedStyle(element, null);
                            return property ? css[property] : css;
                        }
                        /**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */ function getParentNode(element) {
                            if (element.nodeName === "HTML") return element;
                            return element.parentNode || element.host;
                        }
                        /**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */ function getScrollParent(element) {
                            // Return body, `getScroll` will take care to get the correct `scrollTop` from it
                            if (!element) return document.body;
                            switch(element.nodeName){
                                case "HTML":
                                case "BODY":
                                    return element.ownerDocument.body;
                                case "#document":
                                    return element.body;
                            }
                            // Firefox want us to check `-x` and `-y` variations as well
                            var _getStyleComputedProp = getStyleComputedProperty(element), overflow = _getStyleComputedProp.overflow, overflowX = _getStyleComputedProp.overflowX, overflowY = _getStyleComputedProp.overflowY;
                            if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) return element;
                            return getScrollParent(getParentNode(element));
                        }
                        /**
 * Returns the reference node of the reference object, or the reference object itself.
 * @method
 * @memberof Popper.Utils
 * @param {Element|Object} reference - the reference element (the popper will be relative to this)
 * @returns {Element} parent
 */ function getReferenceNode(reference) {
                            return reference && reference.referenceNode ? reference.referenceNode : reference;
                        }
                        var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
                        var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);
                        /**
 * Determines if the browser is Internet Explorer
 * @method
 * @memberof Popper.Utils
 * @param {Number} version to check
 * @returns {Boolean} isIE
 */ function isIE(version) {
                            if (version === 11) return isIE11;
                            if (version === 10) return isIE10;
                            return isIE11 || isIE10;
                        }
                        /**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */ function getOffsetParent(element) {
                            if (!element) return document.documentElement;
                            var noOffsetParent = isIE(10) ? document.body : null;
                            // NOTE: 1 DOM access here
                            var offsetParent = element.offsetParent || null;
                            // Skip hidden elements which don't have an offsetParent
                            while(offsetParent === noOffsetParent && element.nextElementSibling)offsetParent = (element = element.nextElementSibling).offsetParent;
                            var nodeName = offsetParent && offsetParent.nodeName;
                            if (!nodeName || nodeName === "BODY" || nodeName === "HTML") return element ? element.ownerDocument.documentElement : document.documentElement;
                            // .offsetParent will return the closest TH, TD or TABLE in case
                            // no offsetParent is present, I hate this job...
                            if ([
                                "TH",
                                "TD",
                                "TABLE"
                            ].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, "position") === "static") return getOffsetParent(offsetParent);
                            return offsetParent;
                        }
                        function isOffsetContainer(element) {
                            var nodeName = element.nodeName;
                            if (nodeName === "BODY") return false;
                            return nodeName === "HTML" || getOffsetParent(element.firstElementChild) === element;
                        }
                        /**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */ function getRoot(node) {
                            if (node.parentNode !== null) return getRoot(node.parentNode);
                            return node;
                        }
                        /**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */ function findCommonOffsetParent(element1, element2) {
                            // This check is needed to avoid errors in case one of the elements isn't defined for any reason
                            if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) return document.documentElement;
                            // Here we make sure to give as "start" the element that comes first in the DOM
                            var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
                            var start = order ? element1 : element2;
                            var end = order ? element2 : element1;
                            // Get common ancestor container
                            var range = document.createRange();
                            range.setStart(start, 0);
                            range.setEnd(end, 0);
                            var commonAncestorContainer = range.commonAncestorContainer;
                            // Both nodes are inside #document
                            if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
                                if (isOffsetContainer(commonAncestorContainer)) return commonAncestorContainer;
                                return getOffsetParent(commonAncestorContainer);
                            }
                            // one of the nodes is inside shadowDOM, find which one
                            var element1root = getRoot(element1);
                            if (element1root.host) return findCommonOffsetParent(element1root.host, element2);
                            else return findCommonOffsetParent(element1, getRoot(element2).host);
                        }
                        /**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */ function getScroll(element) {
                            var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "top";
                            var upperSide = side === "top" ? "scrollTop" : "scrollLeft";
                            var nodeName = element.nodeName;
                            if (nodeName === "BODY" || nodeName === "HTML") {
                                var html = element.ownerDocument.documentElement;
                                var scrollingElement = element.ownerDocument.scrollingElement || html;
                                return scrollingElement[upperSide];
                            }
                            return element[upperSide];
                        }
                        /*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */ function includeScroll(rect, element) {
                            var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
                            var scrollTop = getScroll(element, "top");
                            var scrollLeft = getScroll(element, "left");
                            var modifier = subtract ? -1 : 1;
                            rect.top += scrollTop * modifier;
                            rect.bottom += scrollTop * modifier;
                            rect.left += scrollLeft * modifier;
                            rect.right += scrollLeft * modifier;
                            return rect;
                        }
                        /*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */ function getBordersSize(styles, axis) {
                            var sideA = axis === "x" ? "Left" : "Top";
                            var sideB = sideA === "Left" ? "Right" : "Bottom";
                            return parseFloat(styles["border" + sideA + "Width"]) + parseFloat(styles["border" + sideB + "Width"]);
                        }
                        function getSize(axis, body, html, computedStyle) {
                            return Math.max(body["offset" + axis], body["scroll" + axis], html["client" + axis], html["offset" + axis], html["scroll" + axis], isIE(10) ? parseInt(html["offset" + axis]) + parseInt(computedStyle["margin" + (axis === "Height" ? "Top" : "Left")]) + parseInt(computedStyle["margin" + (axis === "Height" ? "Bottom" : "Right")]) : 0);
                        }
                        function getWindowSizes(document1) {
                            var body = document1.body;
                            var html = document1.documentElement;
                            var computedStyle = isIE(10) && getComputedStyle(html);
                            return {
                                height: getSize("Height", body, html, computedStyle),
                                width: getSize("Width", body, html, computedStyle)
                            };
                        }
                        var classCallCheck = function classCallCheck(instance, Constructor) {
                            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
                        };
                        var createClass = function() {
                            function defineProperties(target, props) {
                                for(var i = 0; i < props.length; i++){
                                    var descriptor = props[i];
                                    descriptor.enumerable = descriptor.enumerable || false;
                                    descriptor.configurable = true;
                                    if ("value" in descriptor) descriptor.writable = true;
                                    Object.defineProperty(target, descriptor.key, descriptor);
                                }
                            }
                            return function(Constructor, protoProps, staticProps) {
                                if (protoProps) defineProperties(Constructor.prototype, protoProps);
                                if (staticProps) defineProperties(Constructor, staticProps);
                                return Constructor;
                            };
                        }();
                        var defineProperty = function defineProperty(obj, key, value) {
                            if (key in obj) Object.defineProperty(obj, key, {
                                value: value,
                                enumerable: true,
                                configurable: true,
                                writable: true
                            });
                            else obj[key] = value;
                            return obj;
                        };
                        var _extends = Object.assign || function(target) {
                            for(var i = 1; i < arguments.length; i++){
                                var source = arguments[i];
                                for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
                            }
                            return target;
                        };
                        /**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */ function getClientRect(offsets) {
                            return _extends({}, offsets, {
                                right: offsets.left + offsets.width,
                                bottom: offsets.top + offsets.height
                            });
                        }
                        /**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */ function getBoundingClientRect(element) {
                            var rect = {};
                            // IE10 10 FIX: Please, don't ask, the element isn't
                            // considered in DOM in some circumstances...
                            // This isn't reproducible in IE10 compatibility mode of IE11
                            try {
                                if (isIE(10)) {
                                    rect = element.getBoundingClientRect();
                                    var scrollTop = getScroll(element, "top");
                                    var scrollLeft = getScroll(element, "left");
                                    rect.top += scrollTop;
                                    rect.left += scrollLeft;
                                    rect.bottom += scrollTop;
                                    rect.right += scrollLeft;
                                } else rect = element.getBoundingClientRect();
                            } catch (e) {}
                            var result = {
                                left: rect.left,
                                top: rect.top,
                                width: rect.right - rect.left,
                                height: rect.bottom - rect.top
                            };
                            // subtract scrollbar size from sizes
                            var sizes = element.nodeName === "HTML" ? getWindowSizes(element.ownerDocument) : {};
                            var width = sizes.width || element.clientWidth || result.width;
                            var height = sizes.height || element.clientHeight || result.height;
                            var horizScrollbar = element.offsetWidth - width;
                            var vertScrollbar = element.offsetHeight - height;
                            // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
                            // we make this check conditional for performance reasons
                            if (horizScrollbar || vertScrollbar) {
                                var styles = getStyleComputedProperty(element);
                                horizScrollbar -= getBordersSize(styles, "x");
                                vertScrollbar -= getBordersSize(styles, "y");
                                result.width -= horizScrollbar;
                                result.height -= vertScrollbar;
                            }
                            return getClientRect(result);
                        }
                        function getOffsetRectRelativeToArbitraryNode(children, parent) {
                            var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
                            var isIE10 = isIE(10);
                            var isHTML = parent.nodeName === "HTML";
                            var childrenRect = getBoundingClientRect(children);
                            var parentRect = getBoundingClientRect(parent);
                            var scrollParent = getScrollParent(children);
                            var styles = getStyleComputedProperty(parent);
                            var borderTopWidth = parseFloat(styles.borderTopWidth);
                            var borderLeftWidth = parseFloat(styles.borderLeftWidth);
                            // In cases where the parent is fixed, we must ignore negative scroll in offset calc
                            if (fixedPosition && isHTML) {
                                parentRect.top = Math.max(parentRect.top, 0);
                                parentRect.left = Math.max(parentRect.left, 0);
                            }
                            var offsets = getClientRect({
                                top: childrenRect.top - parentRect.top - borderTopWidth,
                                left: childrenRect.left - parentRect.left - borderLeftWidth,
                                width: childrenRect.width,
                                height: childrenRect.height
                            });
                            offsets.marginTop = 0;
                            offsets.marginLeft = 0;
                            // Subtract margins of documentElement in case it's being used as parent
                            // we do this only on HTML because it's the only element that behaves
                            // differently when margins are applied to it. The margins are included in
                            // the box of the documentElement, in the other cases not.
                            if (!isIE10 && isHTML) {
                                var marginTop = parseFloat(styles.marginTop);
                                var marginLeft = parseFloat(styles.marginLeft);
                                offsets.top -= borderTopWidth - marginTop;
                                offsets.bottom -= borderTopWidth - marginTop;
                                offsets.left -= borderLeftWidth - marginLeft;
                                offsets.right -= borderLeftWidth - marginLeft;
                                // Attach marginTop and marginLeft because in some circumstances we may need them
                                offsets.marginTop = marginTop;
                                offsets.marginLeft = marginLeft;
                            }
                            if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== "BODY") offsets = includeScroll(offsets, parent);
                            return offsets;
                        }
                        function getViewportOffsetRectRelativeToArtbitraryNode(element) {
                            var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                            var html = element.ownerDocument.documentElement;
                            var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
                            var width = Math.max(html.clientWidth, window.innerWidth || 0);
                            var height = Math.max(html.clientHeight, window.innerHeight || 0);
                            var scrollTop = !excludeScroll ? getScroll(html) : 0;
                            var scrollLeft = !excludeScroll ? getScroll(html, "left") : 0;
                            var _$offset = {
                                top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
                                left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
                                width: width,
                                height: height
                            };
                            return getClientRect(_$offset);
                        }
                        /**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */ function isFixed(element) {
                            var nodeName = element.nodeName;
                            if (nodeName === "BODY" || nodeName === "HTML") return false;
                            if (getStyleComputedProperty(element, "position") === "fixed") return true;
                            var parentNode = getParentNode(element);
                            if (!parentNode) return false;
                            return isFixed(parentNode);
                        }
                        /**
 * Finds the first parent of an element that has a transformed property defined
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} first transformed parent or documentElement
 */ function getFixedPositionOffsetParent(element) {
                            // This check is needed to avoid errors in case one of the elements isn't defined for any reason
                            if (!element || !element.parentElement || isIE()) return document.documentElement;
                            var el = element.parentElement;
                            while(el && getStyleComputedProperty(el, "transform") === "none")el = el.parentElement;
                            return el || document.documentElement;
                        }
                        /**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @param {Boolean} fixedPosition - Is in fixed position mode
 * @returns {Object} Coordinates of the boundaries
 */ function getBoundaries(popper, reference, padding, boundariesElement) {
                            var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
                            // NOTE: 1 DOM access here
                            var boundaries = {
                                top: 0,
                                left: 0
                            };
                            var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));
                            // Handle viewport case
                            if (boundariesElement === "viewport") boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
                            else {
                                // Handle other cases based on DOM element used as boundaries
                                var boundariesNode = void 0;
                                if (boundariesElement === "scrollParent") {
                                    boundariesNode = getScrollParent(getParentNode(reference));
                                    if (boundariesNode.nodeName === "BODY") boundariesNode = popper.ownerDocument.documentElement;
                                } else if (boundariesElement === "window") boundariesNode = popper.ownerDocument.documentElement;
                                else boundariesNode = boundariesElement;
                                var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);
                                // In case of HTML, we need a different computation
                                if (boundariesNode.nodeName === "HTML" && !isFixed(offsetParent)) {
                                    var _getWindowSizes = getWindowSizes(popper.ownerDocument), height = _getWindowSizes.height, width = _getWindowSizes.width;
                                    boundaries.top += offsets.top - offsets.marginTop;
                                    boundaries.bottom = height + offsets.top;
                                    boundaries.left += offsets.left - offsets.marginLeft;
                                    boundaries.right = width + offsets.left;
                                } else // for all the other DOM elements, this one is good
                                boundaries = offsets;
                            }
                            // Add paddings
                            padding = padding || 0;
                            var isPaddingNumber = typeof padding === "number";
                            boundaries.left += isPaddingNumber ? padding : padding.left || 0;
                            boundaries.top += isPaddingNumber ? padding : padding.top || 0;
                            boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
                            boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
                            return boundaries;
                        }
                        function getArea(_ref) {
                            var width = _ref.width, height = _ref.height;
                            return width * height;
                        }
                        /**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */ function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
                            var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
                            if (placement.indexOf("auto") === -1) return placement;
                            var boundaries = getBoundaries(popper, reference, padding, boundariesElement);
                            var rects = {
                                top: {
                                    width: boundaries.width,
                                    height: refRect.top - boundaries.top
                                },
                                right: {
                                    width: boundaries.right - refRect.right,
                                    height: boundaries.height
                                },
                                bottom: {
                                    width: boundaries.width,
                                    height: boundaries.bottom - refRect.bottom
                                },
                                left: {
                                    width: refRect.left - boundaries.left,
                                    height: boundaries.height
                                }
                            };
                            var sortedAreas = Object.keys(rects).map(function(key) {
                                return _extends({
                                    key: key
                                }, rects[key], {
                                    area: getArea(rects[key])
                                });
                            }).sort(function(a, b) {
                                return b.area - a.area;
                            });
                            var filteredAreas = sortedAreas.filter(function(_ref2) {
                                var width = _ref2.width, height = _ref2.height;
                                return width >= popper.clientWidth && height >= popper.clientHeight;
                            });
                            var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;
                            var variation = placement.split("-")[1];
                            return computedPlacement + (variation ? "-" + variation : "");
                        }
                        /**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @param {Element} fixedPosition - is in fixed position mode
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */ function getReferenceOffsets(state, popper, reference) {
                            var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
                            var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));
                            return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
                        }
                        /**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */ function getOuterSizes(element) {
                            var _$window = element.ownerDocument.defaultView;
                            var styles = _$window.getComputedStyle(element);
                            var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
                            var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
                            var result = {
                                width: element.offsetWidth + y,
                                height: element.offsetHeight + x
                            };
                            return result;
                        }
                        /**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */ function getOppositePlacement(placement) {
                            var hash = {
                                left: "right",
                                right: "left",
                                bottom: "top",
                                top: "bottom"
                            };
                            return placement.replace(/left|right|bottom|top/g, function(matched) {
                                return hash[matched];
                            });
                        }
                        /**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */ function getPopperOffsets(popper, referenceOffsets, placement) {
                            placement = placement.split("-")[0];
                            // Get popper node sizes
                            var popperRect = getOuterSizes(popper);
                            // Add position, width and height to our offsets object
                            var popperOffsets = {
                                width: popperRect.width,
                                height: popperRect.height
                            };
                            // depending by the popper placement we have to compute its offsets slightly differently
                            var isHoriz = [
                                "right",
                                "left"
                            ].indexOf(placement) !== -1;
                            var mainSide = isHoriz ? "top" : "left";
                            var secondarySide = isHoriz ? "left" : "top";
                            var measurement = isHoriz ? "height" : "width";
                            var secondaryMeasurement = !isHoriz ? "height" : "width";
                            popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
                            if (placement === secondarySide) popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
                            else popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
                            return popperOffsets;
                        }
                        /**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */ function find(arr, check) {
                            // use native find if supported
                            if (Array.prototype.find) return arr.find(check);
                            // use `filter` to obtain the same behavior of `find`
                            return arr.filter(check)[0];
                        }
                        /**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */ function findIndex(arr, prop, value) {
                            // use native findIndex if supported
                            if (Array.prototype.findIndex) return arr.findIndex(function(cur) {
                                return cur[prop] === value;
                            });
                            // use `find` + `indexOf` if `findIndex` isn't supported
                            var match = find(arr, function(obj) {
                                return obj[prop] === value;
                            });
                            return arr.indexOf(match);
                        }
                        /**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */ function runModifiers(modifiers, data, ends) {
                            var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, "name", ends));
                            modifiersToRun.forEach(function(modifier) {
                                if (modifier["function"]) // eslint-disable-line dot-notation
                                console.warn("`modifier.function` is deprecated, use `modifier.fn`!");
                                var fn = modifier["function"] || modifier.fn; // eslint-disable-line dot-notation
                                if (modifier.enabled && isFunction(fn)) {
                                    // Add properties to offsets to make them a complete clientRect object
                                    // we do this before each modifier to make sure the previous one doesn't
                                    // mess with these values
                                    data.offsets.popper = getClientRect(data.offsets.popper);
                                    data.offsets.reference = getClientRect(data.offsets.reference);
                                    data = fn(data, modifier);
                                }
                            });
                            return data;
                        }
                        /**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */ function update() {
                            // if popper is destroyed, don't perform any further update
                            if (this.state.isDestroyed) return;
                            var data = {
                                instance: this,
                                styles: {},
                                arrowStyles: {},
                                attributes: {},
                                flipped: false,
                                offsets: {}
                            };
                            // compute reference element offsets
                            data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);
                            // compute auto placement, store placement inside the data object,
                            // modifiers will be able to edit `placement` if needed
                            // and refer to originalPlacement to know the original value
                            data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);
                            // store the computed placement inside `originalPlacement`
                            data.originalPlacement = data.placement;
                            data.positionFixed = this.options.positionFixed;
                            // compute the popper offsets
                            data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
                            data.offsets.popper.position = this.options.positionFixed ? "fixed" : "absolute";
                            // run the modifiers
                            data = runModifiers(this.modifiers, data);
                            // the first `update` will call `onCreate` callback
                            // the other ones will call `onUpdate` callback
                            if (!this.state.isCreated) {
                                this.state.isCreated = true;
                                this.options.onCreate(data);
                            } else this.options.onUpdate(data);
                        }
                        /**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */ function isModifierEnabled(modifiers, modifierName) {
                            return modifiers.some(function(_ref) {
                                var name = _ref.name, enabled = _ref.enabled;
                                return enabled && name === modifierName;
                            });
                        }
                        /**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */ function getSupportedPropertyName(property) {
                            var prefixes = [
                                false,
                                "ms",
                                "Webkit",
                                "Moz",
                                "O"
                            ];
                            var upperProp = property.charAt(0).toUpperCase() + property.slice(1);
                            for(var i = 0; i < prefixes.length; i++){
                                var prefix = prefixes[i];
                                var toCheck = prefix ? "" + prefix + upperProp : property;
                                if (typeof document.body.style[toCheck] !== "undefined") return toCheck;
                            }
                            return null;
                        }
                        /**
 * Destroys the popper.
 * @method
 * @memberof Popper
 */ function destroy() {
                            this.state.isDestroyed = true;
                            // touch DOM only if `applyStyle` modifier is enabled
                            if (isModifierEnabled(this.modifiers, "applyStyle")) {
                                this.popper.removeAttribute("x-placement");
                                this.popper.style.position = "";
                                this.popper.style.top = "";
                                this.popper.style.left = "";
                                this.popper.style.right = "";
                                this.popper.style.bottom = "";
                                this.popper.style.willChange = "";
                                this.popper.style[getSupportedPropertyName("transform")] = "";
                            }
                            this.disableEventListeners();
                            // remove the popper if user explicitly asked for the deletion on destroy
                            // do not use `remove` because IE11 doesn't support it
                            if (this.options.removeOnDestroy) this.popper.parentNode.removeChild(this.popper);
                            return this;
                        }
                        /**
 * Get the window associated with the element
 * @argument {Element} element
 * @returns {Window}
 */ function getWindow(element) {
                            var ownerDocument = element.ownerDocument;
                            return ownerDocument ? ownerDocument.defaultView : window;
                        }
                        function attachToScrollParents(scrollParent, event, callback, scrollParents) {
                            var isBody = scrollParent.nodeName === "BODY";
                            var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
                            target.addEventListener(event, callback, {
                                passive: true
                            });
                            if (!isBody) attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
                            scrollParents.push(target);
                        }
                        /**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */ function setupEventListeners(reference, options, state, updateBound) {
                            // Resize event listener on window
                            state.updateBound = updateBound;
                            getWindow(reference).addEventListener("resize", state.updateBound, {
                                passive: true
                            });
                            // Scroll event listener on scroll parents
                            var scrollElement = getScrollParent(reference);
                            attachToScrollParents(scrollElement, "scroll", state.updateBound, state.scrollParents);
                            state.scrollElement = scrollElement;
                            state.eventsEnabled = true;
                            return state;
                        }
                        /**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */ function enableEventListeners() {
                            if (!this.state.eventsEnabled) this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
                        }
                        /**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */ function removeEventListeners(reference, state) {
                            // Remove resize event listener on window
                            getWindow(reference).removeEventListener("resize", state.updateBound);
                            // Remove scroll event listener on scroll parents
                            state.scrollParents.forEach(function(target) {
                                target.removeEventListener("scroll", state.updateBound);
                            });
                            // Reset state
                            state.updateBound = null;
                            state.scrollParents = [];
                            state.scrollElement = null;
                            state.eventsEnabled = false;
                            return state;
                        }
                        /**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger `onUpdate` callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */ function disableEventListeners() {
                            if (this.state.eventsEnabled) {
                                cancelAnimationFrame(this.scheduleUpdate);
                                this.state = removeEventListeners(this.reference, this.state);
                            }
                        }
                        /**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */ function isNumeric(n) {
                            return n !== "" && !isNaN(parseFloat(n)) && isFinite(n);
                        }
                        /**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */ function setStyles(element, styles) {
                            Object.keys(styles).forEach(function(prop) {
                                var unit = "";
                                // add unit if the value is numeric and is one of the following
                                if ([
                                    "width",
                                    "height",
                                    "top",
                                    "right",
                                    "bottom",
                                    "left"
                                ].indexOf(prop) !== -1 && isNumeric(styles[prop])) unit = "px";
                                element.style[prop] = styles[prop] + unit;
                            });
                        }
                        /**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */ function setAttributes(element, attributes) {
                            Object.keys(attributes).forEach(function(prop) {
                                var value = attributes[prop];
                                if (value !== false) element.setAttribute(prop, attributes[prop]);
                                else element.removeAttribute(prop);
                            });
                        }
                        /**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */ function applyStyle(data) {
                            // any property present in `data.styles` will be applied to the popper,
                            // in this way we can make the 3rd party modifiers add custom styles to it
                            // Be aware, modifiers could override the properties defined in the previous
                            // lines of this modifier!
                            setStyles(data.instance.popper, data.styles);
                            // any property present in `data.attributes` will be applied to the popper,
                            // they will be set as HTML attributes of the element
                            setAttributes(data.instance.popper, data.attributes);
                            // if arrowElement is defined and arrowStyles has some properties
                            if (data.arrowElement && Object.keys(data.arrowStyles).length) setStyles(data.arrowElement, data.arrowStyles);
                            return data;
                        }
                        /**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper
 * @param {Object} options - Popper.js options
 */ function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
                            // compute reference element offsets
                            var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);
                            // compute auto placement, store placement inside the data object,
                            // modifiers will be able to edit `placement` if needed
                            // and refer to originalPlacement to know the original value
                            var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);
                            popper.setAttribute("x-placement", placement);
                            // Apply `position` to popper before anything else because
                            // without the position applied we can't guarantee correct computations
                            setStyles(popper, {
                                position: options.positionFixed ? "fixed" : "absolute"
                            });
                            return options;
                        }
                        /**
 * @function
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Boolean} shouldRound - If the offsets should be rounded at all
 * @returns {Object} The popper's position offsets rounded
 *
 * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
 * good as it can be within reason.
 * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
 *
 * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
 * as well on High DPI screens).
 *
 * Firefox prefers no rounding for positioning and does not have blurriness on
 * high DPI screens.
 *
 * Only horizontal placement and left/right values need to be considered.
 */ function getRoundedOffsets(data, shouldRound) {
                            var _data$offsets = data.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
                            var round = Math.round, floor = Math.floor;
                            var noRound = function noRound(v) {
                                return v;
                            };
                            var referenceWidth = round(reference.width);
                            var popperWidth = round(popper.width);
                            var isVertical = [
                                "left",
                                "right"
                            ].indexOf(data.placement) !== -1;
                            var isVariation = data.placement.indexOf("-") !== -1;
                            var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
                            var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;
                            var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
                            var verticalToInteger = !shouldRound ? noRound : round;
                            return {
                                left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
                                top: verticalToInteger(popper.top),
                                bottom: verticalToInteger(popper.bottom),
                                right: horizontalToInteger(popper.right)
                            };
                        }
                        var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);
                        /**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */ function computeStyle(data, options) {
                            var x = options.x, y = options.y;
                            var popper = data.offsets.popper;
                            // Remove this legacy support in Popper.js v2
                            var legacyGpuAccelerationOption = find(data.instance.modifiers, function(modifier) {
                                return modifier.name === "applyStyle";
                            }).gpuAcceleration;
                            if (legacyGpuAccelerationOption !== undefined) console.warn("WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!");
                            var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;
                            var offsetParent = getOffsetParent(data.instance.popper);
                            var offsetParentRect = getBoundingClientRect(offsetParent);
                            // Styles
                            var styles = {
                                position: popper.position
                            };
                            var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);
                            var sideA = x === "bottom" ? "top" : "bottom";
                            var sideB = y === "right" ? "left" : "right";
                            // if gpuAcceleration is set to `true` and transform is supported,
                            //  we use `translate3d` to apply the position to the popper we
                            // automatically use the supported prefixed version if needed
                            var prefixedProperty = getSupportedPropertyName("transform");
                            // now, let's make a step back and look at this code closely (wtf?)
                            // If the content of the popper grows once it's been positioned, it
                            // may happen that the popper gets misplaced because of the new content
                            // overflowing its reference element
                            // To avoid this problem, we provide two options (x and y), which allow
                            // the consumer to define the offset origin.
                            // If we position a popper on top of a reference element, we can set
                            // `x` to `top` to make the popper grow towards its top instead of
                            // its bottom.
                            var left = void 0, top = void 0;
                            if (sideA === "bottom") {
                                // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
                                // and not the bottom of the html element
                                if (offsetParent.nodeName === "HTML") top = -offsetParent.clientHeight + offsets.bottom;
                                else top = -offsetParentRect.height + offsets.bottom;
                            } else top = offsets.top;
                            if (sideB === "right") {
                                if (offsetParent.nodeName === "HTML") left = -offsetParent.clientWidth + offsets.right;
                                else left = -offsetParentRect.width + offsets.right;
                            } else left = offsets.left;
                            if (gpuAcceleration && prefixedProperty) {
                                styles[prefixedProperty] = "translate3d(" + left + "px, " + top + "px, 0)";
                                styles[sideA] = 0;
                                styles[sideB] = 0;
                                styles.willChange = "transform";
                            } else {
                                // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
                                var invertTop = sideA === "bottom" ? -1 : 1;
                                var invertLeft = sideB === "right" ? -1 : 1;
                                styles[sideA] = top * invertTop;
                                styles[sideB] = left * invertLeft;
                                styles.willChange = sideA + ", " + sideB;
                            }
                            // Attributes
                            var attributes = {
                                "x-placement": data.placement
                            };
                            // Update `data` attributes, styles and arrowStyles
                            data.attributes = _extends({}, attributes, data.attributes);
                            data.styles = _extends({}, styles, data.styles);
                            data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);
                            return data;
                        }
                        /**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */ function isModifierRequired(modifiers, requestingName, requestedName) {
                            var requesting = find(modifiers, function(_ref) {
                                var name = _ref.name;
                                return name === requestingName;
                            });
                            var isRequired = !!requesting && modifiers.some(function(modifier) {
                                return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
                            });
                            if (!isRequired) {
                                var _requesting = "`" + requestingName + "`";
                                var requested = "`" + requestedName + "`";
                                console.warn(requested + " modifier is required by " + _requesting + " modifier in order to work, be sure to include it before " + _requesting + "!");
                            }
                            return isRequired;
                        }
                        /**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */ function arrow(data, options) {
                            var _data$offsets$arrow;
                            // arrow depends on keepTogether in order to work
                            if (!isModifierRequired(data.instance.modifiers, "arrow", "keepTogether")) return data;
                            var arrowElement = options.element;
                            // if arrowElement is a string, suppose it's a CSS selector
                            if (typeof arrowElement === "string") {
                                arrowElement = data.instance.popper.querySelector(arrowElement);
                                // if arrowElement is not found, don't run the modifier
                                if (!arrowElement) return data;
                            } else // if the arrowElement isn't a query selector we must check that the
                            // provided DOM node is child of its popper node
                            if (!data.instance.popper.contains(arrowElement)) {
                                console.warn("WARNING: `arrow.element` must be child of its popper element!");
                                return data;
                            }
                            var placement = data.placement.split("-")[0];
                            var _data$offsets = data.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
                            var isVertical = [
                                "left",
                                "right"
                            ].indexOf(placement) !== -1;
                            var len = isVertical ? "height" : "width";
                            var sideCapitalized = isVertical ? "Top" : "Left";
                            var side = sideCapitalized.toLowerCase();
                            var altSide = isVertical ? "left" : "top";
                            var opSide = isVertical ? "bottom" : "right";
                            var arrowElementSize = getOuterSizes(arrowElement)[len];
                            //
                            // extends keepTogether behavior making sure the popper and its
                            // reference have enough pixels in conjunction
                            //
                            // top/left side
                            if (reference[opSide] - arrowElementSize < popper[side]) data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
                            // bottom/right side
                            if (reference[side] + arrowElementSize > popper[opSide]) data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
                            data.offsets.popper = getClientRect(data.offsets.popper);
                            // compute center of the popper
                            var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;
                            // Compute the sideValue using the updated popper offsets
                            // take popper margin in account because we don't have this info available
                            var css = getStyleComputedProperty(data.instance.popper);
                            var popperMarginSide = parseFloat(css["margin" + sideCapitalized]);
                            var popperBorderSide = parseFloat(css["border" + sideCapitalized + "Width"]);
                            var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;
                            // prevent arrowElement from being placed not contiguously to its popper
                            sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);
                            data.arrowElement = arrowElement;
                            data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ""), _data$offsets$arrow);
                            return data;
                        }
                        /**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */ function getOppositeVariation(variation) {
                            if (variation === "end") return "start";
                            else if (variation === "start") return "end";
                            return variation;
                        }
                        /**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-end` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */ var placements = [
                            "auto-start",
                            "auto",
                            "auto-end",
                            "top-start",
                            "top",
                            "top-end",
                            "right-start",
                            "right",
                            "right-end",
                            "bottom-end",
                            "bottom",
                            "bottom-start",
                            "left-end",
                            "left",
                            "left-start"
                        ];
                        // Get rid of `auto` `auto-start` and `auto-end`
                        var validPlacements = placements.slice(3);
                        /**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */ function clockwise(placement) {
                            var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                            var index = validPlacements.indexOf(placement);
                            var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
                            return counter ? arr.reverse() : arr;
                        }
                        var BEHAVIORS = {
                            FLIP: "flip",
                            CLOCKWISE: "clockwise",
                            COUNTERCLOCKWISE: "counterclockwise"
                        };
                        /**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */ function flip(data, options) {
                            // if `inner` modifier is enabled, we can't use the `flip` modifier
                            if (isModifierEnabled(data.instance.modifiers, "inner")) return data;
                            if (data.flipped && data.placement === data.originalPlacement) // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
                            return data;
                            var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);
                            var placement = data.placement.split("-")[0];
                            var placementOpposite = getOppositePlacement(placement);
                            var variation = data.placement.split("-")[1] || "";
                            var flipOrder = [];
                            switch(options.behavior){
                                case BEHAVIORS.FLIP:
                                    flipOrder = [
                                        placement,
                                        placementOpposite
                                    ];
                                    break;
                                case BEHAVIORS.CLOCKWISE:
                                    flipOrder = clockwise(placement);
                                    break;
                                case BEHAVIORS.COUNTERCLOCKWISE:
                                    flipOrder = clockwise(placement, true);
                                    break;
                                default:
                                    flipOrder = options.behavior;
                            }
                            flipOrder.forEach(function(step, index) {
                                if (placement !== step || flipOrder.length === index + 1) return data;
                                placement = data.placement.split("-")[0];
                                placementOpposite = getOppositePlacement(placement);
                                var popperOffsets = data.offsets.popper;
                                var refOffsets = data.offsets.reference;
                                // using floor because the reference offsets may contain decimals we are not going to consider here
                                var floor = Math.floor;
                                var overlapsRef = placement === "left" && floor(popperOffsets.right) > floor(refOffsets.left) || placement === "right" && floor(popperOffsets.left) < floor(refOffsets.right) || placement === "top" && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === "bottom" && floor(popperOffsets.top) < floor(refOffsets.bottom);
                                var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
                                var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
                                var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
                                var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);
                                var overflowsBoundaries = placement === "left" && overflowsLeft || placement === "right" && overflowsRight || placement === "top" && overflowsTop || placement === "bottom" && overflowsBottom;
                                // flip the variation if required
                                var isVertical = [
                                    "top",
                                    "bottom"
                                ].indexOf(placement) !== -1;
                                // flips variation if reference element overflows boundaries
                                var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === "start" && overflowsLeft || isVertical && variation === "end" && overflowsRight || !isVertical && variation === "start" && overflowsTop || !isVertical && variation === "end" && overflowsBottom);
                                // flips variation if popper content overflows boundaries
                                var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === "start" && overflowsRight || isVertical && variation === "end" && overflowsLeft || !isVertical && variation === "start" && overflowsBottom || !isVertical && variation === "end" && overflowsTop);
                                var flippedVariation = flippedVariationByRef || flippedVariationByContent;
                                if (overlapsRef || overflowsBoundaries || flippedVariation) {
                                    // this boolean to detect any flip loop
                                    data.flipped = true;
                                    if (overlapsRef || overflowsBoundaries) placement = flipOrder[index + 1];
                                    if (flippedVariation) variation = getOppositeVariation(variation);
                                    data.placement = placement + (variation ? "-" + variation : "");
                                    // this object contains `position`, we want to preserve it along with
                                    // any additional property we may add in the future
                                    data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));
                                    data = runModifiers(data.instance.modifiers, data, "flip");
                                }
                            });
                            return data;
                        }
                        /**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */ function keepTogether(data) {
                            var _data$offsets = data.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
                            var placement = data.placement.split("-")[0];
                            var floor = Math.floor;
                            var isVertical = [
                                "top",
                                "bottom"
                            ].indexOf(placement) !== -1;
                            var side = isVertical ? "right" : "bottom";
                            var opSide = isVertical ? "left" : "top";
                            var measurement = isVertical ? "width" : "height";
                            if (popper[side] < floor(reference[opSide])) data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
                            if (popper[opSide] > floor(reference[side])) data.offsets.popper[opSide] = floor(reference[side]);
                            return data;
                        }
                        /**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */ function toValue(str, measurement, popperOffsets, referenceOffsets) {
                            // separate value from unit
                            var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
                            var value = +split[1];
                            var unit = split[2];
                            // If it's not a number it's an operator, I guess
                            if (!value) return str;
                            if (unit.indexOf("%") === 0) {
                                var element = void 0;
                                switch(unit){
                                    case "%p":
                                        element = popperOffsets;
                                        break;
                                    case "%":
                                    case "%r":
                                    default:
                                        element = referenceOffsets;
                                }
                                var rect = getClientRect(element);
                                return rect[measurement] / 100 * value;
                            } else if (unit === "vh" || unit === "vw") {
                                // if is a vh or vw, we calculate the size based on the viewport
                                var size = void 0;
                                if (unit === "vh") size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
                                else size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
                                return size / 100 * value;
                            } else // if is an explicit pixel unit, we get rid of the unit and keep the value
                            // if is an implicit unit, it's px, and we return just the value
                            return value;
                        }
                        /**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */ function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
                            var offsets = [
                                0,
                                0
                            ];
                            // Use height if placement is left or right and index is 0 otherwise use width
                            // in this way the first offset will use an axis and the second one
                            // will use the other one
                            var useHeight = [
                                "right",
                                "left"
                            ].indexOf(basePlacement) !== -1;
                            // Split the offset string to obtain a list of values and operands
                            // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
                            var fragments = offset.split(/(\+|\-)/).map(function(frag) {
                                return frag.trim();
                            });
                            // Detect if the offset string contains a pair of values or a single one
                            // they could be separated by comma or space
                            var divider = fragments.indexOf(find(fragments, function(frag) {
                                return frag.search(/,|\s/) !== -1;
                            }));
                            if (fragments[divider] && fragments[divider].indexOf(",") === -1) console.warn("Offsets separated by white space(s) are deprecated, use a comma (,) instead.");
                            // If divider is found, we divide the list of values and operands to divide
                            // them by ofset X and Y.
                            var splitRegex = /\s*,\s*|\s+/;
                            var ops = divider !== -1 ? [
                                fragments.slice(0, divider).concat([
                                    fragments[divider].split(splitRegex)[0]
                                ]),
                                [
                                    fragments[divider].split(splitRegex)[1]
                                ].concat(fragments.slice(divider + 1))
                            ] : [
                                fragments
                            ];
                            // Convert the values with units to absolute pixels to allow our computations
                            ops = ops.map(function(op, index) {
                                // Most of the units rely on the orientation of the popper
                                var measurement = (index === 1 ? !useHeight : useHeight) ? "height" : "width";
                                var mergeWithPrevious = false;
                                return op// This aggregates any `+` or `-` sign that aren't considered operators
                                // e.g.: 10 + +5 => [10, +, +5]
                                .reduce(function(a, b) {
                                    if (a[a.length - 1] === "" && [
                                        "+",
                                        "-"
                                    ].indexOf(b) !== -1) {
                                        a[a.length - 1] = b;
                                        mergeWithPrevious = true;
                                        return a;
                                    } else if (mergeWithPrevious) {
                                        a[a.length - 1] += b;
                                        mergeWithPrevious = false;
                                        return a;
                                    } else return a.concat(b);
                                }, [])// Here we convert the string values into number values (in px)
                                .map(function(str) {
                                    return toValue(str, measurement, popperOffsets, referenceOffsets);
                                });
                            });
                            // Loop trough the offsets arrays and execute the operations
                            ops.forEach(function(op, index) {
                                op.forEach(function(frag, index2) {
                                    if (isNumeric(frag)) offsets[index] += frag * (op[index2 - 1] === "-" ? -1 : 1);
                                });
                            });
                            return offsets;
                        }
                        /**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */ function offset(data, _ref) {
                            var _$offset = _ref.offset;
                            var placement = data.placement, _data$offsets = data.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
                            var basePlacement = placement.split("-")[0];
                            var offsets = void 0;
                            if (isNumeric(+_$offset)) offsets = [
                                +_$offset,
                                0
                            ];
                            else offsets = parseOffset(_$offset, popper, reference, basePlacement);
                            if (basePlacement === "left") {
                                popper.top += offsets[0];
                                popper.left -= offsets[1];
                            } else if (basePlacement === "right") {
                                popper.top += offsets[0];
                                popper.left += offsets[1];
                            } else if (basePlacement === "top") {
                                popper.left += offsets[0];
                                popper.top -= offsets[1];
                            } else if (basePlacement === "bottom") {
                                popper.left += offsets[0];
                                popper.top += offsets[1];
                            }
                            data.popper = popper;
                            return data;
                        }
                        /**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */ function preventOverflow(data, options) {
                            var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);
                            // If offsetParent is the reference element, we really want to
                            // go one step up and use the next offsetParent as reference to
                            // avoid to make this modifier completely useless and look like broken
                            if (data.instance.reference === boundariesElement) boundariesElement = getOffsetParent(boundariesElement);
                            // NOTE: DOM access here
                            // resets the popper's position so that the document size can be calculated excluding
                            // the size of the popper element itself
                            var transformProp = getSupportedPropertyName("transform");
                            var popperStyles = data.instance.popper.style; // assignment to help minification
                            var top = popperStyles.top, left = popperStyles.left, transform = popperStyles[transformProp];
                            popperStyles.top = "";
                            popperStyles.left = "";
                            popperStyles[transformProp] = "";
                            var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);
                            // NOTE: DOM access here
                            // restores the original style properties after the offsets have been computed
                            popperStyles.top = top;
                            popperStyles.left = left;
                            popperStyles[transformProp] = transform;
                            options.boundaries = boundaries;
                            var order = options.priority;
                            var popper = data.offsets.popper;
                            var check = {
                                primary: function primary(placement) {
                                    var value = popper[placement];
                                    if (popper[placement] < boundaries[placement] && !options.escapeWithReference) value = Math.max(popper[placement], boundaries[placement]);
                                    return defineProperty({}, placement, value);
                                },
                                secondary: function secondary(placement) {
                                    var mainSide = placement === "right" ? "left" : "top";
                                    var value = popper[mainSide];
                                    if (popper[placement] > boundaries[placement] && !options.escapeWithReference) value = Math.min(popper[mainSide], boundaries[placement] - (placement === "right" ? popper.width : popper.height));
                                    return defineProperty({}, mainSide, value);
                                }
                            };
                            order.forEach(function(placement) {
                                var side = [
                                    "left",
                                    "top"
                                ].indexOf(placement) !== -1 ? "primary" : "secondary";
                                popper = _extends({}, popper, check[side](placement));
                            });
                            data.offsets.popper = popper;
                            return data;
                        }
                        /**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */ function shift(data) {
                            var placement = data.placement;
                            var basePlacement = placement.split("-")[0];
                            var shiftvariation = placement.split("-")[1];
                            // if shift shiftvariation is specified, run the modifier
                            if (shiftvariation) {
                                var _data$offsets = data.offsets, reference = _data$offsets.reference, popper = _data$offsets.popper;
                                var isVertical = [
                                    "bottom",
                                    "top"
                                ].indexOf(basePlacement) !== -1;
                                var side = isVertical ? "left" : "top";
                                var measurement = isVertical ? "width" : "height";
                                var shiftOffsets = {
                                    start: defineProperty({}, side, reference[side]),
                                    end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
                                };
                                data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
                            }
                            return data;
                        }
                        /**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */ function hide(data) {
                            if (!isModifierRequired(data.instance.modifiers, "hide", "preventOverflow")) return data;
                            var refRect = data.offsets.reference;
                            var bound = find(data.instance.modifiers, function(modifier) {
                                return modifier.name === "preventOverflow";
                            }).boundaries;
                            if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
                                // Avoid unnecessary DOM access if visibility hasn't changed
                                if (data.hide === true) return data;
                                data.hide = true;
                                data.attributes["x-out-of-boundaries"] = "";
                            } else {
                                // Avoid unnecessary DOM access if visibility hasn't changed
                                if (data.hide === false) return data;
                                data.hide = false;
                                data.attributes["x-out-of-boundaries"] = false;
                            }
                            return data;
                        }
                        /**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */ function inner(data) {
                            var placement = data.placement;
                            var basePlacement = placement.split("-")[0];
                            var _data$offsets = data.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
                            var isHoriz = [
                                "left",
                                "right"
                            ].indexOf(basePlacement) !== -1;
                            var subtractLength = [
                                "top",
                                "left"
                            ].indexOf(basePlacement) === -1;
                            popper[isHoriz ? "left" : "top"] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? "width" : "height"] : 0);
                            data.placement = getOppositePlacement(placement);
                            data.offsets.popper = getClientRect(popper);
                            return data;
                        }
                        /**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */ /**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */ var modifiers = {
                            /**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */ shift: {
                                /** @prop {number} order=100 - Index used to define the order of execution */ order: 100,
                                /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */ enabled: true,
                                /** @prop {ModifierFn} */ fn: shift
                            },
                            /**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unit-less, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the `height`.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
   *
   * @memberof modifiers
   * @inner
   */ offset: {
                                /** @prop {number} order=200 - Index used to define the order of execution */ order: 200,
                                /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */ enabled: true,
                                /** @prop {ModifierFn} */ fn: offset,
                                /** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */ offset: 0
                            },
                            /**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * A scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries" — or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */ preventOverflow: {
                                /** @prop {number} order=300 - Index used to define the order of execution */ order: 300,
                                /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */ enabled: true,
                                /** @prop {ModifierFn} */ fn: preventOverflow,
                                /**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */ priority: [
                                    "left",
                                    "right",
                                    "top",
                                    "bottom"
                                ],
                                /**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper. This makes sure the popper always has a little padding
     * between the edges of its container
     */ padding: 5,
                                /**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier. Can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */ boundariesElement: "scrollParent"
                            },
                            /**
   * Modifier used to make sure the reference and its popper stay near each other
   * without leaving any gap between the two. Especially useful when the arrow is
   * enabled and you want to ensure that it points to its reference element.
   * It cares only about the first axis. You can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */ keepTogether: {
                                /** @prop {number} order=400 - Index used to define the order of execution */ order: 400,
                                /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */ enabled: true,
                                /** @prop {ModifierFn} */ fn: keepTogether
                            },
                            /**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjunction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */ arrow: {
                                /** @prop {number} order=500 - Index used to define the order of execution */ order: 500,
                                /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */ enabled: true,
                                /** @prop {ModifierFn} */ fn: arrow,
                                /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */ element: "[x-arrow]"
                            },
                            /**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */ flip: {
                                /** @prop {number} order=600 - Index used to define the order of execution */ order: 600,
                                /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */ enabled: true,
                                /** @prop {ModifierFn} */ fn: flip,
                                /**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations)
     */ behavior: "flip",
                                /**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */ padding: 5,
                                /**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position.
     * The popper will never be placed outside of the defined boundaries
     * (except if `keepTogether` is enabled)
     */ boundariesElement: "viewport",
                                /**
     * @prop {Boolean} flipVariations=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the reference element overlaps its boundaries.
     *
     * The original placement should have a set variation.
     */ flipVariations: false,
                                /**
     * @prop {Boolean} flipVariationsByContent=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the popper element overlaps its reference boundaries.
     *
     * The original placement should have a set variation.
     */ flipVariationsByContent: false
                            },
                            /**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */ inner: {
                                /** @prop {number} order=700 - Index used to define the order of execution */ order: 700,
                                /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */ enabled: false,
                                /** @prop {ModifierFn} */ fn: inner
                            },
                            /**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */ hide: {
                                /** @prop {number} order=800 - Index used to define the order of execution */ order: 800,
                                /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */ enabled: true,
                                /** @prop {ModifierFn} */ fn: hide
                            },
                            /**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */ computeStyle: {
                                /** @prop {number} order=850 - Index used to define the order of execution */ order: 850,
                                /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */ enabled: true,
                                /** @prop {ModifierFn} */ fn: computeStyle,
                                /**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */ gpuAcceleration: true,
                                /**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */ x: "bottom",
                                /**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */ y: "right"
                            },
                            /**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define your own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */ applyStyle: {
                                /** @prop {number} order=900 - Index used to define the order of execution */ order: 900,
                                /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */ enabled: true,
                                /** @prop {ModifierFn} */ fn: applyStyle,
                                /** @prop {Function} */ onLoad: applyStyleOnLoad,
                                /**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */ gpuAcceleration: undefined
                            }
                        };
                        /**
 * The `dataObject` is an object containing all the information used by Popper.js.
 * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */ /**
 * Default options provided to Popper.js constructor.<br />
 * These can be overridden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass an object with the same
 * structure of the `options` object, as the 3rd argument. For example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */ var Defaults = {
                            /**
   * Popper's placement.
   * @prop {Popper.placements} placement='bottom'
   */ placement: "bottom",
                            /**
   * Set this to true if you want popper to position it self in 'fixed' mode
   * @prop {Boolean} positionFixed=false
   */ positionFixed: false,
                            /**
   * Whether events (resize, scroll) are initially enabled.
   * @prop {Boolean} eventsEnabled=true
   */ eventsEnabled: true,
                            /**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */ removeOnDestroy: false,
                            /**
   * Callback called when the popper is created.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */ onCreate: function onCreate() {},
                            /**
   * Callback called when the popper is updated. This callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */ onUpdate: function onUpdate() {},
                            /**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js.
   * @prop {modifiers}
   */ modifiers: modifiers
                        };
                        /**
 * @callback onCreate
 * @param {dataObject} data
 */ /**
 * @callback onUpdate
 * @param {dataObject} data
 */ // Utils
                        // Methods
                        var Popper = function() {
                            /**
   * Creates a new Popper.js instance.
   * @class Popper
   * @param {Element|referenceObject} reference - The reference element used to position the popper
   * @param {Element} popper - The HTML / XML element used as the popper
   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
   * @return {Object} instance - The generated Popper.js instance
   */ function Popper(reference, popper) {
                                var _this = this;
                                var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
                                classCallCheck(this, Popper);
                                this.scheduleUpdate = function() {
                                    return requestAnimationFrame(_this.update);
                                };
                                // make update() debounced, so that it only runs at most once-per-tick
                                this.update = debounce(this.update.bind(this));
                                // with {} we create a new object with the options inside it
                                this.options = _extends({}, Popper.Defaults, options);
                                // init state
                                this.state = {
                                    isDestroyed: false,
                                    isCreated: false,
                                    scrollParents: []
                                };
                                // get reference and popper elements (allow jQuery wrappers)
                                this.reference = reference && reference.jquery ? reference[0] : reference;
                                this.popper = popper && popper.jquery ? popper[0] : popper;
                                // Deep merge modifiers options
                                this.options.modifiers = {};
                                Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function(name) {
                                    _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
                                });
                                // Refactoring modifiers' list (Object => Array)
                                this.modifiers = Object.keys(this.options.modifiers).map(function(name) {
                                    return _extends({
                                        name: name
                                    }, _this.options.modifiers[name]);
                                })// sort the modifiers by order
                                .sort(function(a, b) {
                                    return a.order - b.order;
                                });
                                // modifiers have the ability to execute arbitrary code when Popper.js get inited
                                // such code is executed in the same order of its modifier
                                // they could add new properties to their options configuration
                                // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
                                this.modifiers.forEach(function(modifierOptions) {
                                    if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
                                });
                                // fire the first update to position the popper in the right place
                                this.update();
                                var eventsEnabled = this.options.eventsEnabled;
                                if (eventsEnabled) // setup event listeners, they will take care of update the position in specific situations
                                this.enableEventListeners();
                                this.state.eventsEnabled = eventsEnabled;
                            }
                            // We can't use class properties because they don't get listed in the
                            // class prototype and break stuff like Sinon stubs
                            createClass(Popper, [
                                {
                                    key: "update",
                                    value: function update$$1() {
                                        return update.call(this);
                                    }
                                },
                                {
                                    key: "destroy",
                                    value: function destroy$$1() {
                                        return destroy.call(this);
                                    }
                                },
                                {
                                    key: "enableEventListeners",
                                    value: function enableEventListeners$$1() {
                                        return enableEventListeners.call(this);
                                    }
                                },
                                {
                                    key: "disableEventListeners",
                                    value: function disableEventListeners$$1() {
                                        return disableEventListeners.call(this);
                                    }
                                }
                            ]);
                            return Popper;
                        }();
                        /**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10.
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */ Popper.Utils = (typeof window !== "undefined" ? window : global).PopperUtils;
                        Popper.placements = placements;
                        Popper.Defaults = Defaults;
                        return Popper;
                    });
                }).call(this);
            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        },
        {}
    ],
    20: [
        function(require1, module, exports) {
            /*! tether 1.4.7 */ (function(root, factory) {
                if (typeof define === "function" && define.amd) define([], factory);
                else if (typeof exports === "object") module.exports = factory();
                else root.Tether = factory();
            })(this, function() {
                "use strict";
                var _createClass = function() {
                    function defineProperties(target, props) {
                        for(var i = 0; i < props.length; i++){
                            var descriptor = props[i];
                            descriptor.enumerable = descriptor.enumerable || false;
                            descriptor.configurable = true;
                            if ("value" in descriptor) descriptor.writable = true;
                            Object.defineProperty(target, descriptor.key, descriptor);
                        }
                    }
                    return function(Constructor, protoProps, staticProps) {
                        if (protoProps) defineProperties(Constructor.prototype, protoProps);
                        if (staticProps) defineProperties(Constructor, staticProps);
                        return Constructor;
                    };
                }();
                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
                }
                var TetherBase = undefined;
                if (typeof TetherBase === "undefined") TetherBase = {
                    modules: []
                };
                var zeroElement = null;
                // Same as native getBoundingClientRect, except it takes into account parent <frame> offsets
                // if the element lies within a nested document (<frame> or <iframe>-like).
                function getActualBoundingClientRect(node) {
                    var boundingRect = node.getBoundingClientRect();
                    // The original object returned by getBoundingClientRect is immutable, so we clone it
                    // We can't use extend because the properties are not considered part of the object by hasOwnProperty in IE9
                    var rect = {};
                    for(var k in boundingRect)rect[k] = boundingRect[k];
                    try {
                        if (node.ownerDocument !== document) {
                            var _frameElement = node.ownerDocument.defaultView.frameElement;
                            if (_frameElement) {
                                var frameRect = getActualBoundingClientRect(_frameElement);
                                rect.top += frameRect.top;
                                rect.bottom += frameRect.top;
                                rect.left += frameRect.left;
                                rect.right += frameRect.left;
                            }
                        }
                    } catch (err) {
                    // Ignore "Access is denied" in IE11/Edge
                    }
                    return rect;
                }
                function getScrollParents(el) {
                    // In firefox if the el is inside an iframe with display: none; window.getComputedStyle() will return null;
                    // https://bugzilla.mozilla.org/show_bug.cgi?id=548397
                    var computedStyle = getComputedStyle(el) || {};
                    var position = computedStyle.position;
                    var parents = [];
                    if (position === "fixed") return [
                        el
                    ];
                    var parent = el;
                    while((parent = parent.parentNode) && parent && parent.nodeType === 1){
                        var style = undefined;
                        try {
                            style = getComputedStyle(parent);
                        } catch (err) {}
                        if (typeof style === "undefined" || style === null) {
                            parents.push(parent);
                            return parents;
                        }
                        var _style = style;
                        var overflow = _style.overflow;
                        var overflowX = _style.overflowX;
                        var overflowY = _style.overflowY;
                        if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
                            if (position !== "absolute" || [
                                "relative",
                                "absolute",
                                "fixed"
                            ].indexOf(style.position) >= 0) parents.push(parent);
                        }
                    }
                    parents.push(el.ownerDocument.body);
                    // If the node is within a frame, account for the parent window scroll
                    if (el.ownerDocument !== document) parents.push(el.ownerDocument.defaultView);
                    return parents;
                }
                var uniqueId = function() {
                    var id = 0;
                    return function() {
                        return ++id;
                    };
                }();
                var zeroPosCache = {};
                var getOrigin = function getOrigin() {
                    // getBoundingClientRect is unfortunately too accurate.  It introduces a pixel or two of
                    // jitter as the user scrolls that messes with our ability to detect if two positions
                    // are equivilant or not.  We place an element at the top left of the page that will
                    // get the same jitter, so we can cancel the two out.
                    var node = zeroElement;
                    if (!node || !document.body.contains(node)) {
                        node = document.createElement("div");
                        node.setAttribute("data-tether-id", uniqueId());
                        extend(node.style, {
                            top: 0,
                            left: 0,
                            position: "absolute"
                        });
                        document.body.appendChild(node);
                        zeroElement = node;
                    }
                    var id = node.getAttribute("data-tether-id");
                    if (typeof zeroPosCache[id] === "undefined") {
                        zeroPosCache[id] = getActualBoundingClientRect(node);
                        // Clear the cache when this position call is done
                        defer(function() {
                            delete zeroPosCache[id];
                        });
                    }
                    return zeroPosCache[id];
                };
                function removeUtilElements() {
                    if (zeroElement) document.body.removeChild(zeroElement);
                    zeroElement = null;
                }
                function getBounds(el) {
                    var doc = undefined;
                    if (el === document) {
                        doc = document;
                        el = document.documentElement;
                    } else doc = el.ownerDocument;
                    var docEl = doc.documentElement;
                    var box = getActualBoundingClientRect(el);
                    var origin = getOrigin();
                    box.top -= origin.top;
                    box.left -= origin.left;
                    if (typeof box.width === "undefined") box.width = document.body.scrollWidth - box.left - box.right;
                    if (typeof box.height === "undefined") box.height = document.body.scrollHeight - box.top - box.bottom;
                    box.top = box.top - docEl.clientTop;
                    box.left = box.left - docEl.clientLeft;
                    box.right = doc.body.clientWidth - box.width - box.left;
                    box.bottom = doc.body.clientHeight - box.height - box.top;
                    return box;
                }
                function getOffsetParent(el) {
                    return el.offsetParent || document.documentElement;
                }
                var _scrollBarSize = null;
                function getScrollBarSize() {
                    if (_scrollBarSize) return _scrollBarSize;
                    var inner = document.createElement("div");
                    inner.style.width = "100%";
                    inner.style.height = "200px";
                    var outer = document.createElement("div");
                    extend(outer.style, {
                        position: "absolute",
                        top: 0,
                        left: 0,
                        pointerEvents: "none",
                        visibility: "hidden",
                        width: "200px",
                        height: "150px",
                        overflow: "hidden"
                    });
                    outer.appendChild(inner);
                    document.body.appendChild(outer);
                    var widthContained = inner.offsetWidth;
                    outer.style.overflow = "scroll";
                    var widthScroll = inner.offsetWidth;
                    if (widthContained === widthScroll) widthScroll = outer.clientWidth;
                    document.body.removeChild(outer);
                    var width = widthContained - widthScroll;
                    _scrollBarSize = {
                        width: width,
                        height: width
                    };
                    return _scrollBarSize;
                }
                function extend() {
                    var out = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
                    var args = [];
                    Array.prototype.push.apply(args, arguments);
                    args.slice(1).forEach(function(obj) {
                        if (obj) {
                            for(var key in obj)if (({}).hasOwnProperty.call(obj, key)) out[key] = obj[key];
                        }
                    });
                    return out;
                }
                function removeClass(el, name) {
                    if (typeof el.classList !== "undefined") name.split(" ").forEach(function(cls) {
                        if (cls.trim()) el.classList.remove(cls);
                    });
                    else {
                        var regex = new RegExp("(^| )" + name.split(" ").join("|") + "( |$)", "gi");
                        var className = getClassName(el).replace(regex, " ");
                        setClassName(el, className);
                    }
                }
                function addClass(el, name) {
                    if (typeof el.classList !== "undefined") name.split(" ").forEach(function(cls) {
                        if (cls.trim()) el.classList.add(cls);
                    });
                    else {
                        removeClass(el, name);
                        var cls = getClassName(el) + (" " + name);
                        setClassName(el, cls);
                    }
                }
                function hasClass(el, name) {
                    if (typeof el.classList !== "undefined") return el.classList.contains(name);
                    var className = getClassName(el);
                    return new RegExp("(^| )" + name + "( |$)", "gi").test(className);
                }
                function getClassName(el) {
                    // Can't use just SVGAnimatedString here since nodes within a Frame in IE have
                    // completely separately SVGAnimatedString base classes
                    if (el.className instanceof el.ownerDocument.defaultView.SVGAnimatedString) return el.className.baseVal;
                    return el.className;
                }
                function setClassName(el, className) {
                    el.setAttribute("class", className);
                }
                function updateClasses(el, add, all) {
                    // Of the set of 'all' classes, we need the 'add' classes, and only the
                    // 'add' classes to be set.
                    all.forEach(function(cls) {
                        if (add.indexOf(cls) === -1 && hasClass(el, cls)) removeClass(el, cls);
                    });
                    add.forEach(function(cls) {
                        if (!hasClass(el, cls)) addClass(el, cls);
                    });
                }
                var deferred = [];
                var defer = function defer(fn) {
                    deferred.push(fn);
                };
                var flush = function flush() {
                    var fn = undefined;
                    while(fn = deferred.pop())fn();
                };
                var Evented = function() {
                    function Evented() {
                        _classCallCheck(this, Evented);
                    }
                    _createClass(Evented, [
                        {
                            key: "on",
                            value: function on(event, handler, ctx) {
                                var once = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];
                                if (typeof this.bindings === "undefined") this.bindings = {};
                                if (typeof this.bindings[event] === "undefined") this.bindings[event] = [];
                                this.bindings[event].push({
                                    handler: handler,
                                    ctx: ctx,
                                    once: once
                                });
                            }
                        },
                        {
                            key: "once",
                            value: function once(event, handler, ctx) {
                                this.on(event, handler, ctx, true);
                            }
                        },
                        {
                            key: "off",
                            value: function off(event, handler) {
                                if (typeof this.bindings === "undefined" || typeof this.bindings[event] === "undefined") return;
                                if (typeof handler === "undefined") delete this.bindings[event];
                                else {
                                    var i = 0;
                                    while(i < this.bindings[event].length)if (this.bindings[event][i].handler === handler) this.bindings[event].splice(i, 1);
                                    else ++i;
                                }
                            }
                        },
                        {
                            key: "trigger",
                            value: function trigger(event) {
                                if (typeof this.bindings !== "undefined" && this.bindings[event]) {
                                    var i = 0;
                                    for(var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)args[_key - 1] = arguments[_key];
                                    while(i < this.bindings[event].length){
                                        var _bindings$event$i = this.bindings[event][i];
                                        var handler = _bindings$event$i.handler;
                                        var ctx = _bindings$event$i.ctx;
                                        var once = _bindings$event$i.once;
                                        var context = ctx;
                                        if (typeof context === "undefined") context = this;
                                        handler.apply(context, args);
                                        if (once) this.bindings[event].splice(i, 1);
                                        else ++i;
                                    }
                                }
                            }
                        }
                    ]);
                    return Evented;
                }();
                TetherBase.Utils = {
                    getActualBoundingClientRect: getActualBoundingClientRect,
                    getScrollParents: getScrollParents,
                    getBounds: getBounds,
                    getOffsetParent: getOffsetParent,
                    extend: extend,
                    addClass: addClass,
                    removeClass: removeClass,
                    hasClass: hasClass,
                    updateClasses: updateClasses,
                    defer: defer,
                    flush: flush,
                    uniqueId: uniqueId,
                    Evented: Evented,
                    getScrollBarSize: getScrollBarSize,
                    removeUtilElements: removeUtilElements
                };
                /* globals TetherBase, performance */ "use strict";
                var _slicedToArray = function() {
                    function sliceIterator(arr, i) {
                        var _arr = [];
                        var _n = true;
                        var _d = false;
                        var _e = undefined;
                        try {
                            for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){
                                _arr.push(_s.value);
                                if (i && _arr.length === i) break;
                            }
                        } catch (err) {
                            _d = true;
                            _e = err;
                        } finally{
                            try {
                                if (!_n && _i["return"]) _i["return"]();
                            } finally{
                                if (_d) throw _e;
                            }
                        }
                        return _arr;
                    }
                    return function(arr, i) {
                        if (Array.isArray(arr)) return arr;
                        else if (Symbol.iterator in Object(arr)) return sliceIterator(arr, i);
                        else throw new TypeError("Invalid attempt to destructure non-iterable instance");
                    };
                }();
                var _createClass = function() {
                    function defineProperties(target, props) {
                        for(var i = 0; i < props.length; i++){
                            var descriptor = props[i];
                            descriptor.enumerable = descriptor.enumerable || false;
                            descriptor.configurable = true;
                            if ("value" in descriptor) descriptor.writable = true;
                            Object.defineProperty(target, descriptor.key, descriptor);
                        }
                    }
                    return function(Constructor, protoProps, staticProps) {
                        if (protoProps) defineProperties(Constructor.prototype, protoProps);
                        if (staticProps) defineProperties(Constructor, staticProps);
                        return Constructor;
                    };
                }();
                var _get = function get(_x6, _x7, _x8) {
                    var _again = true;
                    _function: while(_again){
                        var object = _x6, property = _x7, receiver = _x8;
                        _again = false;
                        if (object === null) object = Function.prototype;
                        var desc = Object.getOwnPropertyDescriptor(object, property);
                        if (desc === undefined) {
                            var parent = Object.getPrototypeOf(object);
                            if (parent === null) return undefined;
                            else {
                                _x6 = parent;
                                _x7 = property;
                                _x8 = receiver;
                                _again = true;
                                desc = parent = undefined;
                                continue _function;
                            }
                        } else if ("value" in desc) return desc.value;
                        else {
                            var getter = desc.get;
                            if (getter === undefined) return undefined;
                            return getter.call(receiver);
                        }
                    }
                };
                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
                }
                function _inherits(subClass, superClass) {
                    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeOf._)(superClass)));
                    subClass.prototype = Object.create(superClass && superClass.prototype, {
                        constructor: {
                            value: subClass,
                            enumerable: false,
                            writable: true,
                            configurable: true
                        }
                    });
                    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
                }
                if (typeof TetherBase === "undefined") throw new Error("You must include the utils.js file before tether.js");
                var _TetherBase$Utils = TetherBase.Utils;
                var getScrollParents = _TetherBase$Utils.getScrollParents;
                var getBounds = _TetherBase$Utils.getBounds;
                var getOffsetParent = _TetherBase$Utils.getOffsetParent;
                var extend = _TetherBase$Utils.extend;
                var addClass = _TetherBase$Utils.addClass;
                var removeClass = _TetherBase$Utils.removeClass;
                var updateClasses = _TetherBase$Utils.updateClasses;
                var defer = _TetherBase$Utils.defer;
                var flush = _TetherBase$Utils.flush;
                var getScrollBarSize = _TetherBase$Utils.getScrollBarSize;
                var removeUtilElements = _TetherBase$Utils.removeUtilElements;
                function within(a, b) {
                    var diff = arguments.length <= 2 || arguments[2] === undefined ? 1 : arguments[2];
                    return a + diff >= b && b >= a - diff;
                }
                var transformKey = function() {
                    if (typeof document === "undefined") return "";
                    var el = document.createElement("div");
                    var transforms = [
                        "transform",
                        "WebkitTransform",
                        "OTransform",
                        "MozTransform",
                        "msTransform"
                    ];
                    for(var i = 0; i < transforms.length; ++i){
                        var key = transforms[i];
                        if (el.style[key] !== undefined) return key;
                    }
                }();
                var tethers = [];
                var position = function position() {
                    tethers.forEach(function(tether) {
                        tether.position(false);
                    });
                    flush();
                };
                function now() {
                    if (typeof performance === "object" && typeof performance.now === "function") return performance.now();
                    return +new Date();
                }
                (function() {
                    var lastCall = null;
                    var lastDuration = null;
                    var pendingTimeout = null;
                    var tick = function tick() {
                        if (typeof lastDuration !== "undefined" && lastDuration > 16) {
                            // We voluntarily throttle ourselves if we can't manage 60fps
                            lastDuration = Math.min(lastDuration - 16, 250);
                            // Just in case this is the last event, remember to position just once more
                            pendingTimeout = setTimeout(tick, 250);
                            return;
                        }
                        if (typeof lastCall !== "undefined" && now() - lastCall < 10) // Some browsers call events a little too frequently, refuse to run more than is reasonable
                        return;
                        if (pendingTimeout != null) {
                            clearTimeout(pendingTimeout);
                            pendingTimeout = null;
                        }
                        lastCall = now();
                        position();
                        lastDuration = now() - lastCall;
                    };
                    if (typeof window !== "undefined" && typeof window.addEventListener !== "undefined") [
                        "resize",
                        "scroll",
                        "touchmove"
                    ].forEach(function(event) {
                        window.addEventListener(event, tick);
                    });
                })();
                var MIRROR_LR = {
                    center: "center",
                    left: "right",
                    right: "left"
                };
                var MIRROR_TB = {
                    middle: "middle",
                    top: "bottom",
                    bottom: "top"
                };
                var OFFSET_MAP = {
                    top: 0,
                    left: 0,
                    middle: "50%",
                    center: "50%",
                    bottom: "100%",
                    right: "100%"
                };
                var autoToFixedAttachment = function autoToFixedAttachment(attachment, relativeToAttachment) {
                    var left = attachment.left;
                    var top = attachment.top;
                    if (left === "auto") left = MIRROR_LR[relativeToAttachment.left];
                    if (top === "auto") top = MIRROR_TB[relativeToAttachment.top];
                    return {
                        left: left,
                        top: top
                    };
                };
                var attachmentToOffset = function attachmentToOffset(attachment) {
                    var left = attachment.left;
                    var top = attachment.top;
                    if (typeof OFFSET_MAP[attachment.left] !== "undefined") left = OFFSET_MAP[attachment.left];
                    if (typeof OFFSET_MAP[attachment.top] !== "undefined") top = OFFSET_MAP[attachment.top];
                    return {
                        left: left,
                        top: top
                    };
                };
                function addOffset() {
                    var out = {
                        top: 0,
                        left: 0
                    };
                    for(var _len = arguments.length, offsets = Array(_len), _key = 0; _key < _len; _key++)offsets[_key] = arguments[_key];
                    offsets.forEach(function(_ref) {
                        var top = _ref.top;
                        var left = _ref.left;
                        if (typeof top === "string") top = parseFloat(top, 10);
                        if (typeof left === "string") left = parseFloat(left, 10);
                        out.top += top;
                        out.left += left;
                    });
                    return out;
                }
                function offsetToPx(offset, size) {
                    if (typeof offset.left === "string" && offset.left.indexOf("%") !== -1) offset.left = parseFloat(offset.left, 10) / 100 * size.width;
                    if (typeof offset.top === "string" && offset.top.indexOf("%") !== -1) offset.top = parseFloat(offset.top, 10) / 100 * size.height;
                    return offset;
                }
                var parseOffset = function parseOffset(value) {
                    var _value$split = value.split(" ");
                    var _value$split2 = _slicedToArray(_value$split, 2);
                    var top = _value$split2[0];
                    var left = _value$split2[1];
                    return {
                        top: top,
                        left: left
                    };
                };
                var parseAttachment = parseOffset;
                var TetherClass = function(_Evented) {
                    _inherits(TetherClass, _Evented);
                    function TetherClass(options) {
                        var _this = this;
                        _classCallCheck(this, TetherClass);
                        _get(Object.getPrototypeOf(TetherClass.prototype), "constructor", this).call(this);
                        this.position = this.position.bind(this);
                        tethers.push(this);
                        this.history = [];
                        this.setOptions(options, false);
                        TetherBase.modules.forEach(function(module) {
                            if (typeof module.initialize !== "undefined") module.initialize.call(_this);
                        });
                        this.position();
                    }
                    _createClass(TetherClass, [
                        {
                            key: "getClass",
                            value: function getClass() {
                                var key = arguments.length <= 0 || arguments[0] === undefined ? "" : arguments[0];
                                var classes = this.options.classes;
                                if (typeof classes !== "undefined" && classes[key]) return this.options.classes[key];
                                else if (this.options.classPrefix) return this.options.classPrefix + "-" + key;
                                else return key;
                            }
                        },
                        {
                            key: "setOptions",
                            value: function setOptions(options) {
                                var _this2 = this;
                                var pos = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
                                var defaults = {
                                    offset: "0 0",
                                    targetOffset: "0 0",
                                    targetAttachment: "auto auto",
                                    classPrefix: "tether"
                                };
                                this.options = extend(defaults, options);
                                var _options = this.options;
                                var element = _options.element;
                                var target = _options.target;
                                var targetModifier = _options.targetModifier;
                                this.element = element;
                                this.target = target;
                                this.targetModifier = targetModifier;
                                if (this.target === "viewport") {
                                    this.target = document.body;
                                    this.targetModifier = "visible";
                                } else if (this.target === "scroll-handle") {
                                    this.target = document.body;
                                    this.targetModifier = "scroll-handle";
                                }
                                [
                                    "element",
                                    "target"
                                ].forEach(function(key) {
                                    if (typeof _this2[key] === "undefined") throw new Error("Tether Error: Both element and target must be defined");
                                    if (typeof _this2[key].jquery !== "undefined") _this2[key] = _this2[key][0];
                                    else if (typeof _this2[key] === "string") _this2[key] = document.querySelector(_this2[key]);
                                });
                                addClass(this.element, this.getClass("element"));
                                if (!(this.options.addTargetClasses === false)) addClass(this.target, this.getClass("target"));
                                if (!this.options.attachment) throw new Error("Tether Error: You must provide an attachment");
                                this.targetAttachment = parseAttachment(this.options.targetAttachment);
                                this.attachment = parseAttachment(this.options.attachment);
                                this.offset = parseOffset(this.options.offset);
                                this.targetOffset = parseOffset(this.options.targetOffset);
                                if (typeof this.scrollParents !== "undefined") this.disable();
                                if (this.targetModifier === "scroll-handle") this.scrollParents = [
                                    this.target
                                ];
                                else this.scrollParents = getScrollParents(this.target);
                                if (!(this.options.enabled === false)) this.enable(pos);
                            }
                        },
                        {
                            key: "getTargetBounds",
                            value: function getTargetBounds() {
                                if (typeof this.targetModifier !== "undefined") {
                                    if (this.targetModifier === "visible") {
                                        if (this.target === document.body) return {
                                            top: pageYOffset,
                                            left: pageXOffset,
                                            height: innerHeight,
                                            width: innerWidth
                                        };
                                        else {
                                            var bounds = getBounds(this.target);
                                            var out = {
                                                height: bounds.height,
                                                width: bounds.width,
                                                top: bounds.top,
                                                left: bounds.left
                                            };
                                            out.height = Math.min(out.height, bounds.height - (pageYOffset - bounds.top));
                                            out.height = Math.min(out.height, bounds.height - (bounds.top + bounds.height - (pageYOffset + innerHeight)));
                                            out.height = Math.min(innerHeight, out.height);
                                            out.height -= 2;
                                            out.width = Math.min(out.width, bounds.width - (pageXOffset - bounds.left));
                                            out.width = Math.min(out.width, bounds.width - (bounds.left + bounds.width - (pageXOffset + innerWidth)));
                                            out.width = Math.min(innerWidth, out.width);
                                            out.width -= 2;
                                            if (out.top < pageYOffset) out.top = pageYOffset;
                                            if (out.left < pageXOffset) out.left = pageXOffset;
                                            return out;
                                        }
                                    } else if (this.targetModifier === "scroll-handle") {
                                        var bounds = undefined;
                                        var target = this.target;
                                        if (target === document.body) {
                                            target = document.documentElement;
                                            bounds = {
                                                left: pageXOffset,
                                                top: pageYOffset,
                                                height: innerHeight,
                                                width: innerWidth
                                            };
                                        } else bounds = getBounds(target);
                                        var style = getComputedStyle(target);
                                        var hasBottomScroll = target.scrollWidth > target.clientWidth || [
                                            style.overflow,
                                            style.overflowX
                                        ].indexOf("scroll") >= 0 || this.target !== document.body;
                                        var scrollBottom = 0;
                                        if (hasBottomScroll) scrollBottom = 15;
                                        var height = bounds.height - parseFloat(style.borderTopWidth) - parseFloat(style.borderBottomWidth) - scrollBottom;
                                        var out = {
                                            width: 15,
                                            height: height * 0.975 * (height / target.scrollHeight),
                                            left: bounds.left + bounds.width - parseFloat(style.borderLeftWidth) - 15
                                        };
                                        var fitAdj = 0;
                                        if (height < 408 && this.target === document.body) fitAdj = -0.00011 * Math.pow(height, 2) - 0.00727 * height + 22.58;
                                        if (this.target !== document.body) out.height = Math.max(out.height, 24);
                                        var scrollPercentage = this.target.scrollTop / (target.scrollHeight - height);
                                        out.top = scrollPercentage * (height - out.height - fitAdj) + bounds.top + parseFloat(style.borderTopWidth);
                                        if (this.target === document.body) out.height = Math.max(out.height, 24);
                                        return out;
                                    }
                                } else return getBounds(this.target);
                            }
                        },
                        {
                            key: "clearCache",
                            value: function clearCache() {
                                this._cache = {};
                            }
                        },
                        {
                            key: "cache",
                            value: function cache(k, getter) {
                                // More than one module will often need the same DOM info, so
                                // we keep a cache which is cleared on each position call
                                if (typeof this._cache === "undefined") this._cache = {};
                                if (typeof this._cache[k] === "undefined") this._cache[k] = getter.call(this);
                                return this._cache[k];
                            }
                        },
                        {
                            key: "enable",
                            value: function enable() {
                                var _this3 = this;
                                var pos = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
                                if (!(this.options.addTargetClasses === false)) addClass(this.target, this.getClass("enabled"));
                                addClass(this.element, this.getClass("enabled"));
                                this.enabled = true;
                                this.scrollParents.forEach(function(parent) {
                                    if (parent !== _this3.target.ownerDocument) parent.addEventListener("scroll", _this3.position);
                                });
                                if (pos) this.position();
                            }
                        },
                        {
                            key: "disable",
                            value: function disable() {
                                var _this4 = this;
                                removeClass(this.target, this.getClass("enabled"));
                                removeClass(this.element, this.getClass("enabled"));
                                this.enabled = false;
                                if (typeof this.scrollParents !== "undefined") this.scrollParents.forEach(function(parent) {
                                    parent.removeEventListener("scroll", _this4.position);
                                });
                            }
                        },
                        {
                            key: "destroy",
                            value: function destroy() {
                                var _this5 = this;
                                this.disable();
                                tethers.forEach(function(tether, i) {
                                    if (tether === _this5) tethers.splice(i, 1);
                                });
                                // Remove any elements we were using for convenience from the DOM
                                if (tethers.length === 0) removeUtilElements();
                            }
                        },
                        {
                            key: "updateAttachClasses",
                            value: function updateAttachClasses(elementAttach, targetAttach) {
                                var _this6 = this;
                                elementAttach = elementAttach || this.attachment;
                                targetAttach = targetAttach || this.targetAttachment;
                                var sides = [
                                    "left",
                                    "top",
                                    "bottom",
                                    "right",
                                    "middle",
                                    "center"
                                ];
                                if (typeof this._addAttachClasses !== "undefined" && this._addAttachClasses.length) // updateAttachClasses can be called more than once in a position call, so
                                // we need to clean up after ourselves such that when the last defer gets
                                // ran it doesn't add any extra classes from previous calls.
                                this._addAttachClasses.splice(0, this._addAttachClasses.length);
                                if (typeof this._addAttachClasses === "undefined") this._addAttachClasses = [];
                                var add = this._addAttachClasses;
                                if (elementAttach.top) add.push(this.getClass("element-attached") + "-" + elementAttach.top);
                                if (elementAttach.left) add.push(this.getClass("element-attached") + "-" + elementAttach.left);
                                if (targetAttach.top) add.push(this.getClass("target-attached") + "-" + targetAttach.top);
                                if (targetAttach.left) add.push(this.getClass("target-attached") + "-" + targetAttach.left);
                                var all = [];
                                sides.forEach(function(side) {
                                    all.push(_this6.getClass("element-attached") + "-" + side);
                                    all.push(_this6.getClass("target-attached") + "-" + side);
                                });
                                defer(function() {
                                    if (!(typeof _this6._addAttachClasses !== "undefined")) return;
                                    updateClasses(_this6.element, _this6._addAttachClasses, all);
                                    if (!(_this6.options.addTargetClasses === false)) updateClasses(_this6.target, _this6._addAttachClasses, all);
                                    delete _this6._addAttachClasses;
                                });
                            }
                        },
                        {
                            key: "position",
                            value: function position() {
                                var _this7 = this;
                                var flushChanges = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
                                // flushChanges commits the changes immediately, leave true unless you are positioning multiple
                                // tethers (in which case call Tether.Utils.flush yourself when you're done)
                                if (!this.enabled) return;
                                this.clearCache();
                                // Turn 'auto' attachments into the appropriate corner or edge
                                var targetAttachment = autoToFixedAttachment(this.targetAttachment, this.attachment);
                                this.updateAttachClasses(this.attachment, targetAttachment);
                                var elementPos = this.cache("element-bounds", function() {
                                    return getBounds(_this7.element);
                                });
                                var width = elementPos.width;
                                var height = elementPos.height;
                                if (width === 0 && height === 0 && typeof this.lastSize !== "undefined") {
                                    var _lastSize = this.lastSize;
                                    // We cache the height and width to make it possible to position elements that are
                                    // getting hidden.
                                    width = _lastSize.width;
                                    height = _lastSize.height;
                                } else this.lastSize = {
                                    width: width,
                                    height: height
                                };
                                var targetPos = this.cache("target-bounds", function() {
                                    return _this7.getTargetBounds();
                                });
                                var targetSize = targetPos;
                                // Get an actual px offset from the attachment
                                var offset = offsetToPx(attachmentToOffset(this.attachment), {
                                    width: width,
                                    height: height
                                });
                                var targetOffset = offsetToPx(attachmentToOffset(targetAttachment), targetSize);
                                var manualOffset = offsetToPx(this.offset, {
                                    width: width,
                                    height: height
                                });
                                var manualTargetOffset = offsetToPx(this.targetOffset, targetSize);
                                // Add the manually provided offset
                                offset = addOffset(offset, manualOffset);
                                targetOffset = addOffset(targetOffset, manualTargetOffset);
                                // It's now our goal to make (element position + offset) == (target position + target offset)
                                var left = targetPos.left + targetOffset.left - offset.left;
                                var top = targetPos.top + targetOffset.top - offset.top;
                                for(var i = 0; i < TetherBase.modules.length; ++i){
                                    var _module2 = TetherBase.modules[i];
                                    var ret = _module2.position.call(this, {
                                        left: left,
                                        top: top,
                                        targetAttachment: targetAttachment,
                                        targetPos: targetPos,
                                        elementPos: elementPos,
                                        offset: offset,
                                        targetOffset: targetOffset,
                                        manualOffset: manualOffset,
                                        manualTargetOffset: manualTargetOffset,
                                        scrollbarSize: scrollbarSize,
                                        attachment: this.attachment
                                    });
                                    if (ret === false) return false;
                                    else if (typeof ret === "undefined" || typeof ret !== "object") continue;
                                    else {
                                        top = ret.top;
                                        left = ret.left;
                                    }
                                }
                                // We describe the position three different ways to give the optimizer
                                // a chance to decide the best possible way to position the element
                                // with the fewest repaints.
                                var next = {
                                    // It's position relative to the page (absolute positioning when
                                    // the element is a child of the body)
                                    page: {
                                        top: top,
                                        left: left
                                    },
                                    // It's position relative to the viewport (fixed positioning)
                                    viewport: {
                                        top: top - pageYOffset,
                                        bottom: pageYOffset - top - height + innerHeight,
                                        left: left - pageXOffset,
                                        right: pageXOffset - left - width + innerWidth
                                    }
                                };
                                var doc = this.target.ownerDocument;
                                var win = doc.defaultView;
                                var scrollbarSize = undefined;
                                if (win.innerHeight > doc.documentElement.clientHeight) {
                                    scrollbarSize = this.cache("scrollbar-size", getScrollBarSize);
                                    next.viewport.bottom -= scrollbarSize.height;
                                }
                                if (win.innerWidth > doc.documentElement.clientWidth) {
                                    scrollbarSize = this.cache("scrollbar-size", getScrollBarSize);
                                    next.viewport.right -= scrollbarSize.width;
                                }
                                if ([
                                    "",
                                    "static"
                                ].indexOf(doc.body.style.position) === -1 || [
                                    "",
                                    "static"
                                ].indexOf(doc.body.parentElement.style.position) === -1) {
                                    // Absolute positioning in the body will be relative to the page, not the 'initial containing block'
                                    next.page.bottom = doc.body.scrollHeight - top - height;
                                    next.page.right = doc.body.scrollWidth - left - width;
                                }
                                if (typeof this.options.optimizations !== "undefined" && this.options.optimizations.moveElement !== false && !(typeof this.targetModifier !== "undefined")) (function() {
                                    var offsetParent = _this7.cache("target-offsetparent", function() {
                                        return getOffsetParent(_this7.target);
                                    });
                                    var offsetPosition = _this7.cache("target-offsetparent-bounds", function() {
                                        return getBounds(offsetParent);
                                    });
                                    var offsetParentStyle = getComputedStyle(offsetParent);
                                    var offsetParentSize = offsetPosition;
                                    var offsetBorder = {};
                                    [
                                        "Top",
                                        "Left",
                                        "Bottom",
                                        "Right"
                                    ].forEach(function(side) {
                                        offsetBorder[side.toLowerCase()] = parseFloat(offsetParentStyle["border" + side + "Width"]);
                                    });
                                    offsetPosition.right = doc.body.scrollWidth - offsetPosition.left - offsetParentSize.width + offsetBorder.right;
                                    offsetPosition.bottom = doc.body.scrollHeight - offsetPosition.top - offsetParentSize.height + offsetBorder.bottom;
                                    if (next.page.top >= offsetPosition.top + offsetBorder.top && next.page.bottom >= offsetPosition.bottom) {
                                        if (next.page.left >= offsetPosition.left + offsetBorder.left && next.page.right >= offsetPosition.right) {
                                            // We're within the visible part of the target's scroll parent
                                            var scrollTop = offsetParent.scrollTop;
                                            var scrollLeft = offsetParent.scrollLeft;
                                            // It's position relative to the target's offset parent (absolute positioning when
                                            // the element is moved to be a child of the target's offset parent).
                                            next.offset = {
                                                top: next.page.top - offsetPosition.top + scrollTop - offsetBorder.top,
                                                left: next.page.left - offsetPosition.left + scrollLeft - offsetBorder.left
                                            };
                                        }
                                    }
                                })();
                                // We could also travel up the DOM and try each containing context, rather than only
                                // looking at the body, but we're gonna get diminishing returns.
                                this.move(next);
                                this.history.unshift(next);
                                if (this.history.length > 3) this.history.pop();
                                if (flushChanges) flush();
                                return true;
                            }
                        },
                        {
                            key: "move",
                            value: function move(pos) {
                                var _this8 = this;
                                if (!(typeof this.element.parentNode !== "undefined")) return;
                                var same = {};
                                for(var type in pos){
                                    same[type] = {};
                                    for(var key in pos[type]){
                                        var found = false;
                                        for(var i = 0; i < this.history.length; ++i){
                                            var point = this.history[i];
                                            if (typeof point[type] !== "undefined" && !within(point[type][key], pos[type][key])) {
                                                found = true;
                                                break;
                                            }
                                        }
                                        if (!found) same[type][key] = true;
                                    }
                                }
                                var css = {
                                    top: "",
                                    left: "",
                                    right: "",
                                    bottom: ""
                                };
                                var transcribe = function transcribe(_same, _pos) {
                                    var hasOptimizations = typeof _this8.options.optimizations !== "undefined";
                                    var gpu = hasOptimizations ? _this8.options.optimizations.gpu : null;
                                    if (gpu !== false) {
                                        var yPos = undefined, xPos = undefined;
                                        if (_same.top) {
                                            css.top = 0;
                                            yPos = _pos.top;
                                        } else {
                                            css.bottom = 0;
                                            yPos = -_pos.bottom;
                                        }
                                        if (_same.left) {
                                            css.left = 0;
                                            xPos = _pos.left;
                                        } else {
                                            css.right = 0;
                                            xPos = -_pos.right;
                                        }
                                        if (typeof window.devicePixelRatio === "number" && devicePixelRatio % 1 === 0) {
                                            xPos = Math.round(xPos * devicePixelRatio) / devicePixelRatio;
                                            yPos = Math.round(yPos * devicePixelRatio) / devicePixelRatio;
                                        }
                                        css[transformKey] = "translateX(" + xPos + "px) translateY(" + yPos + "px)";
                                        if (transformKey !== "msTransform") // The Z transform will keep this in the GPU (faster, and prevents artifacts),
                                        // but IE9 doesn't support 3d transforms and will choke.
                                        css[transformKey] += " translateZ(0)";
                                    } else {
                                        if (_same.top) css.top = _pos.top + "px";
                                        else css.bottom = _pos.bottom + "px";
                                        if (_same.left) css.left = _pos.left + "px";
                                        else css.right = _pos.right + "px";
                                    }
                                };
                                var moved = false;
                                if ((same.page.top || same.page.bottom) && (same.page.left || same.page.right)) {
                                    css.position = "absolute";
                                    transcribe(same.page, pos.page);
                                } else if ((same.viewport.top || same.viewport.bottom) && (same.viewport.left || same.viewport.right)) {
                                    css.position = "fixed";
                                    transcribe(same.viewport, pos.viewport);
                                } else if (typeof same.offset !== "undefined" && same.offset.top && same.offset.left) (function() {
                                    css.position = "absolute";
                                    var offsetParent = _this8.cache("target-offsetparent", function() {
                                        return getOffsetParent(_this8.target);
                                    });
                                    if (getOffsetParent(_this8.element) !== offsetParent) defer(function() {
                                        _this8.element.parentNode.removeChild(_this8.element);
                                        offsetParent.appendChild(_this8.element);
                                    });
                                    transcribe(same.offset, pos.offset);
                                    moved = true;
                                })();
                                else {
                                    css.position = "absolute";
                                    transcribe({
                                        top: true,
                                        left: true
                                    }, pos.page);
                                }
                                if (!moved) {
                                    if (this.options.bodyElement) {
                                        if (this.element.parentNode !== this.options.bodyElement) this.options.bodyElement.appendChild(this.element);
                                    } else {
                                        var isFullscreenElement = function isFullscreenElement(e) {
                                            var d = e.ownerDocument;
                                            var fe = d.fullscreenElement || d.webkitFullscreenElement || d.mozFullScreenElement || d.msFullscreenElement;
                                            return fe === e;
                                        };
                                        var offsetParentIsBody = true;
                                        var currentNode = this.element.parentNode;
                                        while(currentNode && currentNode.nodeType === 1 && currentNode.tagName !== "BODY" && !isFullscreenElement(currentNode)){
                                            if (getComputedStyle(currentNode).position !== "static") {
                                                offsetParentIsBody = false;
                                                break;
                                            }
                                            currentNode = currentNode.parentNode;
                                        }
                                        if (!offsetParentIsBody) {
                                            this.element.parentNode.removeChild(this.element);
                                            this.element.ownerDocument.body.appendChild(this.element);
                                        }
                                    }
                                }
                                // Any css change will trigger a repaint, so let's avoid one if nothing changed
                                var writeCSS = {};
                                var write = false;
                                for(var key in css){
                                    var val = css[key];
                                    var elVal = this.element.style[key];
                                    if (elVal !== val) {
                                        write = true;
                                        writeCSS[key] = val;
                                    }
                                }
                                if (write) defer(function() {
                                    extend(_this8.element.style, writeCSS);
                                    _this8.trigger("repositioned");
                                });
                            }
                        }
                    ]);
                    return TetherClass;
                }(Evented);
                TetherClass.modules = [];
                TetherBase.position = position;
                var Tether = extend(TetherClass, TetherBase);
                /* globals TetherBase */ "use strict";
                var _slicedToArray = function() {
                    function sliceIterator(arr, i) {
                        var _arr = [];
                        var _n = true;
                        var _d = false;
                        var _e = undefined;
                        try {
                            for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){
                                _arr.push(_s.value);
                                if (i && _arr.length === i) break;
                            }
                        } catch (err) {
                            _d = true;
                            _e = err;
                        } finally{
                            try {
                                if (!_n && _i["return"]) _i["return"]();
                            } finally{
                                if (_d) throw _e;
                            }
                        }
                        return _arr;
                    }
                    return function(arr, i) {
                        if (Array.isArray(arr)) return arr;
                        else if (Symbol.iterator in Object(arr)) return sliceIterator(arr, i);
                        else throw new TypeError("Invalid attempt to destructure non-iterable instance");
                    };
                }();
                var _TetherBase$Utils = TetherBase.Utils;
                var getBounds = _TetherBase$Utils.getBounds;
                var extend = _TetherBase$Utils.extend;
                var updateClasses = _TetherBase$Utils.updateClasses;
                var defer = _TetherBase$Utils.defer;
                var BOUNDS_FORMAT = [
                    "left",
                    "top",
                    "right",
                    "bottom"
                ];
                function getBoundingRect(tether, to) {
                    if (to === "scrollParent") to = tether.scrollParents[0];
                    else if (to === "window") to = [
                        pageXOffset,
                        pageYOffset,
                        innerWidth + pageXOffset,
                        innerHeight + pageYOffset
                    ];
                    if (to === document) to = to.documentElement;
                    if (typeof to.nodeType !== "undefined") (function() {
                        var node = to;
                        var size = getBounds(to);
                        var pos = size;
                        var style = getComputedStyle(to);
                        to = [
                            pos.left,
                            pos.top,
                            size.width + pos.left,
                            size.height + pos.top
                        ];
                        // Account any parent Frames scroll offset
                        if (node.ownerDocument !== document) {
                            var win = node.ownerDocument.defaultView;
                            to[0] += win.pageXOffset;
                            to[1] += win.pageYOffset;
                            to[2] += win.pageXOffset;
                            to[3] += win.pageYOffset;
                        }
                        BOUNDS_FORMAT.forEach(function(side, i) {
                            side = side[0].toUpperCase() + side.substr(1);
                            if (side === "Top" || side === "Left") to[i] += parseFloat(style["border" + side + "Width"]);
                            else to[i] -= parseFloat(style["border" + side + "Width"]);
                        });
                    })();
                    return to;
                }
                TetherBase.modules.push({
                    position: function position(_ref) {
                        var _this = this;
                        var top = _ref.top;
                        var left = _ref.left;
                        var targetAttachment = _ref.targetAttachment;
                        if (!this.options.constraints) return true;
                        var _cache = this.cache("element-bounds", function() {
                            return getBounds(_this.element);
                        });
                        var height = _cache.height;
                        var width = _cache.width;
                        if (width === 0 && height === 0 && typeof this.lastSize !== "undefined") {
                            var _lastSize = this.lastSize;
                            // Handle the item getting hidden as a result of our positioning without glitching
                            // the classes in and out
                            width = _lastSize.width;
                            height = _lastSize.height;
                        }
                        var targetSize = this.cache("target-bounds", function() {
                            return _this.getTargetBounds();
                        });
                        var targetHeight = targetSize.height;
                        var targetWidth = targetSize.width;
                        var allClasses = [
                            this.getClass("pinned"),
                            this.getClass("out-of-bounds")
                        ];
                        this.options.constraints.forEach(function(constraint) {
                            var outOfBoundsClass = constraint.outOfBoundsClass;
                            var pinnedClass = constraint.pinnedClass;
                            if (outOfBoundsClass) allClasses.push(outOfBoundsClass);
                            if (pinnedClass) allClasses.push(pinnedClass);
                        });
                        allClasses.forEach(function(cls) {
                            [
                                "left",
                                "top",
                                "right",
                                "bottom"
                            ].forEach(function(side) {
                                allClasses.push(cls + "-" + side);
                            });
                        });
                        var addClasses = [];
                        var tAttachment = extend({}, targetAttachment);
                        var eAttachment = extend({}, this.attachment);
                        this.options.constraints.forEach(function(constraint) {
                            var to = constraint.to;
                            var attachment = constraint.attachment;
                            var pin = constraint.pin;
                            if (typeof attachment === "undefined") attachment = "";
                            var changeAttachX = undefined, changeAttachY = undefined;
                            if (attachment.indexOf(" ") >= 0) {
                                var _attachment$split = attachment.split(" ");
                                var _attachment$split2 = _slicedToArray(_attachment$split, 2);
                                changeAttachY = _attachment$split2[0];
                                changeAttachX = _attachment$split2[1];
                            } else changeAttachX = changeAttachY = attachment;
                            var bounds = getBoundingRect(_this, to);
                            if (changeAttachY === "target" || changeAttachY === "both") {
                                if (top < bounds[1] && tAttachment.top === "top") {
                                    top += targetHeight;
                                    tAttachment.top = "bottom";
                                }
                                if (top + height > bounds[3] && tAttachment.top === "bottom") {
                                    top -= targetHeight;
                                    tAttachment.top = "top";
                                }
                            }
                            if (changeAttachY === "together") {
                                if (tAttachment.top === "top") {
                                    if (eAttachment.top === "bottom" && top < bounds[1]) {
                                        top += targetHeight;
                                        tAttachment.top = "bottom";
                                        top += height;
                                        eAttachment.top = "top";
                                    } else if (eAttachment.top === "top" && top + height > bounds[3] && top - (height - targetHeight) >= bounds[1]) {
                                        top -= height - targetHeight;
                                        tAttachment.top = "bottom";
                                        eAttachment.top = "bottom";
                                    }
                                }
                                if (tAttachment.top === "bottom") {
                                    if (eAttachment.top === "top" && top + height > bounds[3]) {
                                        top -= targetHeight;
                                        tAttachment.top = "top";
                                        top -= height;
                                        eAttachment.top = "bottom";
                                    } else if (eAttachment.top === "bottom" && top < bounds[1] && top + (height * 2 - targetHeight) <= bounds[3]) {
                                        top += height - targetHeight;
                                        tAttachment.top = "top";
                                        eAttachment.top = "top";
                                    }
                                }
                                if (tAttachment.top === "middle") {
                                    if (top + height > bounds[3] && eAttachment.top === "top") {
                                        top -= height;
                                        eAttachment.top = "bottom";
                                    } else if (top < bounds[1] && eAttachment.top === "bottom") {
                                        top += height;
                                        eAttachment.top = "top";
                                    }
                                }
                            }
                            if (changeAttachX === "target" || changeAttachX === "both") {
                                if (left < bounds[0] && tAttachment.left === "left") {
                                    left += targetWidth;
                                    tAttachment.left = "right";
                                }
                                if (left + width > bounds[2] && tAttachment.left === "right") {
                                    left -= targetWidth;
                                    tAttachment.left = "left";
                                }
                            }
                            if (changeAttachX === "together") {
                                if (left < bounds[0] && tAttachment.left === "left") {
                                    if (eAttachment.left === "right") {
                                        left += targetWidth;
                                        tAttachment.left = "right";
                                        left += width;
                                        eAttachment.left = "left";
                                    } else if (eAttachment.left === "left") {
                                        left += targetWidth;
                                        tAttachment.left = "right";
                                        left -= width;
                                        eAttachment.left = "right";
                                    }
                                } else if (left + width > bounds[2] && tAttachment.left === "right") {
                                    if (eAttachment.left === "left") {
                                        left -= targetWidth;
                                        tAttachment.left = "left";
                                        left -= width;
                                        eAttachment.left = "right";
                                    } else if (eAttachment.left === "right") {
                                        left -= targetWidth;
                                        tAttachment.left = "left";
                                        left += width;
                                        eAttachment.left = "left";
                                    }
                                } else if (tAttachment.left === "center") {
                                    if (left + width > bounds[2] && eAttachment.left === "left") {
                                        left -= width;
                                        eAttachment.left = "right";
                                    } else if (left < bounds[0] && eAttachment.left === "right") {
                                        left += width;
                                        eAttachment.left = "left";
                                    }
                                }
                            }
                            if (changeAttachY === "element" || changeAttachY === "both") {
                                if (top < bounds[1] && eAttachment.top === "bottom") {
                                    top += height;
                                    eAttachment.top = "top";
                                }
                                if (top + height > bounds[3] && eAttachment.top === "top") {
                                    top -= height;
                                    eAttachment.top = "bottom";
                                }
                            }
                            if (changeAttachX === "element" || changeAttachX === "both") {
                                if (left < bounds[0]) {
                                    if (eAttachment.left === "right") {
                                        left += width;
                                        eAttachment.left = "left";
                                    } else if (eAttachment.left === "center") {
                                        left += width / 2;
                                        eAttachment.left = "left";
                                    }
                                }
                                if (left + width > bounds[2]) {
                                    if (eAttachment.left === "left") {
                                        left -= width;
                                        eAttachment.left = "right";
                                    } else if (eAttachment.left === "center") {
                                        left -= width / 2;
                                        eAttachment.left = "right";
                                    }
                                }
                            }
                            if (typeof pin === "string") pin = pin.split(",").map(function(p) {
                                return p.trim();
                            });
                            else if (pin === true) pin = [
                                "top",
                                "left",
                                "right",
                                "bottom"
                            ];
                            pin = pin || [];
                            var pinned = [];
                            var oob = [];
                            if (top < bounds[1]) {
                                if (pin.indexOf("top") >= 0) {
                                    top = bounds[1];
                                    pinned.push("top");
                                } else oob.push("top");
                            }
                            if (top + height > bounds[3]) {
                                if (pin.indexOf("bottom") >= 0) {
                                    top = bounds[3] - height;
                                    pinned.push("bottom");
                                } else oob.push("bottom");
                            }
                            if (left < bounds[0]) {
                                if (pin.indexOf("left") >= 0) {
                                    left = bounds[0];
                                    pinned.push("left");
                                } else oob.push("left");
                            }
                            if (left + width > bounds[2]) {
                                if (pin.indexOf("right") >= 0) {
                                    left = bounds[2] - width;
                                    pinned.push("right");
                                } else oob.push("right");
                            }
                            if (pinned.length) (function() {
                                var pinnedClass = undefined;
                                if (typeof _this.options.pinnedClass !== "undefined") pinnedClass = _this.options.pinnedClass;
                                else pinnedClass = _this.getClass("pinned");
                                addClasses.push(pinnedClass);
                                pinned.forEach(function(side) {
                                    addClasses.push(pinnedClass + "-" + side);
                                });
                            })();
                            if (oob.length) (function() {
                                var oobClass = undefined;
                                if (typeof _this.options.outOfBoundsClass !== "undefined") oobClass = _this.options.outOfBoundsClass;
                                else oobClass = _this.getClass("out-of-bounds");
                                addClasses.push(oobClass);
                                oob.forEach(function(side) {
                                    addClasses.push(oobClass + "-" + side);
                                });
                            })();
                            if (pinned.indexOf("left") >= 0 || pinned.indexOf("right") >= 0) eAttachment.left = tAttachment.left = false;
                            if (pinned.indexOf("top") >= 0 || pinned.indexOf("bottom") >= 0) eAttachment.top = tAttachment.top = false;
                            if (tAttachment.top !== targetAttachment.top || tAttachment.left !== targetAttachment.left || eAttachment.top !== _this.attachment.top || eAttachment.left !== _this.attachment.left) {
                                _this.updateAttachClasses(eAttachment, tAttachment);
                                _this.trigger("update", {
                                    attachment: eAttachment,
                                    targetAttachment: tAttachment
                                });
                            }
                        });
                        defer(function() {
                            if (!(_this.options.addTargetClasses === false)) updateClasses(_this.target, addClasses, allClasses);
                            updateClasses(_this.element, addClasses, allClasses);
                        });
                        return {
                            top: top,
                            left: left
                        };
                    }
                });
                /* globals TetherBase */ "use strict";
                var _TetherBase$Utils = TetherBase.Utils;
                var getBounds = _TetherBase$Utils.getBounds;
                var updateClasses = _TetherBase$Utils.updateClasses;
                var defer = _TetherBase$Utils.defer;
                TetherBase.modules.push({
                    position: function position(_ref) {
                        var _this = this;
                        var top = _ref.top;
                        var left = _ref.left;
                        var _cache = this.cache("element-bounds", function() {
                            return getBounds(_this.element);
                        });
                        var height = _cache.height;
                        var width = _cache.width;
                        var targetPos = this.getTargetBounds();
                        var bottom = top + height;
                        var right = left + width;
                        var abutted = [];
                        if (top <= targetPos.bottom && bottom >= targetPos.top) [
                            "left",
                            "right"
                        ].forEach(function(side) {
                            var targetPosSide = targetPos[side];
                            if (targetPosSide === left || targetPosSide === right) abutted.push(side);
                        });
                        if (left <= targetPos.right && right >= targetPos.left) [
                            "top",
                            "bottom"
                        ].forEach(function(side) {
                            var targetPosSide = targetPos[side];
                            if (targetPosSide === top || targetPosSide === bottom) abutted.push(side);
                        });
                        var allClasses = [];
                        var addClasses = [];
                        var sides = [
                            "left",
                            "top",
                            "right",
                            "bottom"
                        ];
                        allClasses.push(this.getClass("abutted"));
                        sides.forEach(function(side) {
                            allClasses.push(_this.getClass("abutted") + "-" + side);
                        });
                        if (abutted.length) addClasses.push(this.getClass("abutted"));
                        abutted.forEach(function(side) {
                            addClasses.push(_this.getClass("abutted") + "-" + side);
                        });
                        defer(function() {
                            if (!(_this.options.addTargetClasses === false)) updateClasses(_this.target, addClasses, allClasses);
                            updateClasses(_this.element, addClasses, allClasses);
                        });
                        return true;
                    }
                });
                /* globals TetherBase */ "use strict";
                var _slicedToArray = function() {
                    function sliceIterator(arr, i) {
                        var _arr = [];
                        var _n = true;
                        var _d = false;
                        var _e = undefined;
                        try {
                            for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){
                                _arr.push(_s.value);
                                if (i && _arr.length === i) break;
                            }
                        } catch (err) {
                            _d = true;
                            _e = err;
                        } finally{
                            try {
                                if (!_n && _i["return"]) _i["return"]();
                            } finally{
                                if (_d) throw _e;
                            }
                        }
                        return _arr;
                    }
                    return function(arr, i) {
                        if (Array.isArray(arr)) return arr;
                        else if (Symbol.iterator in Object(arr)) return sliceIterator(arr, i);
                        else throw new TypeError("Invalid attempt to destructure non-iterable instance");
                    };
                }();
                TetherBase.modules.push({
                    position: function position(_ref) {
                        var top = _ref.top;
                        var left = _ref.left;
                        if (!this.options.shift) return;
                        var shift = this.options.shift;
                        if (typeof this.options.shift === "function") shift = this.options.shift.call(this, {
                            top: top,
                            left: left
                        });
                        var shiftTop = undefined, shiftLeft = undefined;
                        if (typeof shift === "string") {
                            shift = shift.split(" ");
                            shift[1] = shift[1] || shift[0];
                            var _shift = shift;
                            var _shift2 = _slicedToArray(_shift, 2);
                            shiftTop = _shift2[0];
                            shiftLeft = _shift2[1];
                            shiftTop = parseFloat(shiftTop, 10);
                            shiftLeft = parseFloat(shiftLeft, 10);
                        } else {
                            shiftTop = shift.top;
                            shiftLeft = shift.left;
                        }
                        top += shiftTop;
                        left += shiftLeft;
                        return {
                            top: top,
                            left: left
                        };
                    }
                });
                return Tether;
            });
        },
        {}
    ],
    21: [
        function(require1, module, exports) {
            window.dataLayer = window.dataLayer || [];
            window.gtag = function() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                window.dataLayer.push(arguments);
            };
            var gtagConfigEl = document.getElementById("gtag-config");
            if (gtagConfigEl) {
                var gtagConfig = JSON.parse(gtagConfigEl.innerText);
                window.gtag("js", new Date());
                window.gtag("config", gtagConfig["GA_TRACKING_ID"]);
                window.gtag("config", gtagConfig["AW_TRACKING_ID"]);
            }
        },
        {}
    ],
    22: [
        function(require1, module, exports) {
            (function(global) {
                (function() {
                    "use strict";
                    var __importDefault = this && this.__importDefault || function(mod) {
                        return mod && mod.__esModule ? mod : {
                            "default": mod
                        };
                    };
                    Object.defineProperty(exports, "__esModule", {
                        value: true
                    });
                    var jquery_1 = __importDefault(require1("jquery"));
                    var jquery_2 = __importDefault(require1("jquery")); // Bootstrap dependency
                    var tether_1 = __importDefault(require1("tether")); // Bootstrap dependency
                    var popper_js_1 = __importDefault(require1("popper.js")); // Bootstrap dependency
                    var aos_1 = __importDefault(require1("aos"));
                    require1("bootstrap");
                    require1("parsleyjs");
                    require1("./gtag");
                    // Assigning libraries to global scope
                    global.$ = jquery_1.default;
                    global.jQuery = jquery_2.default;
                    global.Tether = tether_1.default;
                    global.Popper = popper_js_1.default;
                    require1("imagesloaded");
                    require1("isotope-layout");
                    (0, jquery_1.default)(document).ready(function() {
                        aos_1.default.init();
                    });
                }).call(this);
            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        },
        {
            "./gtag": 21,
            "aos": 2,
            "bootstrap": 1,
            "imagesloaded": 7,
            "isotope-layout": 8,
            "jquery": 14,
            "parsleyjs": 18,
            "popper.js": 19,
            "tether": 20
        }
    ]
}, {}, [
    22
]);

},{"@swc/helpers/_/_type_of":"dSW1g"}],"dSW1g":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_", function() {
    return _type_of;
});
function _type_of(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"iBm0a"}]},["dtPYO"], "dtPYO", "parcelRequire874f")

//# sourceMappingURL=base_revamp.31e85fe3.js.map
